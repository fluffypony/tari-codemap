# Tari

**Repository:** https://github.com/tari-project/tari
**Branch:** development

## Project Overview

## An In-Depth Overview of the Tari Codebase

### Introduction

Welcome to the Tari codebase. This document provides a comprehensive technical overview designed to onboard new developers.

Tari is a decentralized, open-source, private-by-default blockchain protocol built in Rust. It is designed for the management and transfer of digital assets. The protocol merges the privacy-preserving features of the Mimblewimble blockchain protocol with the robust security of the Monero project through merge-mining.

The project is structured as a monorepo containing multiple Rust crates, organized into distinct layers: low-level infrastructure, peer-to-peer communications, a core blockchain base layer, and user-facing applications. This modular design promotes code reuse and clear separation of concerns.

This guide will walk you through the architecture, core components, key workflows, and development practices of the Tari project.

### 1. Directory Structure

The Tari repository is a Cargo workspace containing numerous crates. The top-level structure is organized by functionality, reflecting the system's layered architecture.

```
.
├── applications/         # End-user applications (binaries)
│   ├── minotari_node/        # The full blockchain node
│   ├── minotari_console_wallet/ # A terminal-based wallet
│   ├── minotari_miner/       # Standalone SHA3X miner
│   └── minotari_merge_mining_proxy/ # Proxy for merge-mining with Monero
├── base_layer/           # Core blockchain protocol and logic
│   ├── core/               # Fundamental types: Blocks, Transactions, Consensus, Validation
│   ├── comms/              # Peer-to-peer communication framework
│   ├── p2p/                # P2P services built on top of comms
│   ├── wallet/             # The core wallet library (used by applications)
│   └── key_manager/        # Cryptographic key management service
├── clients/              # Client libraries for different languages
│   ├── ffi_client/         # NodeJS example using the FFI library
│   └── rust/               # Rust gRPC clients for the Base Node and Wallet
├── common/               # Shared utilities used across the entire workspace
│   ├── config/             # Default configuration files
│   └── logging/            # Logging setup and configuration
├── comms/                # The low-level P2P communication stack
│   ├── core/               # Core networking primitives (transports, multiplexing, encryption)
│   └── dht/                # Distributed Hash Table for peer discovery and message routing
├── infrastructure/       # Foundational, reusable library crates
│   ├── storage/            # Key-value store abstractions (LMDB)
│   ├── tari_script/        # Tari's scripting language VM
│   ├── metrics/            # Prometheus metrics collection
│   └── shutdown/           # Graceful shutdown signaling
├── integration_tests/    # End-to-end BDD tests using Cucumber
├── .github/workflows/    # CI/CD automation pipelines
└── scripts/              # Build, release, and utility scripts
```

### 2. Overall Architecture

Tari's architecture is a multi-layered system designed for modularity, security, and extensibility. At its core, it's a Rust project structured as a single monorepo but composed of many loosely-coupled crates.

#### Architectural Layers

1. **Infrastructure Layer (`infrastructure/`)**: This is the lowest level, providing foundational, domain-agnostic components. Crates here include `tari_script` (a simple stack-based VM for transaction validation), `storage` (an abstraction over key-value stores like LMDB), `metrics`, and `shutdown` signaling. These components have minimal dependencies on the rest of the Tari codebase.

2. **Communications (Comms) Layer (`comms/`)**: This layer provides the peer-to-peer networking stack. It's responsible for establishing secure, authenticated, and multiplexed connections between nodes.
   * `comms/core`: Implements the fundamental networking primitives: various transports (TCP, Tor, in-memory), Noise protocol encryption (`noise`), stream multiplexing (`yamux`), and peer/connection management.
   * `comms/dht`: Builds upon `comms/core` to implement a Kademlia-based Distributed Hash Table (DHT) for peer discovery and robust message routing.

3. **Base Layer (`base_layer/`)**: This is the heart of the Tari protocol. It contains all the logic for the blockchain itself.
   * `base_layer/core`: Defines the core data structures (`Block`, `Transaction`), consensus rules, validation logic, and the blockchain database (`chain_storage`).
   * `base_layer/p2p`: Integrates the `comms` layer to build specific P2P services for the base node, such as block and transaction propagation.
   * `base_layer/wallet` & `key_manager`: These are libraries that provide the core logic for wallet functionality and secure key management, respectively. They are used by wallet applications.

4. **Applications Layer (`applications/`)**: These are the final executables that users and node operators interact with. They assemble the various libraries from the lower layers into functional programs.
   * `minotari_node`: The full base node daemon.
   * `minotari_console_wallet`: A TUI/CLI wallet application.
   * `minotari_miner`: A standalone miner for the SHA3X PoW algorithm.
   * `minotari_merge_mining_proxy`: A proxy that allows Monero miners (like XMRig) to merge-mine Tari.

#### Component Interaction and Data Flow

Communication between components happens through two primary mechanisms:

1. **Inter-process Communication (gRPC)**: Applications (like the wallet or a block explorer) communicate with the Base Node daemon using gRPC. The `minotari_app_grpc` crate defines all the protocol buffer schemas (`.proto` files) and generates the corresponding Rust code, serving as a single source of truth for the gRPC API. This provides a strongly-typed, language-agnostic interface for external tools.

2. **Intra-process Communication (Service Framework & Actor Model)**: Within a single process (like the `minotari_node`), components are structured as long-running services that communicate asynchronously via message-passing channels. The `tari_service_framework` provides the infrastructure for this, resembling the Actor model. Each major component (e.g., `ConnectionManager`, `DhtActor`, `Mempool`) runs in its own async task and exposes a "handle" for other services to send requests to it.

A typical data flow for a transaction looks like this:

1. A user initiates a transaction in the `minotari_console_wallet`.
2. The wallet application makes a `send_transaction` gRPC call to a running `minotari_node`.
3. The `minotari_node`'s gRPC server receives the request and passes it to its `Mempool` service.
4. The `Mempool` (`base_layer/core/src/mempool`) validates the transaction and, if valid, stores it in the unconfirmed pool.
5. The `Mempool` service then uses the `Dht` (`comms/dht`) to propagate this new transaction to its peers.
6. Other nodes receive the transaction, validate it, and add it to their own mempools.
7. A miner (either `minotari_miner` or a merge miner via the `minotari_merge_mining_proxy`) requests a block template from its base node via a gRPC call.
8. The base node constructs a template including transactions from its mempool.
9. The miner finds a valid Proof of Work and submits the completed block back to the base node.
10. The `minotari_node` uses its `ChainStorage` (`base_layer/core/src/chain_storage`) and `Validation` (`base_layer/core/src/validation`) components to validate and add the block to its local blockchain database.
11. The new block is then propagated to peers.

[Tari Architecture Diagram](https://raw.githubusercontent.com/tari-project/tari/development/docs/src/diagrams/comms/index.png)

### 3. Core Business Logic and Main Workflows

The Tari protocol's primary goal is to facilitate the creation and transfer of digital assets in a private and scalable manner.

#### Mimblewimble and Privacy

Tari is built on the Mimblewimble protocol, which provides privacy and scalability by default. Key concepts include:

* **Confidential Transactions**: Transaction amounts are cryptographically hidden using Pedersen Commitments. Only the sender and receiver can verify the amounts.
* **No Addresses on-chain**: There are no public addresses recorded on the blockchain. Transactions are built interactively between sender and receiver wallets.
* **Cut-through**: Intermediate transactions in a block can be "cut through," meaning only the net effect of inputs and outputs remains on the chain. This significantly reduces blockchain bloat and improves scalability.

A Tari transaction consists of three main parts, defined in `base_layer/core/src/transactions/transaction_components`:
* **Inputs**: References to previous Unspent Transaction Outputs (UTXOs) that are being spent.
* **Outputs**: New UTXOs being created. Each output contains a commitment, a range proof (to prove the amount is positive), and a TariScript.
* **Kernels**: Contain the excess commitment (proving the transaction balances to zero), the transaction fee, and an aggregate signature from all participants.

#### Hybrid Proof-of-Work

Tari uses a hybrid Proof-of-Work (PoW) system to secure the network, allowing participation from different types of hardware and leveraging the security of an established network.

1. **SHA3X**: A custom, ASIC-resistant PoW algorithm designed for standalone Tari mining. This is implemented in `base_layer/core/src/proof_of_work/sha3x_pow.rs` and is the target for the `minotari_miner` application.

2. **RandomX**: The same algorithm used by Monero. This enables **merge-mining**, where Monero miners can submit their PoW solutions to the Tari network simultaneously, without any additional mining cost. This bootstraps Tari's security by piggybacking on Monero's significant hash rate. The `minotari_merge_mining_proxy` facilitates this by acting as a bridge between standard Monero mining software (like XMRig) and a Tari node.

#### Node Synchronization Workflow

When a new node joins the network, it must synchronize its state with its peers. This is managed by a sophisticated state machine found in `base_layer/core/src/base_node/state_machine_service`.

1. **Starting**: The node initializes and bootstraps its connection to the DHT network.
2. **Listening**: The node listens for chain metadata from its peers to determine the network's current state (tip height, total accumulated difficulty).
3. **Header Sync**: If the node is behind, it enters `HeaderSync` state. It downloads and validates block headers in batches from the peer with the strongest chain (highest accumulated difficulty). This is much faster than downloading full blocks.
4. **Decide Next Sync**: After syncing headers, the node decides how to sync the block bodies.
5. **Horizon Sync (for Pruned Nodes)**: A pruned node doesn't store the full blockchain history. Instead, it performs a "horizon sync" where it downloads only the set of current UTXOs and corresponding kernel data, which is much smaller than the full block history.
6. **Block Sync (for Archival Nodes)**: An archival node downloads all historical block bodies from its peers to build a complete copy of the blockchain.
7. Once synchronized, the node returns to the **Listening** state, where it processes new blocks and transactions as they are propagated through the network.

#### Digital Asset Network (DAN) - Future Work

The codebase contains significant groundwork for a second-layer Digital Asset Network (DAN). This layer will enable the creation and management of various digital assets on top of the Tari base layer. Key components related to this include:
* `validator_node.proto` and related sidechain features in `sidechain_feature.proto`.
* `TemplateRegistration` features for deploying smart contract-like templates.
* `ValidatorNodeRegistration` features for nodes to register as validators on the second layer.

### 4. Key Technical Patterns and Conventions

The Tari codebase adheres to modern Rust best practices and employs several key design patterns to ensure robustness, maintainability, and security.

* **Actor Model via Service Framework**: The system is heavily based on an actor-like architecture where concurrent components (services) are isolated and communicate asynchronously via message channels. The `tari_service_framework` crate provides the foundation for this, allowing developers to define services, their request/response messages, and their initializers. This pattern simplifies concurrency and prevents deadlocks.

* **Builder Pattern**: For objects with complex configurations, the builder pattern is used extensively. `CommsBuilder`, `DhtBuilder`, `BlockBuilder`, and `TransactionBuilder` are prime examples. This provides a fluent, readable, and type-safe way to construct complex objects.

* **Foreign Function Interface (FFI)**: A key goal is to support mobile wallets. The `minotari_wallet_ffi` crate exposes the core wallet logic through a C-compatible API. The `build.rs` script uses `cbindgen` to automatically generate the C header file (`wallet.h`), ensuring the Rust and C interfaces stay in sync.

* **Protocol Buffers and gRPC**: All inter-application communication relies on gRPC, with `tonic` as the Rust implementation. Protocol definitions are centralized in the `minotari_app_grpc` crate's `.proto` files, which act as the authoritative schema for communication between the base node, wallet, miner, and other tools.

* **Comprehensive Error Handling**: `thiserror` is used throughout the codebase to create descriptive, typed errors. This allows for fine-grained error handling and clear propagation of failure conditions, which is critical for a financial system.

* **Domain-Separated Hashing**: To prevent cross-protocol replay attacks and ensure cryptographic hygiene, Tari uses domain separation for all its hashing operations. The `tari_hashing` crate provides a `DomainSeparatedHasher` that prefixes all hashed data with a unique, context-specific string.

* **Monorepo with Cargo Workspaces**: The entire project is contained in a single Git repository, managed as a Cargo workspace. This simplifies dependency management, ensures all crates are built against a consistent set of dependencies (enforced by the root `Cargo.lock`), and makes cross-cutting changes easier to manage.

* **Secure Coding Practices**: The codebase shows a strong focus on security. This is evident in the use of `zeroize` to securely clear sensitive data from memory, constant-time operations for cryptographic comparisons (`subtle`), and a comprehensive security policy (`SECURITY.md`) with a bug bounty program.

### 5. Important Dependencies and Integrations

Tari is built upon a foundation of high-quality, community-vetted Rust libraries and integrates with other best-in-class open-source projects.

* **Async Runtime**: `tokio` is used as the asynchronous runtime for all networking and concurrent services.

* **gRPC/Protobuf**: `tonic` and `prost` provide the gRPC server/client implementation and protocol buffer tooling.

* **Database**:
  * **LMDB (`lmdb-zero`)**: A high-performance, memory-mapped key-value store is used for the core blockchain database. This is managed through the `tari_storage` crate.
  * **SQLite (`diesel`)**: The Diesel ORM with an SQLite backend is used for structured data, including the wallet database, peer manager, and contacts. The `tari_common_sqlite` crate provides a shared wrapper.

* **Networking**:
  * **`yamux`**: For multiplexing multiple logical streams over a single TCP or Tor connection.
  * **`snow`**: The Rust implementation of the Noise Protocol Framework, used for end-to-end encryption of P2P traffic.
  * **`multiaddr`**: A standard for self-describing network addresses, used to represent peer connection information.

* **Cryptography**:
  * `tari_crypto`: Tari's own cryptographic library, providing implementations of Ristretto, Schnorrkel signatures, Pedersen commitments, and Bulletproofs+.
  * `randomx-rs`: A Rust binding for the RandomX proof-of-work algorithm used in Monero.

* **External Integrations**:
  * **Monero**: The `monero` crate is used by the merge-mining proxy to interact with Monero's data structures.
  * **Tor**: The `libtor` crate provides an embedded Tor client, allowing Tari nodes to run over Tor for enhanced privacy without requiring a separate Tor installation.
  * **Ledger**: The `minotari_ledger_wallet` crate family provides full support for building and communicating with the Tari application on Ledger hardware wallets.

### 6. Database Schema Overview

Tari uses two different types of databases for two different purposes: a high-performance key-value store for the blockchain itself, and a relational database for application-level data like wallet and peer information.

#### Blockchain Database (LMDB)

The main blockchain database is an LMDB instance located in the base node's data directory. It is not a relational database; it is a key-value store optimized for very fast reads. The data is organized into different "databases" (which are like tables) within the main LMDB environment. The keys are defined in `base_layer/core/src/chain_storage/db_transaction.rs` as the `DbKey` enum.

Key-value pairs stored include:
* `BlockHeader(height)` → `BlockHeader`
* `BlockHash(hash)` → `Block`
* `UTXO(commitment)` → `TransactionOutput`
* `Kernel(excess_sig)` → `TransactionKernel`
* `Orphan(hash)` → `Block`
* Metadata such as chain tip, pruning horizon, etc.
* The Merkle Mountain Range (MMR) structures for headers, kernels, and outputs.

#### Application Databases (SQLite via Diesel)

The wallet, peer manager, and contacts service all use SQLite for persistent storage, managed via the Diesel ORM. The schema for each is defined by migration files.

* **Wallet Database (`base_layer/wallet/migrations/`)**:
  * `outputs`: Stores all UTXOs owned by the wallet, including their value, spending keys (encrypted), and status (Unspent, Spent, etc.).
  * `completed_transactions`: A record of all finalized transactions, including their direction (inbound/outbound), amount, and counterparties.
  * `inbound_transactions` / `outbound_transactions`: Temporary tables for transactions that are currently being negotiated.
  * `scanned_blocks`: Tracks the progress of the UTXO scanner.
  * `wallet_settings`: A key-value store for wallet configuration.

* **Key Manager Database (`base_layer/key_manager/migrations/`)**:
  * `key_manager_states`: Stores the branch seeds and key indices for the Hierarchical Deterministic (HD) key generation.
  * `imported_keys`: Stores any private keys that were imported into the wallet rather than derived from the seed.

* **Contacts Database (`base_layer/contacts/migrations/`)**:
  * `contacts`: An address book storing peer Tari addresses, public keys, and aliases.
  * `messages`: Stores chat messages for the experimental peer-to-peer messaging feature.

### 7. API Structure (gRPC)

Tari's primary external-facing API is a gRPC interface. This API allows applications like wallets, explorers, and miners to interact with a running base node. All protocol definitions are located in `applications/minotari_app_grpc/proto/`.

#### Key Services

* **BaseNode Service (`base_node.proto`)**: This is the main service for interacting with the blockchain.
  * **Queries**: `GetChainMetadata`, `ListHeaders`, `GetBlocks`, `SearchKernels`, `SearchUtxos`.
  * **Submissions**: `SubmitTransaction`, `SubmitBlock`.
  * **Mining**: `GetNewBlockTemplate` (for miners to get work), `GetMiningData`.
  * **Network**: `ListPeers`, `AddPeer`, `BanPeer`.
  * **Streaming**: Exposes several methods that return streams of data, such as `GetHeadersStream`.

* **Wallet Service (`wallet.proto`)**: This service exposes the full functionality of a wallet daemon. A console wallet running in gRPC mode will expose this API.
  * **Balance & Funds**: `GetBalance`, `GetAvailableBalance`.
  * **Transactions**: `Transfer` (to send Tari), `CoinSplit`, `CancelTransaction`.
  * **History**: `GetCompletedTransactions`, `GetCancelledTransactions`.
  * **Management**: `GetContacts`, `AddContact`, `GetNetworkStatus`.
  * **Recovery**: `StartRecovery`, `GetRecoveryStatus`.

* **P2Pool Service (`p2pool.proto`)**: A specialized service for decentralized SHA3X mining pools.

#### Authentication & Security

The gRPC endpoints are secured using two mechanisms:

1. **TLS**: The connection itself can be encrypted using TLS. The `minotari_app_grpc/src/tls` module contains utilities for generating self-signed certificates for development and loading production certificates.

2. **Basic Authentication**: Access to gRPC methods can be restricted via username and password. The implementation in `minotari_app_grpc/src/authentication` uses Argon2 for password hashing and constant-time string comparison to prevent timing attacks.

### 8. Testing Approach

Tari employs a multi-faceted testing strategy to ensure the correctness, security, and performance of the protocol.

* **Unit Tests**: Each crate contains its own suite of unit tests, located within the `tests` submodule of each file (`#[cfg(test)]`). These are fast-running tests that verify individual functions and structures in isolation.

* **Integration Tests (`integration_tests/`)**: The project uses the `cucumber` crate for Behavior-Driven Development (BDD).
  * Test scenarios are written in a human-readable Gherkin format in `.feature` files (e.g., `WalletTransactions.feature`).
  * These scenarios are then implemented as Rust code in the `tests/steps/` directory.
  * The test runner (`TariWorld`) spins up actual `minotari_node` and `minotari_console_wallet` processes, making them communicate over the OS networking stack to simulate real-world conditions. This provides a high degree of confidence in the end-to-end functionality.

* **Benchmarking**: Performance-critical components like the mempool and MMRs have benchmark suites in their `benches/` directories, using the `criterion` crate. This helps track performance regressions and optimizations.

* **Mocks and Test Utilities**: The `infrastructure/test_utils` crate and various `test_utils` modules within other crates provide a rich set of tools for testing, including mock services, network transport simulators (`MemorySocket`), and factories for creating test data.

* **Continuous Integration (CI)**: A comprehensive set of CI workflows are defined in `.github/workflows/`.
  * `ci.yml` runs formatting (`rustfmt`), linting (`clippy`), and unit tests on every pull request. `cargo-nextest` is used for faster test execution.
  * `integration_tests.yml` runs the full suite of Cucumber tests.
  * `audit.yml` runs `cargo-audit` to check for security vulnerabilities in dependencies.
  * Other workflows build binaries, FFI libraries, and Docker images for all supported platforms.

### 9. Build and Deployment Notes

The Tari project is designed to be built and deployed on a variety of platforms including Linux, macOS, and Windows, with support for multiple architectures.

* **Build System**: The primary build tool is `cargo`. A `Makefile` is used for certain tasks like documentation generation.

* **Cross-Compilation**: The `Cross.toml` file configures the `cross` tool for cross-compiling to different architectures, including ARM64 and RISC-V64. This is used extensively in the CI pipelines.

* **Release Automation**: The CI system automates the entire release process. The `build_binaries.yml` workflow builds all application binaries, signs them (using macOS notarization and Windows Trusted Signing), packages them into installers (`.pkg`, `.exe`), and uploads them as release artifacts.

* **Docker Support**: The repository includes `Dockerfile`s in `buildtools/docker_rig` for all applications and third-party dependencies (Tor, Monerod, XMRig). The `build_dockers.yml` workflow automates building and publishing multi-arch Docker images to container registries.

* **Configuration**: Tari applications use a layered configuration system, defined in the `common` crate. Configuration is loaded from a series of `.toml` files located in `common/config/presets`. Users can create a `config.toml` in their data directory to override these defaults. Configuration values can be further overridden by environment variables and finally by command-line arguments. This provides a highly flexible configuration system.

* **FFI Libraries**: The CI pipeline includes a dedicated workflow, `build_libffis.yml`, for building the wallet FFI libraries for all supported mobile (iOS, Android) and desktop platforms. These artifacts are crucial for third-party developers building applications on top of Tari.

## Codebase Structure

### Root Directory

| File | Description |
|------|-------------|
| `.dockerignore` | Docker build context exclusion file preventing unnecessary files from being sent to Docker daemon during image builds. Excludes build artifacts (target/, *.rs.bk), development files (.env, IDE workspaces, .DS_Store), logs (*.log), databases (*.mdb, *.sqlite3), temporary data (/data/), configuration files (.rustfmt.toml, .clippy.toml), documentation (book/), test reports (report/), and sensitive data (keys.json). Optimizes Docker build performance and security by reducing build context size and preventing sensitive information leakage. |
| `.gitignore` | Git version control ignore file specifying files and directories to exclude from repository tracking. Excludes build artifacts (target/, **/*.rs.bk), development environment files (.env, IDE configurations), OS-specific files (.DS_Store), logs (*.log), databases (*.mdb, *.sqlite3), temporary directories (/data/, /integration_tests/temp), generated documentation (book/), test artifacts (*.profraw, /report/), and sensitive configuration (keys.json). Includes Tari-specific exclusions for wallet FFI builds, integration test outputs, and Ledger wallet artifacts. Maintains clean repository state by preventing tracking of generated and temporary files. |
| `.license.ignore` | License header exclusion file listing files that should be ignored during license header validation. Contains paths to auto-generated files (schema.rs database schemas), asset files (tari_banner.rs, tari_logo.rs), configuration files (entitlements.xml), documentation assets (theme files), and the Tari manifesto. Prevents license header enforcement on files where copyright headers are inappropriate or automatically generated, maintaining clean license compliance checking across the Tari project. |
| `CODEOWNERS` | GitHub CODEOWNERS file defining code review requirements and ownership for different areas of the Tari codebase. Requires DevOps team approval for CI/CD files (.github/**, scripts/**), lead maintainer approval for consensus-critical code (consensus/**, meta/ management), and core developer approval for base layer components (core/**, key_manager/**, wallet/**). Ensures appropriate expertise reviews critical code changes that could affect security, consensus, or core functionality. Essential for maintaining code quality and security through mandatory code review processes. |
| `Cargo.lock` | Auto-generated Cargo dependency lock file ensuring reproducible builds across all Tari project environments. Contains precise version specifications and checksums for all direct and transitive dependencies including cryptographic libraries (aes, argon2, ed25519), networking (tokio, tonic), serialization (serde, borsh), database (diesel, lmdb), and Tari-specific crates. Critical for security auditing, build reproducibility, and dependency management across development, CI/CD, and production deployments. Should not be manually edited. |
| `Cargo.toml` | Root Cargo workspace configuration for the Tari cryptocurrency project. Defines workspace members including base_layer components (core, wallet, p2p), applications (minotari_node, minotari_console_wallet, minotari_miner, minotari_merge_mining_proxy), communications (comms/core, comms/dht), infrastructure libraries (storage, metrics, shutdown), and client libraries. Sets up shared dependencies like tari_crypto (0.22.0), external crates, and build configuration with overflow checks enabled in release mode. Configures patch for liblmdb-sys dependency from Tari fork. |
| `Contributing.md` | Comprehensive contributing guidelines for the Tari open-source project covering development workflow, security requirements, and collaboration processes. Defines 4-branch release process (mainnet, development, nextnet, Esmeralda), feature gate lifecycle, RFC implementation process, and code review requirements (3+ approvals post-mainnet). Includes PR guidelines (single purpose, <400 lines, detailed commit messages), release cycle management (2-month periods), versioning strategy (semver with hard fork considerations), and automated CI requirements. Features extensive code review guidelines, label taxonomy, and best practices for maintaining secure, high-quality financial software. |
| `Cross.toml` | Cross-compilation configuration for building Tari across multiple target platforms using the cross tool. Defines Docker images, pre-build scripts, and environment variable passthrough for Android (x86_64, aarch64), Linux (aarch64, x86_64, riscv64), and embedded targets. Includes protocol buffer compiler installation, Android-specific flags (CFLAGS=-DMDB_USE_ROBUST=0), cross-compilation toolchain setup, and Ubuntu-based build environments. Enables consistent cross-platform builds for Tari applications supporting diverse hardware architectures and operating systems. |
| `LICENSE` | BSD 3-Clause License for the Tari project granting broad permissions for use, modification, and distribution while requiring copyright notice retention and disclaimer of liability. Copyright held by The Tari Developer Community since 2019. Permits commercial and non-commercial use, source and binary redistribution, with minimal restrictions. Provides legal framework for open-source collaboration while protecting contributors from liability and preventing unauthorized endorsement claims. Standard permissive license enabling wide adoption and contribution to the Tari cryptocurrency project. |
| `Makefile` | Build automation file providing documentation generation targets for core Tari packages. Defines PACKAGES variable including tari_crypto, tari_core, tari_utilities, and tari_comms. Provides 'doc' target for generating standard documentation with custom JavaScript header inclusion, and 'doc-internal' target for generating documentation including private items. Uses cargo rustdoc with HTML header injection for enhanced documentation presentation. Facilitates consistent documentation generation across multiple Tari crates with standardized styling and functionality. |
| `README.md` | Main project documentation for the Tari protocol implementation. Provides comprehensive setup and usage instructions for Minotari Base Node, Wallet, Miner, and Merge Mining Proxy applications. Includes binary installation guides, source build instructions for macOS/Ubuntu/Windows, Docker usage, mining configuration (both SHA3 standalone and Monero merge mining), XMRig setup, and network versioning information. Documents command-line usage, configuration requirements, testing with cargo nextest, and references to RFC documentation and community channels. |
| `RELEASE_CHECKLIST.md` | Point release checklist and version tracking for Tari project crate management. Documents step-by-step release process including RC branch creation, version updates, testing (cargo test), crates.io publishing, master rebasing, tagging, GitHub release notes, and development merging. Includes version tracking table for all Tari crates with current versions and last change commit hashes. Essential for maintaining consistent release quality and coordinating multi-crate releases across the Tari ecosystem. |
| `SECURITY.md` | Comprehensive security vulnerability disclosure policy for the Tari project defining responsible disclosure procedures, bug bounty programs, and security research guidelines. Covers scope including tari-project repositories, RFCs, and Tari Labs infrastructure. Offers token-based bounties (500-250,000 XTM based on CVSS severity), multiple disclosure channels (HackerOne preferred), and safe harbor protections for researchers. Includes detailed submission requirements, commonplace report exclusions, and clear expectations for both researchers and the Tari team. Establishes 60-day disclosure timeline and comprehensive legal protections for security research conducted in good faith. |
| `bors.toml` | Bors merge bot configuration file for automated testing and merging of pull requests in the Tari repository. Defines branch protection rules, required status checks, merge strategies, and testing workflows. Configures automatic merging conditions, rollup strategies for batching PRs, and failure handling. Ensures thorough testing before code integration and maintains main branch stability through automated continuous integration processes. |
| `changelog-Mainnet.md` | Mainnet release changelog documenting version history and changes. Contains release notes from v4.4.0 back to v2.0.0 with features, bug fixes, and breaking changes. Follows conventional-changelog format with GitHub issue/PR links. Includes major features like PayRef implementation, RandomX mining updates, improved peer matching, base node HTTP wallet service, consensus changes. Documents breaking changes, migration notes, and security fixes. Critical for tracking mainnet deployment history and communicating changes to users and developers. |
| `changelog-development.md` | Development branch changelog documenting features, bug fixes, and breaking changes for Tari project releases. Latest version 4.4.0-pre.0 includes PayRef implementation, peer resilience improvements, network discovery fixes, payment ID deserialization fixes, and wallet FFI improvements. Follows conventional changelog format with semantic versioning. Used by: developers and users tracking development progress, release planning, and understanding version differences. Contains detailed commit references and issue links for comprehensive change tracking across development iterations. |
| `changelog-nextnet.md` | Changelog for Tari NextNet network releases following conventional changelog format. Documents notable changes, features, bug fixes, and breaking changes from v4.4.0-rc.0 down to earlier versions. Includes commit links, issue references, and semantic versioning. Used for tracking NextNet-specific changes separate from mainnet. Generated by standard-version. Dependencies: standard-version. Related files: changelog-Mainnet.md, changelog-development.md. |
| `clippy.toml` | Clippy linter configuration file customizing Rust static analysis rules for the Tari codebase. Defines project-specific lint levels, allowed/denied lint categories, and custom lint configurations to maintain code quality standards. Configures complexity thresholds, naming conventions, performance optimizations, and security-related lints. Ensures consistent code style and catches common programming errors across all Tari Rust components. |
| `lints.toml` | Lint configuration file defining code quality rules and linting standards for the Tari project. Specifies allowed/denied lints, lint levels, and code quality enforcement policies. Dependencies: Rust linting infrastructure. Used by: development tools to enforce code quality, maintain consistency, and ensure adherence to Tari coding standards across the codebase. |
| `rust-toolchain.toml` | Rust toolchain configuration file specifying the exact Rust compiler version and components required for building Tari. Ensures consistent compilation environment across development teams, CI/CD systems, and deployment environments. Defines stable Rust channel version, required components (rustfmt, clippy), and target platforms. Critical for reproducible builds and preventing version-related compilation issues in the Tari project. |
| `rustfmt.toml` | Rust code formatting configuration file defining code style rules and formatting standards for the Tari project. Specifies indentation, line length, import organization, and other formatting preferences. Dependencies: rustfmt tool. Used by: development tools to automatically format Rust code, maintain consistent code style, and enforce formatting standards across the codebase. |

### .cargo/

| File | Description |
|------|-------------|
| `audit.toml` | Cargo audit configuration file specifying security advisory exemptions for the Tari project. Ignores RUSTSEC-2021-0145 (allocator-related vulnerability not applicable to Tari's usage patterns) and RUSTSEC-2023-0071 (RSA-related vulnerability not applicable since Tari doesn't use RSA cryptography). Helps cargo-audit tool focus on relevant security issues while filtering out false positives. Part of Tari's security vulnerability scanning and management workflow. |
| `config.toml` | Cargo configuration file defining cross-compilation linkers and convenient command aliases for Tari development workflow. Configures linkers for aarch64-unknown-linux-gnu and riscv64gc-unknown-linux-gnu targets. Provides CI-friendly aliases: ci-fmt for format checking, ci-clippy for linting, ci-test-compile for build verification, ci-test for running tests with nextest, and ci-cucumber for integration testing with cucumber features. Streamlines development and CI/CD processes across different architectures and testing scenarios. |

### .config/

| File | Description |
|------|-------------|
| `nextest.toml` | Nextest configuration file defining test execution profiles for Tari project. Includes 'ci' profile with 60-second slow test timeout and junit.xml output for CI/CD integration, and 'intellij' profile optimized for IDE usage with 30-second timeout, immediate failure output, no retries, and no fail-fast behavior. Both profiles generate JUnit XML reports for test result visualization and integration with development tools and continuous integration systems. |

### .github/

| File | Description |
|------|-------------|
| `PULL_REQUEST_TEMPLATE.md` | GitHub pull request template for standardized PR submissions in the Tari project. Provides sections for description, motivation/context, testing methodology, review process instructions, and breaking changes checklist. Includes checkbox options for breaking changes (data directory deletion, hard fork requirements, other changes) and comments about conventional commit formatting for changelog generation. Ensures consistent PR quality and proper documentation of changes for review and release management. |
| `dependabot.yml` | Dependabot configuration for automated dependency updates in the Tari project. Monitors GitHub Actions workflow dependencies in the root directory with weekly update schedule. Helps maintain security and compatibility by automatically creating pull requests for outdated GitHub Actions dependencies. Essential for keeping CI/CD workflows current with latest action versions and security patches. |

#### .github/ISSUE_TEMPLATE/

| File | Description |
|------|-------------|
| `bug_report.md` | GitHub issue template for bug reports providing structured format for Tari project issue reporting. Includes sections for bug description, reproduction steps, expected behavior, screenshots, desktop/mobile environment details (OS, browser versions), and additional context. Uses YAML frontmatter to specify issue type ('bug-report' label), title placeholder, and template metadata. Ensures consistent bug report quality with all necessary information for developers to reproduce and address issues effectively. |

#### .github/workflows/

| File | Description |
|------|-------------|
| `audit.yml` | GitHub Actions workflow for automated security auditing of Rust dependencies using cargo-audit and rustsec/audit-check. Triggers on Cargo.toml/Cargo.lock changes, workflow file changes, audit.toml configuration updates, daily at 05:43 UTC, and manual dispatch. Uses rustsec/audit-check@v2.0.0 action to scan for known security vulnerabilities in project dependencies. Critical security infrastructure ensuring continuous monitoring of supply chain security for the Tari cryptocurrency project. |
| `build_binaries.json` | Build matrix configuration for cross-platform Tari binary compilation. Defines build targets including Linux (x86_64, arm64, riscv64), macOS (x86_64, arm64), and Windows (x64, arm64) with corresponding runners, Rust targets, cross-compilation settings, and feature flags. Specifies special configurations like libtor exclusion for Windows, safe features, build metrics enablement, and best-effort flags for experimental targets. Used by build_binaries.yml workflow for automated multi-platform releases. |
| `build_binaries.yml` | Comprehensive GitHub Actions workflow for building, signing, and releasing Tari binaries across multiple platforms. Supports Linux (x86_64, arm64, riscv64), macOS (x86_64, arm64, universal), and Windows (x64, arm64) targets with cross-compilation, platform-specific dependencies, code signing (macOS notarization, Windows Trusted Signing), package creation (.pkg, .exe installers), artifact archiving, and S3 deployment. Includes metrics builds, targeted miners, cargo auditing, checksum verification, and comprehensive release automation. Triggers on tags, scheduled builds, and manual dispatch. |
| `build_dockers.yml` | GitHub Actions workflow coordinator for Docker image builds with environment-based configuration. Analyzes build triggers (tags, branches, schedule, manual) to determine build matrix (all/minotari_all/3rdparty), platform targets (amd64/arm64), and tag aliases (latest/latest-testing/latest-weekly/latest-daily). Sets appropriate toolchain, version, and build scope before calling reusable build_dockers_workflow.yml. Supports selective builds, multi-architecture compilation, and various release strategies for Tari Docker ecosystem. |
| `build_dockers_workflow.yml` | Reusable GitHub Actions workflow for building and publishing Tari Docker images to multiple registries. Supports matrix builds for minotari applications (node, wallet, miner, merge mining proxy) and 3rd party tools (tor, monerod, xmrig) with multi-platform compilation (linux/amd64, linux/arm64). Includes Docker Buildx setup, QEMU emulation, GitHub Container Registry and custom registry authentication, metadata extraction, image tagging, cache management, and automatic expiration for non-release builds. Features build argument injection for version, architecture, features, and network configuration. |
| `build_ledger_wallet.yml` | GitHub Actions workflow for building Tari Ledger hardware wallet firmware across multiple Ledger device types. Builds for nanox, nanosplus, flex, and stax targets using official Ledger Docker builder image (ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder:4.2.0). Compiles firmware with cargo ledger, archives build artifacts (JSON manifests, key GIFs, firmware files), generates checksums, and uploads to GitHub releases for tagged builds. Essential for Tari hardware wallet support enabling secure transaction signing on Ledger devices. |
| `build_libffis.json` | Build matrix configuration for Foreign Function Interface (FFI) libraries targeting mobile and embedded platforms. Defines cross-compilation targets for Android (x86_64, aarch64), Linux (x86_64, aarch64, riscv64), iOS (x86_64, aarch64, simulator), macOS (x86_64, aarch64), and Windows (x86_64, aarch64). Specifies runners, cross-compilation requirements, and selective build enablement flags. Used for generating Tari wallet FFI libraries for mobile application integration and cross-platform compatibility. |
| `build_libffis.yml` | GitHub Actions workflow for building Foreign Function Interface (FFI) libraries across multiple target platforms for Tari mobile and embedded integration. Supports Android (x86_64, aarch64), iOS (x86_64, aarch64, simulator), Linux (x86_64, aarch64, riscv64), macOS (x86_64, aarch64), and Windows (x86_64, aarch64) targets. Builds minotari_wallet_ffi with cross-compilation support, artifact generation, checksum verification, and release automation. Essential for mobile wallet applications and cross-platform Tari library distribution enabling native integration across diverse hardware architectures. |
| `ci.yml` | Primary continuous integration workflow for Tari project providing comprehensive testing, linting, and validation across pull requests and pushes. Runs Rust toolchain setup with nightly compiler, Ubuntu dependency installation, formatting checks (cargo fmt), linting (cargo clippy), compilation verification, test execution with nextest, security auditing, and feature validation. Supports multiple feature combinations (default, safe, grpc, ledger, libtor, metrics, miner_input) ensuring code quality and compatibility across different build configurations. Critical for maintaining Tari codebase integrity and preventing regressions. |
| `coverage.yml` | GitHub Actions workflow for source code coverage analysis using self-hosted runners with high memory capacity. Triggered on development branch pushes and CI coverage branches. Installs Ubuntu dependencies, sets up Rust toolchain, configures cargo-tarpaulin for coverage measurement, runs comprehensive test suite with coverage collection, and generates detailed coverage reports. Utilizes compiler flags specifically for coverage runs and local caching solutions. Essential for maintaining code quality metrics and ensuring adequate test coverage across the Tari codebase. |
| `integration_tests.yml` | Comprehensive integration testing workflow for end-to-end Tari system validation with configurable test execution. Supports pull request validation, scheduled daily/weekly runs, and manual dispatch with options for binary CI, FFI testing, and custom CI profiles. Implements matrix testing across different configurations, multi-application integration scenarios, wallet-node interaction testing, mining functionality validation, and network protocol testing. Critical for ensuring system-level functionality and preventing integration regressions across Tari ecosystem components. |
| `pr_signed_commits_check.yml` | GitHub Actions workflow enforcing signed commit requirements for pull requests using 1Password's check-signed-commits-action. Triggered on pull_request_target events with appropriate permissions for reading contents and writing pull request comments. Validates that all commits in pull requests are cryptographically signed, enhancing security and ensuring commit authenticity. Essential security measure for maintaining code integrity and contributor accountability in the Tari project. |
| `pr_title.yml` | GitHub Actions workflow enforcing Conventional Commits specification for pull request titles. Installs commitlint with conventional config and validates PR titles against standardized format requirements (feat:, fix:, docs:, etc.). Triggered on PR open, reopen, edit, and synchronize events with concurrency control. Ensures consistent commit messaging and changelog generation by requiring properly formatted PR titles that follow semantic versioning conventions. |
| `publish_test_results_ci.yml` | GitHub Actions workflow for processing and publishing test results from CI and Integration Tests workflows. Triggered on workflow completion with artifact download, test result parsing, and report publishing capabilities. Requires permissions for checks writing, pull request comments, and artifact access. Downloads JUnit XML reports, processes test data, and creates comprehensive test result summaries for developer feedback. Essential for test result visibility and automated quality reporting in the Tari development workflow. |

#### applications/minotari_app_grpc/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for minotari_app_grpc crate providing unified gRPC interface and type conversions for Tari applications. Depends on core Tari libraries (tari_core with base_node features, tari_common_types, tari_comms, tari_crypto, tari_script) and gRPC infrastructure (tonic, prost for protocol buffers). Includes security-focused dependencies: argon2 for password hashing, subtle for constant-time operations, zeroize for secure memory handling, rcgen for certificate generation. Uses tonic-build at build time to generate Rust code from protobuf definitions. Central crate enabling cross-application gRPC communication in the Tari ecosystem. |
| `README.md` | Brief documentation for minotari_app_grpc crate explaining its purpose as a unified source for cross-application gRPC files and type conversions. Serves as central integration point between Tari core types and gRPC protocol definitions, enabling standardized communication between base node, wallet, miner, and other Tari applications. Provides single source of truth for gRPC interfaces and type conversion utilities used throughout the Tari ecosystem. |
| `build.rs` | Build script for minotari_app_grpc crate that generates Rust gRPC client and server code from protocol buffer definitions. Processes feature flags via tari_features::resolver and uses tonic-build to compile base_node.proto, wallet.proto, validator_node.proto, and p2pool.proto into Rust types and service definitions. Generates both client and server implementations enabling bidirectional gRPC communication. Essential build step creating the foundation for all Tari gRPC APIs and cross-application communication interfaces. |

##### applications/minotari_app_grpc/proto/

| File | Description |
|------|-------------|
| `base_node.proto` | Protocol buffer definitions for Minotari Base Node gRPC API providing comprehensive blockchain query and management interface. Defines BaseNode service with methods for listing headers, retrieving blocks by hash/height, getting chain metadata, querying block timing/sizes/fees, network constants, peer management, mempool operations, transaction submission, mining template retrieval, and network monitoring. Includes message types for blockchain data structures, consensus parameters, network information, and mining operations. Central API definition enabling external applications to interact with Tari base nodes through standardized gRPC protocols. |
| `block.proto` | Protocol buffer definitions for Tari blockchain block structures and mining templates. Defines BlockHeader with comprehensive metadata (hash, height, merkle roots, proof-of-work, timestamps), Block structure combining header and AggregateBody, HistoricalBlock with confirmation data, and mining template structures (NewBlockHeaderTemplate, NewBlockTemplate). Includes ProofOfWork message supporting multiple algorithms (Monero=0, Sha3X=1, RandomXT=2) and PowAlgo enumeration. Essential for gRPC APIs providing block data, mining interfaces, and blockchain state information. Used by base node services, miners, and block explorers. |
| `network.proto` | Protocol buffer definitions for Tari peer-to-peer networking and connectivity management. Defines NodeIdentity for node identification, Peer structure with connection metadata (public keys, addresses, ban status, supported protocols, user agent), ConnectivityStatus enumeration (Initializing, Online, Degraded, Offline), and NetworkStatusResponse for network health monitoring. Includes Address with connection statistics, AverageLatency tracking, ListConnectedPeersResponse, SoftwareUpdate notifications, and identity management requests/responses. Used by base node networking layer for peer discovery, connection management, and network status reporting. |
| `p2pool.proto` | Protocol buffer definitions for SHA-based P2Pool mining service enabling decentralized mining pool functionality. Defines ShaP2Pool service with methods for GetTipInfo (blockchain height synchronization), GetNewBlock (mining template requests), and SubmitBlock (share submission). Includes tip info tracking for node height, P2Pool RandomX/SHA heights, and corresponding tip hashes. Features GetNewBlockRequest with proof-of-work algorithm selection, coinbase extra data, and wallet payment addresses. Enables miners to participate in decentralized mining pools while maintaining individual payouts and reducing centralization risks. |
| `sidechain_types.proto` | Protocol buffer definitions for Tari sidechain functionality and validator node features. Defines SideChainFeature union type supporting ValidatorNodeRegistration with public key signatures, TemplateRegistration for smart contract deployment with build metadata and binary verification, and ConfidentialOutputData for privacy features. Includes TemplateType enumeration (Flow, Wasm), BuildInfo with compiler information, and ConfidentialOutputStatement for zero-knowledge proofs. Essential for Tari's planned smart contract and validator node infrastructure. Used by sidechain features, template deployment, and validator registration processes. |
| `transaction.proto` | Protocol buffer definitions for Tari transaction components implementing Mimblewimble protocol structures. Defines TransactionKernel with excess proofs and fee data, TransactionInput for spending UTXOs with script validation, TransactionOutput with commitment proofs and encrypted data, and OutputFeatures supporting various output types (Standard, Coinbase, Burn, Validator Registration). Includes AggregateBody for cut-through optimization, Transaction structure with offsets, UnblindedOutput for wallet operations, and comprehensive signature types (Signature, ComAndPubSignature). Features covenant support, range proof types, and payment references. Core to all Tari transaction processing and validation. |
| `types.proto` | Protocol buffer definitions for core Tari data types and consensus parameters. Defines Range for numeric intervals, Empty for parameterless endpoints, BlockHeight wrapper, and cryptographic signature types (Signature, ComAndPubSignature, CommitmentSignature). Includes comprehensive ConsensusConstants with emission schedules, difficulty windows, weight parameters, version ranges, and proof-of-work configurations. Defines OutputType enumeration (Standard, Coinbase, Burn, Validator, Template), RangeProofType options (BulletproofPlus, RevealedValue), and WeightParams for transaction fee calculations. Central type definitions used across all Tari gRPC services and blockchain operations. |
| `validator_node.proto` | Protocol buffer definitions for Tari validator node services supporting smart contract execution and consensus participation. Defines ValidatorNode service with methods for identity management (GetIdentity), metadata queries (GetMetadata), token data retrieval (GetTokenData), and contract interaction (InvokeReadMethod, InvokeMethod). Includes constitution request streaming (GetConstitutionRequests) and contract acceptance publishing for governance. Features comprehensive request/response structures for validator operations, contract execution, and consensus participation. Essential for Tari's planned validator network and smart contract infrastructure enabling decentralized application deployment and execution. |
| `wallet.proto` | Protocol buffer definitions for Minotari Wallet gRPC API providing complete wallet functionality interface. Defines Wallet service with extensive methods for balance queries, transaction management (send, receive, cancel), contact management, UTXO operations, key management, wallet recovery, connectivity status, and network configuration. Includes comprehensive message types for wallet states, transaction details, authentication, and wallet synchronization. Provides detailed API documentation with JavaScript examples and JSON response formats. Essential interface for wallet applications and services requiring programmatic access to Tari wallet functionality. |

##### applications/minotari_app_grpc/src/

| File | Description |
|------|-------------|
| `lib.rs` | Shared gRPC protocol definitions and utilities for Tari applications. Provides authentication module for gRPC services, type conversions between internal types and protobuf messages, TLS configuration utilities, and auto-generated tari_rpc module from protocol buffer definitions. Central location for gRPC-related functionality shared between base node, wallet, and other Tari services. Includes authentication interceptors and conversion utilities for seamless integration between Rust types and gRPC messages. |

###### applications/minotari_app_grpc/src/authentication/

| File | Description |
|------|-------------|
| `basic_auth.rs` | RFC 2617 Basic Authentication implementation for Tari gRPC services with constant-time security guarantees. Provides BasicAuthCredentials for secure username/password validation using Argon2 hashing, constant-time username comparison to prevent timing attacks, HTTP Authorization header parsing/generation, and comprehensive error handling. Features extensive security testing including timing analysis to ensure cryptographic operations resist side-channel attacks. Used by gRPC authentication interceptors for secure API access control across Tari applications. |
| `client_interceptor.rs` | gRPC client authentication interceptor for automatic Authorization header injection in Tari service communications. Implements Tonic Interceptor trait to add Basic Authentication headers to outgoing requests based on GrpcAuthentication configuration. Supports both authenticated and non-authenticated modes, automatically generating proper Authorization headers from credentials. Includes comprehensive testing covering successful authentication, failure scenarios, and mixed authentication configurations. Essential for secure client-server communication in Tari gRPC ecosystem. |
| `mod.rs` | Authentication module aggregation for Tari gRPC services providing comprehensive authentication infrastructure. Exports ClientAuthenticationInterceptor for outgoing request authentication, BasicAuthCredentials and BasicAuthError for secure credential handling, ServerAuthenticationInterceptor for incoming request validation, and salted_password utilities for secure password hashing. Central module organizing all authentication components used across Tari gRPC API endpoints for base node, wallet, and other services. |
| `salted_password.rs` | Secure password hashing utility using Argon2id with OWASP-recommended parameters for Tari gRPC authentication. Implements create_salted_hashed_password function with 16-byte random salt generation, 46 MiB memory cost, single iteration, single thread, and Argon2id v0x13 algorithm. Returns zeroized string for secure memory handling. Used by BasicAuthCredentials for storing hashed passwords in configuration files and authentication validation across Tari services. |
| `server_interceptor.rs` | gRPC server authentication interceptor for validating incoming requests to Tari services. Implements Tonic Interceptor trait to extract and validate Authorization headers using BasicAuthCredentials with constant-time comparison. Supports both authenticated and non-authenticated modes based on GrpcAuthentication configuration. Provides comprehensive error handling with proper gRPC status responses and extensive testing for various authentication scenarios. Essential security component protecting Tari gRPC endpoints from unauthorized access. |

###### applications/minotari_app_grpc/src/conversions/

| File | Description |
|------|-------------|
| `aggregate_body.rs` | Bidirectional type conversion implementation between Tari core AggregateBody and gRPC protocol buffer representation. Provides TryFrom implementations for converting between internal blockchain transaction aggregate bodies (containing inputs, outputs, kernels) and external gRPC message format. Handles component decomposition, vector transformations, and error propagation during conversion. Essential for enabling gRPC API access to blockchain transaction data while maintaining type safety and proper error handling in client-server communication. |
| `base_node_state.rs` | Type conversion implementation between Tari base node state machine states and gRPC protocol buffer representation. Maps internal StateInfo variants (StartUp, HeaderSync, HorizonSync, Connecting, BlockSync, Listening, SyncFailed) to corresponding gRPC BaseNodeState enumeration values. Enables external monitoring and status reporting of base node synchronization state through gRPC APIs. Essential for client applications to track blockchain synchronization progress and node connectivity status. |
| `block.rs` | Bidirectional type conversion implementation between Tari core Block types and gRPC protocol buffer representation. Provides TryFrom implementations for converting blockchain blocks (containing header and body components) between internal format and external gRPC messaging. Handles block structure decomposition, component validation, and error propagation during conversion. Critical for enabling gRPC API access to blockchain data while maintaining type safety and proper error handling for block queries and submissions. |
| `block_header.rs` | Bidirectional type conversion implementation between Tari core BlockHeader and gRPC protocol buffer representation. Provides From trait for converting internal BlockHeader to grpc::BlockHeader with comprehensive field mapping including hash, version, height, Merkle roots (input_mr, output_mr, block_output_mr, kernel_mr), proof-of-work data, validator node information, and offset values. Implements TryFrom for reverse conversion with validation, error handling for invalid private keys, proof-of-work validation, and proper type conversions from protobuf to internal Tari types. Essential for gRPC API block data exchange. |
| `chain_metadata.rs` | Type conversion implementation between Tari core ChainMetadata and gRPC protocol buffer representation. Provides From trait for converting blockchain metadata including best block height, best block hash, pruned height, accumulated difficulty (converted to big-endian 64-byte array), and timestamp. Enables gRPC API access to blockchain state information including chain progress, pruning status, and difficulty accumulation for client applications monitoring blockchain status. |
| `com_and_pub_signature.rs` | Type conversion implementation for ComAndPubSignature (commitment and public key signature) from gRPC to Tari internal types. Implements TryFrom trait for converting gRPC ComAndPubSignature to internal ComAndPubSignature with validation of ephemeral commitment, ephemeral public key, and partial signature components (u_a, u_x, u_y). Includes comprehensive error handling for invalid cryptographic data and canonical byte conversion failures. Used for signature verification in transaction inputs and metadata signatures within the Tari gRPC protocol. |
| `commitment_signature.rs` | Bidirectional type conversion implementation for CommitmentSignature between gRPC and Tari internal Ristretto cryptographic types. Implements TryFrom for converting gRPC CommitmentSignature to internal CommitmentSignature<RistrettoPublicKey, PrivateKey> with validation of public nonce (HomomorphicCommitment), and signature components (u, v). Provides From trait for reverse conversion to gRPC format. Includes comprehensive error handling for cryptographic validation failures. Essential for commitment-based signature schemes used in Tari's privacy-preserving transactions. |
| `consensus_constants.rs` | Comprehensive type conversion implementation for ConsensusConstants from Tari internal types to gRPC protocol buffer representation. Converts complex consensus parameters including emission schedule (initial, decay, inflation), transaction weight parameters, version ranges (input, kernel, output, blockchain), proof-of-work algorithm configurations (RandomXM, RandomXT, SHA3X), permitted output types, range proof types, validator node parameters, and epoch configurations. Features detailed field mapping with proper type conversions, HashMap creation for PoW algorithms, and extensive parameter extraction. Critical for exposing blockchain consensus rules through gRPC API. |
| `historical_block.rs` | Type conversion implementation for HistoricalBlock from Tari internal types to gRPC protocol buffer representation. Implements TryFrom trait for converting internal HistoricalBlock to grpc::HistoricalBlock with confirmation count and block data. Includes error handling for conversion failures through ChainStorageError mapping. Enables gRPC API access to historical blockchain data with confirmation information for clients querying past blocks and their validation status within the Tari blockchain. |
| `mod.rs` | Type conversion module for bridging Tari internal types with gRPC protocol buffer definitions. Provides conversion utilities for aggregate bodies, blocks, headers, transactions, consensus constants, signatures, peer information, and other core types. Includes utility functions like naive_datetime_to_timestamp for time conversions and standard From implementations for IntegerValue, StringValue, and request mappings. Central coordination point for all type conversions enabling seamless communication between Tari core logic and external gRPC clients. |
| `new_block_template.rs` | Bidirectional type conversion implementation for NewBlockTemplate between Tari internal types and gRPC protocol buffer representation. Provides TryFrom for converting internal NewBlockTemplate to gRPC format with header template (version, height, prev_hash, offsets, proof-of-work), aggregate body (inputs, outputs, kernels), and mempool sync status. Implements reverse conversion from gRPC to internal with validation, error handling for missing components, and default value assignments for target difficulty, reward, and total fees. Essential for mining template distribution through gRPC API. |
| `output_features.rs` | Bidirectional type conversion implementation for OutputFeatures between gRPC and Tari internal transaction component types. Implements TryFrom for converting gRPC OutputFeatures to internal OutputFeatures with validation of version, output type, maturity, coinbase extra data, sidechain features, and range proof type. Provides From trait for reverse conversion with proper field mapping. Includes comprehensive error handling for invalid or unrecognized types, overflow protection, and sidechain feature processing. Critical for transaction output metadata exchange through gRPC API. |
| `peer.rs` | Type conversion implementations for peer networking data structures from Tari internal types to gRPC protocol buffer representation. Implements From traits for converting Peer to grpc::Peer with comprehensive field mapping including public key, node ID, addresses with statistics, connection timestamps, ban information, feature flags, supported protocols, and user agent. Includes MultiaddrWithStats to grpc::Address conversion with latency statistics and ConnectivityStatus mapping. Essential for exposing peer management and network status information through gRPC API. |
| `proof_of_work.rs` | Type conversion implementation for ProofOfWork from gRPC to Tari internal types. Implements TryFrom trait for converting grpc::ProofOfWork to internal ProofOfWork with validation of proof-of-work algorithm (PowAlgorithm) and proof-of-work data (PowData). Includes error handling for algorithm conversion failures and data validation. Essential for processing proof-of-work submissions through gRPC API, supporting multiple PoW algorithms (SHA3, RandomX variants) used in Tari's hybrid mining system. |
| `sidechain_feature.rs` | Comprehensive type conversion implementations for sidechain functionality between Tari internal types and gRPC protocol buffer representation. Provides bidirectional conversions for SideChainFeature variants (ValidatorNodeRegistration, CodeTemplateRegistration, ConfidentialOutput), validator node registration with public key signatures, template registration with author signatures and build information, confidential output data, template types (Wasm, Flow, Manifest), and build info with repository metadata. Includes extensive error handling, validation, and proper field mapping. Essential for Tari's sidechain and smart contract infrastructure through gRPC API. |
| `signature.rs` | Bidirectional type conversion implementation for Signature (Schnorr signatures) between gRPC and Tari internal cryptographic types. Implements TryFrom for converting gRPC Signature to internal Signature with validation of public nonce (CompressedPublicKey) and signature scalar (PrivateKey). Provides generic From trait using Borrow for converting any type containing a Signature reference to gRPC format. Includes error handling for cryptographic validation failures. Essential for signature verification in transactions, kernels, and various authentication mechanisms within Tari's gRPC protocol. |
| `transaction.rs` | Comprehensive type conversion implementations for Transaction and transaction status types between Tari internal types and gRPC protocol buffer representation. Provides bidirectional Transaction conversions with offset and script_offset handling (RistrettoSecretKey), aggregate body processing, and Arc<Transaction> support. Includes TransactionDirection (Unknown, Inbound, Outbound) and TransactionStatus (Completed, Broadcast, MinedUnconfirmed, Pending, Coinbase, etc.) conversions. Features TransactionInfo::not_found helper for missing transaction responses. Essential for transaction management and status tracking through gRPC API. |
| `transaction_input.rs` | Complex bidirectional type conversion implementation for TransactionInput between gRPC and Tari internal transaction component types. Supports both compact (output hash only) and full (complete UTXO data) input formats with conditional processing. Handles script signatures, output features, commitments, scripts, execution stacks, sender offset public keys, covenants, encrypted data, metadata signatures, range proof hashes, and minimum value promises. Includes comprehensive validation, error handling, and proper serialization/deserialization using Borsh for covenants. Critical for transaction input processing in Tari's gRPC protocol with privacy-preserving features. |
| `transaction_kernel.rs` | Bidirectional type conversion implementation for TransactionKernel between gRPC and Tari internal transaction component types. Implements TryFrom for converting gRPC TransactionKernel to internal TransactionKernel with validation of excess commitment, excess signature, kernel features, fee amounts (MicroMinotari), lock height, version, and optional burn commitment. Provides From trait for reverse conversion with hash calculation and proper field mapping. Includes comprehensive error handling for invalid feature flags and cryptographic validation. Essential for transaction kernel processing in Tari's gRPC protocol supporting fee payments and advanced features. |
| `transaction_output.rs` | Bidirectional type conversion implementation for TransactionOutput between gRPC and Tari internal transaction component types. Handles comprehensive transaction output conversion including features, commitments, sender offset public keys, range proofs (BulletRangeProof), scripts (TariScript), metadata signatures, covenants (Borsh serialization), encrypted data, minimum value promises, versioning, and hash calculation. Provides proper validation, error handling for cryptographic components, and payment reference handling. Essential for transaction output processing in Tari's privacy-preserving UTXO model through gRPC API with Mimblewimble protocol support. |
| `unblinded_output.rs` | Bidirectional type conversion implementation for UnblindedOutput between gRPC and Tari internal wallet types with secure handling of sensitive cryptographic material. Converts unblinded outputs containing spending keys, script private keys, features, scripts, input data, metadata signatures, covenants, encrypted data, minimum value promises, and range proofs. Features automatic zeroization of sensitive data (spending_key, script_private_key) after conversion, Borsh serialization for covenants, comprehensive validation, and proper error handling. Critical for wallet operations requiring access to spending information while maintaining security through memory protection. |

###### applications/minotari_app_grpc/src/tls/

| File | Description |
|------|-------------|
| `certs.rs` | TLS certificate generation utilities for secure gRPC communications in Tari applications. Provides generate_self_signed_certs function creating CA and server certificates with subject alternative names (localhost, 127.0.0.1, 0.0.0.0), rcgen-based certificate generation, and PEM serialization. Includes write_cert_to_disk for certificate file management and print_warning function displaying comprehensive security warnings about self-signed certificate risks. Essential for TLS-enabled gRPC endpoints while emphasizing production security requirements and proper CA-issued certificate usage. |
| `error.rs` | Error types for TLS operations in Tari gRPC applications using thiserror for comprehensive error handling. Defines GrpcTlsError enum covering file read errors (FileReadError), certificate generation errors (CertGenerationError with rcgen::Error integration), and I/O errors (IoError with std::io::Error integration). Provides structured error handling for TLS certificate management, file operations, and certificate generation failures in secure gRPC communication setup. |
| `identity.rs` | TLS identity management for secure gRPC server connections in Tari applications. Implements read_identity async function that loads server certificate (server.pem) and private key (server.key) from specified configuration directory, creates tonic::transport::Identity for gRPC server authentication, and provides comprehensive error handling for file operations. Essential for establishing secure TLS connections in production gRPC deployments with proper certificate-based authentication and encryption. |
| `mod.rs` | TLS/SSL support module for secure gRPC communications in Tari services. Exports certificate management (certs), error handling (error), and identity management (identity) submodules. Provides protocol_string utility function for generating appropriate HTTP/HTTPS URLs based on TLS enablement status. Enables secure communications between Tari applications and external clients through proper TLS configuration and certificate handling for production deployments. |

#### applications/minotari_app_utilities/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for minotari_app_utilities crate providing shared utilities across Tari applications. Dependencies include core Tari libraries (tari_common, tari_comms, tari_utilities), optional gRPC support (minotari_app_grpc), CLI framework (clap with derive/env features), async runtime (tokio with signal), serialization (serde, json5), user interaction (dialoguer), networking (tonic), and utility libraries (futures, log, rand, thiserror). Features miner_input flag enabling gRPC functionality for mining applications. Build dependencies include tari_common with build and static-application-info features. |
| `build.rs` | Build script for minotari_app_utilities crate handling feature flag resolution and static application information generation. Executes tari_features::resolver::build_features() for compile-time feature processing and StaticApplicationInfo::initialize() for generating build constants (version, git hash, timestamp). Outputs consts.rs file to OUT_DIR containing application metadata accessible at runtime. Essential for consistent build configuration and providing version information across Tari applications. |

##### applications/minotari_app_utilities/src/

| File | Description |
|------|-------------|
| `common_cli_args.rs` | Common command-line argument definitions shared across Tari applications using Clap derive macros. Defines CommonCliArgs struct with standardized options for base path (data directory), configuration file location, log configuration and path, network selection, and configuration overrides. Includes environment variable support (TARI_BASE_DIR, TARI_NETWORK), default value handling, and ConfigOverrideProvider integration. Ensures consistent CLI interface and configuration management across minotari_node, minotari_console_wallet, minotari_miner, and other Tari applications. |
| `identity_management.rs` | Node identity management system for Tari applications providing secure key generation, storage, and loading functionality. Handles NodeIdentity creation with cryptographic key pairs, peer features configuration, Tor identity integration, file permissions validation (0o100600), identity persistence, and interactive identity setup with user prompts. Includes comprehensive error handling, logging, and validation for identity file integrity. Essential for establishing secure peer-to-peer communications and maintaining node identity across Tari network applications. |
| `lib.rs` | Shared utilities library for Minotari applications providing common CLI argument parsing, identity management, mining input parsing, and application utilities. Includes auto-generated build constants (version, git hash, build info) from OUT_DIR/consts.rs, common command-line interface patterns, node identity setup and management utilities, and architecture validation macro (deny_non_64_bit_archs) ensuring 64-bit platform support. Reduces code duplication across minotari_node, minotari_console_wallet, minotari_miner, and minotari_merge_mining_proxy applications. |
| `parse_miner_input.rs` | Mining input validation and user interface utilities for Tari mining applications. Provides interactive prompts for base node gRPC addresses, P2Pool addresses, and wallet payment addresses with network validation. Implements address verification, user input processing with quit handling, wallet address network matching, gRPC client type definitions (BaseNodeGrpcClient, ShaP2PoolGrpcClient), and base node mining capability verification. Features comprehensive error handling, default value suggestions, and interactive command-line interfaces for miner configuration and validation. Essential for mining setup and configuration validation. |
| `utilities.rs` | Common utility functions and types for Tari applications providing multi-threaded async runtime setup, cryptographic key parsing, and flexible identifier handling. Implements parse functions for emoji IDs, public keys, node IDs, block hashes, and Tari addresses with Either type support. Defines universal identifier types (UniPublicKey, UniNodeId, UniSignature) supporting multiple input formats including emoji IDs, hex keys, and Tari addresses. Features comprehensive error handling (UniIdError), runtime configuration with proper error mapping to exit codes, and flexible conversion between different Tari identifier formats. Essential utilities shared across all Tari applications. |

#### applications/minotari_console_wallet/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for minotari_console_wallet application providing comprehensive terminal-based wallet functionality. Integrates extensive Tari dependencies including wallet core (minotari_wallet with SQLite), gRPC services (minotari_app_grpc), networking (tari_comms, tari_p2p), and cryptography (tari_crypto, tari_key_manager). Features include: Ledger hardware wallet support, embedded Tor (libtor), TUI interface (tui/crossterm), CLI functionality (clap), QR code generation, password strength validation (zxcvbn), and comprehensive logging (log4rs). Optional DHAT heap profiling and tokio-console tracing support for development. Central wallet application for Tari cryptocurrency user interaction. |
| `README.md` | Comprehensive documentation for Minotari Console Wallet covering all operational modes and command-line interface usage. Documents TUI mode (default terminal interface), non-interactive GRPC mode (server operation), command mode (single operations), and script mode (batch processing). Includes detailed examples for all commands: get-balance, send-minotari, send-one-sided, make-it-rain, coin-split, base node management, UTXO operations (export/count), peer discovery, and identity lookup (whois). Provides practical examples with expected outputs, parameters, and usage patterns for wallet management and Tari network interaction. |
| `build.rs` | Build script for minotari_console_wallet providing platform-specific compilation configuration. Executes tari_features::resolver::build_features() for feature flag processing. On Windows, links icon.res resource file for application icon embedding with rerun-if-changed tracking. On non-Windows platforms, performs standard build process. Ensures proper resource linking and platform-specific build requirements for the console wallet application across different operating systems. |
| `icon.rc` | Windows resource file for Minotari Console Wallet application icon. Simple resource definition linking 'miner' identifier to 'icon.ico' file for Windows executable icon embedding. Used during Windows build process to associate application icon with the console wallet binary, providing visual branding and recognition in Windows file explorer, taskbar, and application launchers. |
| `icon.res` | Windows compiled resource file containing Minotari Console Wallet application icon. Binary resource file generated from icon.rc for Windows executable branding, providing visual identification in Windows file explorer, taskbar, and application launchers. Used during Windows build process to embed application icon into the console wallet executable for consistent visual identity across Windows deployments. |
| `log4rs_sample.yml` | Comprehensive log4rs configuration template for Minotari Console Wallet providing multi-destination logging with rotation and filtering. Configures appenders for stdout (general output), network (comms/P2P traffic), base_layer (wallet core operations), other (third-party crates), and contacts (contact management) with rolling file policies, size-based rotation (10MB limits), pattern-based formatting with timestamps and thread IDs. Features logger hierarchy with appropriate levels (debug/info/error) for different components, additive flag controls, and segregated log file organization. Essential for production wallet logging and debugging. |

##### applications/minotari_console_wallet/linux/

| File | Description |
|------|-------------|
| `start_minotari_console_wallet` | Linux executable startup script for Minotari Console Wallet providing application launcher functionality. Binary launcher script enabling easy console wallet startup on Linux systems with proper environment setup, configuration loading, and application initialization. Used for simplified wallet launch process in Linux desktop environments and command-line usage. |

###### applications/minotari_console_wallet/linux/runtime/

| File | Description |
|------|-------------|
| `start_minotari_console_wallet.sh` | Linux shell script for launching Minotari Console Wallet with proper configuration and Tor integration. Handles path initialization (base_path, config_path, exe_path), starts Tor daemon via start_tor.sh, manages log4rs configuration file creation with init flag detection, and spawns console wallet in new gnome-terminal with proper working directory and configuration parameters. Provides automated startup sequence ensuring proper environment setup, configuration validation, and terminal-based wallet interface launch for Linux deployments. |

###### applications/minotari_console_wallet/osx/runtime/

| File | Description |
|------|-------------|
| `start_minotari_console_wallet.sh` | macOS shell script for launching Minotari Console Wallet with proper environment configuration and dependencies. Handles macOS-specific setup including path initialization (base_path, config_path, exe_path), Tor daemon startup, log4rs configuration file management, and terminal application launch. Provides automated startup sequence ensuring proper environment setup, configuration validation, and macOS-compatible wallet interface launch with comprehensive error handling and logging support. |

##### applications/minotari_console_wallet/src/

| File | Description |
|------|-------------|
| `cli.rs` | Command-line interface definitions for Minotari Console Wallet using Clap parser for comprehensive argument and subcommand processing. Defines Cli struct with wallet configuration options (password, recovery, gRPC settings, file paths), wallet modes (interactive/non-interactive), and CliCommands enum covering all wallet operations including balance queries, transaction sending, pre-mine operations, atomic swaps, UTXO management, peer discovery, validator registration, and import/export functions. Features extensive argument structures for complex operations like make-it-rain stress testing, coin splitting, and multi-step pre-mine spending with validation and configuration override support. |
| `config.rs` | Configuration management for Minotari Console Wallet application combining common configuration, wallet-specific settings, auto-update configuration, and peer seed configuration into a unified ApplicationConfig structure. Implements configuration loading from Config objects with automatic base path propagation to wallet configuration. Provides centralized configuration management for all wallet services including networking, peer discovery, auto-update mechanisms, and common application settings. |
| `lib.rs` | Core library entry point for Minotari Console Wallet providing main execution logic and wallet mode coordination. Implements run_wallet and run_wallet_with_cli functions orchestrating wallet initialization, password management, recovery handling, hardware wallet support, and mode selection (TUI, gRPC, Script, Command, Recovery). Features libtor integration for privacy, seed word confirmation, direct-only send warnings, base node configuration, and wallet lifecycle management. Coordinates between CLI parsing, configuration management, wallet initialization, and various operational modes with comprehensive error handling and graceful shutdown. |
| `main.rs` | Main entry point for the Minotari Console Wallet application. Parses command-line arguments using Clap, initializes logging system, loads configuration from config.toml, and sets up gRPC server address with automatic port assignment. Creates multi-threaded tokio runtime and launches wallet with CLI interface. Includes modules for automation, CLI handling, configuration, gRPC services, initialization, notifications, recovery, UI components, utilities, and wallet operation modes. Supports tokio-console profiling and optional DHAT heap profiling for performance analysis. |
| `recovery.rs` | Wallet recovery implementation for Minotari Console Wallet providing seed-based wallet restoration and UTXO scanning functionality. Implements interactive seed word prompting (prompt_private_key_from_seed_words), seed validation (get_seed_from_seed_words), and comprehensive blockchain scanning (wallet_recovery) with peer management, retry logic, and progress reporting. Features UtxoScannerService integration, base node connectivity, event monitoring with progress updates, connection failure handling, and comprehensive recovery statistics. Supports secure input handling with Hidden types, mnemonic validation, and detailed recovery metrics including scan rate and value recovery reporting. |
| `wallet_modes.rs` | Wallet operational mode management for Minotari Console Wallet coordinating between TUI, gRPC, script, command, and recovery execution modes. Implements WalletMode enum, PeerConfig for base node management, and mode-specific execution functions including tui_mode (terminal interface), grpc_mode (server operation), script_mode (batch file processing), command_mode (single operations), and recovery_mode (wallet restoration). Features script command parsing, peer prioritization, TLS configuration, authentication setup, gRPC server management, and comprehensive mode transition logic. Includes extensive testing for command file parsing and supports both interactive and non-interactive operational patterns. |

###### applications/minotari_console_wallet/src/automation/

| File | Description |
|------|-------------|
| `commands.rs` | Command execution engine for Minotari Console Wallet automation providing comprehensive command line and script processing capabilities. Implements wallet operations including transaction sending (send_tari, send_one_sided_to_stealth_address), burning (burn_tari), pre-mine spending operations with multi-signature support, atomic swaps (init_sha_atomic_swap, finalise_sha_atomic_swap), validator node registration, UTXO management (coin_split), peer discovery, and stress testing (make_it_rain). Features transaction monitoring, batch operations, session-based pre-mine management, encrypted file I/O, networking connectivity checks, and comprehensive error handling. Exports command_runner for executing CLI command sequences with transaction lifecycle tracking. |
| `error.rs` | Error handling definitions for Minotari Console Wallet automation module using thiserror for comprehensive error management. Defines CommandError enum covering transaction errors, wallet service errors, output manager errors, key manager errors, I/O errors, configuration errors, communication errors, file processing errors (CSV, JSON), cryptographic errors, and script errors. Includes ParseError enum for input file parsing with support for various data types (floats, integers, dates, addresses). Features automatic error conversion from underlying service errors and ExitError conversion for proper application exit code handling. |
| `mod.rs` | Automation module aggregation for Minotari Console Wallet providing structured data types for multi-step pre-mine spending operations. Defines session-based data structures (PreMineSpendStep1SessionInfo through PreMineSpendStep4OutputsForLeader) with comprehensive transaction orchestration support including recipient information, cryptographic key management, signature aggregation, and encrypted data handling. Implements SessionId trait for session tracking and exports commands, error handling, and utilities modules. Central coordination point for complex multi-party pre-mine transaction workflows with JSON serialization support. |
| `prompt.rs` | Interactive command-line prompt utilities for Minotari Console Wallet automation providing user input collection with validation and type conversion. Implements Prompt struct with support for default values, conditional skipping, type parsing (ask_parsed), and repeated input collection (ask_repeatedly). Features specialized wrapper types: HexArg for hexadecimal input validation, Optional for nullable inputs, and YesNo for boolean confirmation prompts. Includes stdin reading with formatting and error handling for automation scenarios requiring user interaction. |
| `utils.rs` | File I/O and session management utilities for Minotari Console Wallet automation supporting JSON data persistence and session-based operations. Provides functions for reading/writing JSON objects (json_from_file_single_object, write_to_json_file), session directory management (create_pre_mine_output_dir, out_dir), session info validation (read_verify_session_info), partial file reading, and file manipulation utilities. Features comprehensive error handling, automatic directory creation, session ID validation, and support for multi-step pre-mine spending workflows with persistent state management. |

###### applications/minotari_console_wallet/src/grpc/

| File | Description |
|------|-------------|
| `mod.rs` | gRPC module aggregation for Minotari Console Wallet providing transaction event conversion and wallet service integration. Defines TransactionWrapper enum for unified handling of completed, outbound, and inbound transactions, and convert_to_transaction_event function for converting wallet transaction types to gRPC TransactionEvent messages. Exports wallet gRPC server functionality and debouncer utilities. Central coordination point for wallet gRPC API with transaction event streaming and status reporting capabilities. |
| `wallet_debouncer.rs` | Balance debouncing service for Minotari Console Wallet gRPC server implementing efficient balance caching with event-driven refresh mechanisms. Monitors wallet events (transaction, output manager, connectivity, UTXO scanner) to determine when balance updates are needed, providing cached responses when possible to reduce database load. Features automatic event monitoring startup, thread-safe balance caching, scanned height tracking, and comprehensive event handling for transaction lifecycle events, base node changes, TXO validation, and scanning progress. Essential for responsive gRPC balance queries while minimizing backend service calls. |
| `wallet_grpc_server.rs` | Comprehensive gRPC server implementation for Minotari Console Wallet providing full wallet API functionality through tonic-based service. Implements Wallet gRPC service with balance queries, transaction transfers, atomic swaps, HTLC operations, burn transactions, validator registration, address management, connectivity status, software updates, and transaction streaming. Features debounced balance retrieval, multi-recipient transfers, SHA atomic swap support, HTLC claim/refund operations, payment ID handling, transaction validation, and real-time event streaming. Includes consensus constants management, TLS support, authentication integration, and comprehensive error handling for all wallet operations. Essential as the primary programmatic interface for external applications to interact with the wallet. |

###### applications/minotari_console_wallet/src/init/

| File | Description |
|------|-------------|
| `mod.rs` | Wallet initialization and lifecycle management for Minotari Console Wallet providing secure wallet setup, password management, and hardware wallet integration. Implements wallet boot modes (New, Existing, Recovery, ViewAndSpendKey), password collection with strength validation, seed word confirmation, base node auto-detection, identity setup, and wallet validation. Features comprehensive password feedback using zxcvbn, hardware wallet support (Ledger), libtor integration, multi-signature recovery, and transaction/UTXO validation. Core initialization logic coordinating wallet creation, recovery, configuration, and startup processes with security best practices. |

###### applications/minotari_console_wallet/src/notifier/

| File | Description |
|------|-------------|
| `mod.rs` | External notification system for Minotari Console Wallet enabling custom script execution on transaction events. Implements Notifier struct that triggers external scripts with structured arguments for transaction events including received, sent, queued, mined, confirmed, and cancelled transactions. Features event broadcasting, async script execution, comprehensive argument formatting with transaction details (amounts, addresses, payment IDs, signatures), and support for completed, outbound, and inbound transaction types. Exports event constants (RECEIVED, SENT, QUEUED, CONFIRMATION, MINED, CANCELLED) and WalletEventMessage enum for internal event coordination. |
| `notify_example.sh` | Example notification script demonstrating external script integration with Minotari Console Wallet notification system. Sample shell script showing how to handle transaction events (received, sent, queued, mined, confirmed, cancelled) with structured arguments including transaction details, amounts, addresses, and payment information. Provides template for custom notification scripts enabling integration with external systems, desktop notifications, or automated transaction processing workflows. |

###### applications/minotari_console_wallet/src/ui/

| File | Description |
|------|-------------|
| `app.rs` | Main application structure for Minotari Console Wallet TUI (Terminal User Interface) providing comprehensive wallet interface management. Implements App struct with tab-based navigation (send, receive, transactions, contacts, burn, network, log, notifications, template registration), base node status monitoring, menu system, and notification handling. Features wallet identity management, state initialization, event handling for keyboard input, component lifecycle management, and UI rendering coordination. Integrates with wallet services, provides real-time balance updates, transaction monitoring, and supports comprehensive wallet operations through an intuitive terminal-based interface. |
| `mod.rs` | Terminal User Interface (TUI) module for Minotari Console Wallet providing crossterm-based interactive interface. Implements main UI loop with keyboard event handling, terminal management (raw mode, alternate screen), state initialization (transactions, contacts, burnt proofs, peers, connectivity), and component rendering. Features cross-platform key event processing (Windows/Unix), terminal title setting, balance debouncer startup, event monitoring initialization, and comprehensive error handling. Exports app structure and manages UI lifecycle including terminal setup, event processing, and graceful shutdown with proper terminal restoration. |
| `ui_burnt_proof.rs` | UI data structure for burnt proof display in Minotari Console Wallet providing formatted representation of burn transaction proofs. Implements UiBurntProof struct with proof ID, reciprocal claim public key, payload data, and burned timestamp. Simple but essential data structure for presenting burn transaction proof information in terminal interface, enabling users to view and manage their burnt coin proofs with proper formatting for console display. |
| `ui_contact.rs` | UI contact data structure for Minotari Console Wallet providing contact representation optimized for terminal display. Implements UiContact struct with alias, Tari address (Base58 format), emoji ID representation, formatted last seen timestamp, and online status information. Features conversion from Contact database type with automatic address formatting (Base58 and emoji string), timestamp formatting for terminal display, and online status integration. Provides clean separation between database contact storage and UI presentation with proper formatting for console wallet interface requirements. |
| `ui_error.rs` | Comprehensive error type definitions for Minotari Console Wallet UI operations using thiserror for error handling. Defines UiError enum covering transaction service errors, output manager errors, contacts service errors, connectivity errors, wallet storage errors, peer manager errors, address parsing errors, and UI-specific errors including burn proof file conflicts, channel send errors, transaction errors, wallet type errors, and public key parsing errors. Provides automatic error conversion from underlying service errors and detailed error messages for user feedback. Central error handling infrastructure for all wallet UI operations and service integration. |

###### applications/minotari_console_wallet/src/ui/components/

| File | Description |
|------|-------------|
| `balance.rs` | Balance display component for Minotari Console Wallet TUI providing real-time wallet balance visualization. Implements Component trait for tui-rs rendering with three-column layout displaying available balance (with time-locked amount), pending incoming balance, and pending outgoing balance. Features styled text with magenta-colored labels, proper margin handling, bordered display block, and responsive layout using horizontal constraints. Integrates with AppState for balance data retrieval and provides essential balance overview functionality for the wallet terminal interface. |
| `base_node.rs` | Base node status display component for Minotari Console Wallet TUI providing real-time blockchain synchronization monitoring. Shows chain tip information with current block height and wallet scan height, connection status with color-coded indicators (green=synced, yellow=syncing, red=offline), base node ID with connectivity state, latency measurements with color-coded performance indicators, and last update timestamps. Features automatic status updates, responsive layout with dynamic title spacing, comprehensive connection state visualization, and integration with wallet connectivity service for real-time base node monitoring and health display. |
| `burn_tab.rs` | Burn transaction tab component for Minotari Console Wallet TUI providing coin burning functionality with proof generation. Features interactive form with fields for burn proof filepath, claim public key, amount, fee-per-gram, and payment ID. Includes input validation, confirmation dialogs, real-time transaction status monitoring, and burnt proof list management. Supports burnt proof file creation, proof viewing with multi-column display, proof deletion with confirmation, keyboard navigation (V/K/A/F/P keys for field editing), and comprehensive error handling. Integrates with Balance component and provides complete burn transaction workflow with visual feedback and status tracking. |
| `component.rs` | Core component trait definition for Minotari Console Wallet TUI providing standardized interface for all UI components. Defines Component trait with draw method for rendering, keyboard event handlers (on_key, on_up, on_down, on_esc, on_backspace), tick handler for periodic updates, and format_title utility for consistent title styling. All event handlers have default implementations allowing components to selectively override needed functionality. Provides foundation for all wallet TUI components including tabs, dialogs, forms, and display elements with consistent event handling and rendering patterns. |
| `contacts_tab.rs` | Contacts management tab component for Minotari Console Wallet TUI providing comprehensive address book functionality. Features contact list display with multi-column layout (alias, Tari address, emoji ID, last seen, status), interactive contact editing with alias and address fields, contact creation and deletion with confirmation dialogs, keyboard navigation (E/Enter to edit, D to delete, N for new contact), input validation and error handling, and windowed list state for efficient large contact list handling. Integrates with app state for persistent contact storage and includes formatted contact display with compressed string utilities for optimal terminal presentation. |
| `events_component.rs` | Events display component for Minotari Console Wallet TUI providing tabular view of wallet events and system activity. Implements Component trait with Table widget displaying event type and description columns, keyboard navigation (Up/Down arrows) for event selection, table state management for selection tracking, and styled table headers. Features event data retrieval from AppState, row highlighting for selected events, and clean tabular presentation of wallet activity history. Essential for monitoring wallet operations and troubleshooting transaction and connection events. |
| `log_tab.rs` | Log viewing tab component for Minotari Console Wallet TUI providing real-time stdout log display with syntax highlighting. Features regex-based log parsing for timestamp, target, level, and message extraction, color-coded log levels (ERROR=red, WARN=yellow, INFO/DEBUG=magenta), scrollable log view with keyboard navigation (Up/Down arrows), automatic log file reading from 'log/wallet/stdout.log', newest-first display order, and formatted timestamp display. Includes comprehensive error handling for log file access and raw line display fallback for unparseable log entries. Essential debugging and monitoring tool for wallet operations. |
| `menu.rs` | Menu component for Minotari Console Wallet TUI providing application header information and status display. Shows wallet version information, current network (mainnet/testnet/etc.), connection status indicators, and other essential wallet metadata in horizontal layout. Features multi-column layout with proportional spacing, color-coded status information, and integration with app state for real-time status updates. Provides consistent header information across all wallet tabs and serves as primary status indicator for wallet state and connectivity. |
| `mod.rs` | UI components module aggregation for Minotari Console Wallet TUI organizing all terminal interface components. Exports balance display, base node management, burn transactions tab, component traits, contacts management, events handling, logging interface, menu system, network status, notifications, receive transactions, send transactions, styling utilities, tab container, and template registration components. Defines KeyHandled enum for keyboard event processing (Handled/NotHandled) enabling proper event delegation across UI components. Central coordination point for all wallet TUI functionality and component interaction patterns. |
| `network_tab.rs` | Network management tab component for Minotari Console Wallet TUI providing base node configuration and connectivity management. Features base node selection list with multi-column display (public key, address, alias), custom base node configuration with public key and address input fields, base node connectivity testing and validation, peer management functionality, and detailed base node inspection. Includes keyboard navigation (B for base node list), input validation for custom nodes, confirmation dialogs for configuration changes, and integration with Balance component. Provides comprehensive network configuration interface for wallet connectivity management and base node switching. |
| `notification_tab.rs` | Notification display tab component for Minotari Console Wallet TUI providing centralized notification management. Shows timestamped notifications in reverse chronological order with color-coded timestamps (green), automatic notification marking as read when tab is active, clear all notifications functionality (C key), and persistent notification storage during application lifetime. Features proper formatting for timestamp and message display, integration with wallet event monitor for notification generation, and clean UI layout with instructions and scrollable notification list. Provides essential user feedback system for wallet events and status updates. |
| `receive_tab.rs` | Receive tab component for Minotari Console Wallet TUI displaying wallet identity and payment information. Shows 'Who Am I?' section with wallet connection details including interactive and one-sided Tari addresses (Base58 format), node ID and public key, network addresses, emoji address representations, and QR code for easy sharing. Features clean layout with connection details section and large QR code display for mobile wallet scanning. Provides essential wallet identity information for receiving payments and wallet identification across the Tari network. |
| `register_template_tab.rs` | Template registration tab component for Minotari Console Wallet TUI providing smart contract template deployment interface. Features interactive form for template registration including template name, version, type selection (WASM/Flow), binary URL validation with SHA256 hash verification, repository URL extraction (GitHub/GitLab/Bitbucket), commit hash specification, and fee configuration. Includes URL parsing and validation, Git repository detection, template type inference from file extensions, comprehensive input validation, confirmation dialogs, real-time transaction status monitoring, and integration with Balance component. Enables registration of smart contract templates on Tari blockchain with proper validation and user feedback. |
| `send_tab.rs` | Send transaction tab component for Minotari Console Wallet TUI providing comprehensive transaction sending interface. Implements interactive form with fields for recipient address (Tari Address/Emoji ID), amount/token selection, fee-per-gram, and payment ID. Features input validation, contact selection from address book, confirmation dialogs for normal and one-sided transactions, real-time transaction status monitoring, and support for both regular and stealth address payments. Includes keyboard navigation (T/A/F/C/P keys), error/success message handling, transaction progress tracking, and wallet type compatibility (standard/ledger). Integrates with Balance component and contacts system for complete transaction management workflow. |
| `styles.rs` | UI styling definitions for Minotari Console Wallet TUI providing consistent visual themes across all components. Defines header_row style with magenta foreground color for table headers and highlight style with bold modifier and magenta color for selected items. Simple but essential styling module ensuring uniform appearance and user experience across all wallet interface components including tables, lists, and interactive elements. |
| `tabs_container.rs` | Tab container widget for Minotari Console Wallet TUI providing tabbed interface management and navigation. Implements TabsContainer with dynamic tab registration, tab switching functionality (next/previous navigation), keyboard event delegation to active tabs, and styled tab headers with highlighting. Features component lifecycle management, tab index tracking, title management, and proper event handling delegation to contained tab components. Provides foundation for wallet's multi-tab interface enabling organized access to different wallet functions (send, receive, transactions, contacts, etc.). |
| `transactions_tab.rs` | Transactions tab component for Minotari Console Wallet TUI providing comprehensive transaction history management. Features dual-panel layout with pending and completed transaction lists, transaction detail view with payment reference information, multi-column transaction display (date, amount, direction, status, counterparty), payment reference search functionality, transaction cancellation with confirmation, keyboard navigation between lists (P for pending, C for completed), and detailed transaction inspection. Includes payment reference tracking, confirmation count display, transaction rebroadcasting, comprehensive transaction status visualization, and integration with Balance component. Supports transaction filtering and detailed transaction analysis with QR code display for payment references. |

###### applications/minotari_console_wallet/src/ui/state/

| File | Description |
|------|-------------|
| `app_state.rs` | Core application state management for Minotari Console Wallet TUI providing centralized data and wallet operation coordination. Implements AppState with cached data layer, balance enquiry debouncing, wallet connectivity management, transaction state tracking, contacts management, burnt proofs handling, and comprehensive CRUD operations for wallet entities. Features async wallet operations (send transactions, burn transactions, template registration), base node management with automatic failover, payment reference calculation, notification system, event monitoring integration, and real-time status updates. Includes confirmation tracking, transaction filtering, peer management, and custom base node configuration. Central state controller coordinating all wallet services and UI data flow with caching optimization and event-driven updates. |
| `debouncer.rs` | Balance enquiry debouncing service for Minotari Console Wallet providing efficient balance update management and reducing excessive database queries. Implements BalanceEnquiryDebouncer with configurable cooldown periods, broadcast channel coordination, interval-based balance fetching, missed tick handling, and integration with OutputManagerService. Features automatic balance update triggering, cooldown period enforcement, shutdown signal handling, comprehensive error handling for balance retrieval failures, and debug logging for balance state changes. Essential performance optimization preventing excessive balance queries while maintaining responsive UI updates. |
| `mod.rs` | State management module aggregation for Minotari Console Wallet TUI organizing application state components and serialization structures. Exports app_state functionality and defines Base64-serialized data structures for commitment signatures (CommitmentSignatureBase64 with public_nonce, u, v fields) and burnt proofs (BurntProofBase64 with reciprocal claim public key, commitment, ownership proof, range proof). Coordinates state management modules including app state, debouncer, task execution, and wallet event monitoring. Central coordination point for wallet UI state with proper serialization support for cryptographic data structures. |
| `tasks.rs` | Asynchronous task execution for Minotari Console Wallet UI providing background wallet operations. Implements send_transaction_task for standard transactions, send_one_sided_to_stealth_address_transaction for privacy payments, send_burn_transaction_task for coin burning with proof generation, and send_register_template_transaction_task for smart contract template registration. Features transaction event monitoring, status broadcasting via watch channels, comprehensive error handling, file I/O for burn proofs, cryptographic signature generation, and real-time progress reporting. Essential background processing layer enabling UI responsiveness during long-running wallet operations. |
| `wallet_event_monitor.rs` | Comprehensive wallet event monitoring service for Minotari Console Wallet TUI providing real-time event processing and state synchronization. Implements WalletEventMonitor that listens to transaction service events, output manager events, connectivity events, base node events, contacts liveness events, and UTXO scanner events using tokio::select! for concurrent event handling. Features automatic state refresh triggers for transactions, confirmations, balance updates, peer connections, base node changes, and contacts status. Includes notification generation, external script triggering via Notifier, debounced balance refresh mechanism, and comprehensive error handling with retry logic. Essential coordination layer ensuring UI state consistency with underlying wallet services and providing real-time user feedback through notifications and state updates. |

###### applications/minotari_console_wallet/src/ui/widgets/

| File | Description |
|------|-------------|
| `list_state.rs` | Windowed list state management widget for Minotari Console Wallet TUI providing efficient handling of large data sets in terminal interface. Implements WindowedListState with viewport management, scroll offset tracking, item selection handling, window bounds checking, and automatic scroll adjustment when selection moves outside visible area. Features dynamic start/end window calculation, selected item tracking, height-based viewport sizing, and integration with tui-rs ListState for optimal performance with large lists. Essential for responsive navigation in transaction lists, contact lists, and other large datasets without performance degradation. |
| `mod.rs` | UI widgets module aggregation for Minotari Console Wallet TUI providing custom widget components. Exports list state management (WindowedListState for efficient large list handling), multi-column list widget (MultiColumnList for tabular data display), and utility functions for UI layout and dialog creation. Provides foundation widgets used across all wallet TUI components for consistent data presentation, navigation, and user interaction patterns. Central collection of reusable UI building blocks for terminal-based wallet interface. |
| `multi_column_list.rs` | Multi-column list widget for Minotari Console Wallet TUI providing tabular data display with customizable columns and styling. Implements MultiColumnList with column management (heading, width, items), style configuration (highlight style, heading style), symbol customization, maximum width constraints, and rendering functionality. Features dynamic column layout calculation, heading display with styled headers, proper constraint distribution across columns, and integration with tui-rs ListState for selection handling. Essential widget for displaying structured data like transaction lists, contact lists, and other tabular information in terminal interface. |
| `utilities.rs` | UI utility functions for Minotari Console Wallet TUI providing common dialog and layout helpers. Implements draw_dialog function for modal dialog rendering with customizable title, message, color, width, and height parameters. Features centered_rect_absolute function for absolute positioning calculations and other layout utilities for consistent UI element placement and styling. Essential utilities supporting dialog boxes, popup windows, and other UI components throughout the wallet terminal interface. |

###### applications/minotari_console_wallet/src/utils/

| File | Description |
|------|-------------|
| `crossterm_events.rs` | Cross-platform keyboard event handling utilities for Minotari Console Wallet TUI using crossterm library. Provides event processing abstractions, key mapping utilities, and input handling functions for consistent keyboard interaction across different terminal environments. Enables portable terminal input handling supporting Windows, macOS, and Linux platforms with unified event processing for wallet UI navigation and control. |
| `db.rs` | Database utility functions for Minotari Console Wallet providing custom base node persistence functionality. Implements get_custom_base_node_peer_from_db for retrieving stored base node configuration (public key and address) from wallet database and constructing Peer objects. Features set_custom_base_node_peer_in_db for persisting custom base node settings with proper key-value storage, hex encoding/decoding, multiaddr parsing, and comprehensive error handling. Defines storage key constants (CUSTOM_BASE_NODE_PUBLIC_KEY_KEY, CUSTOM_BASE_NODE_ADDRESS_KEY) and provides database interaction abstraction for base node management. |
| `events.rs` | General event handling utilities for Minotari Console Wallet TUI providing event processing abstractions and coordination. Implements event management patterns, event delegation utilities, and common event handling functions used across the wallet terminal interface. Provides foundation for consistent event processing and UI responsiveness throughout the console wallet application. |
| `formatting.rs` | Text formatting utilities for Minotari Console Wallet TUI providing string display helpers. Implements display_compressed_string for truncating long strings with ellipsis (unicode-aware grapheme handling), display_address for extracting best network address from Peer objects, and other formatting functions for consistent text presentation in terminal interface. Features unicode segmentation support for proper international character handling and peer address formatting for network display. Essential utilities for clean and consistent text display across all wallet TUI components. |
| `mod.rs` | Utility modules aggregation for Minotari Console Wallet providing shared helper functionality. Exports crossterm event handling utilities, database utilities for wallet operations, general event processing, and formatting utilities. Central coordination point for common utilities used across the console wallet application including UI event management, database persistence helpers, and formatting functions for user interface display. |
| `termion_events.rs` | Termion-specific event handling utilities for Minotari Console Wallet TUI providing alternative terminal backend support. Implements termion library event processing, key mapping, and input handling for Unix-like systems using termion terminal library. Provides alternative event handling implementation for platforms where termion is preferred over crossterm for terminal interface operations. |

##### applications/minotari_console_wallet/windows/

| File | Description |
|------|-------------|
| `start_minotari_console_wallet.lnk` | Windows shortcut file for Minotari Console Wallet providing desktop launcher functionality. Binary Windows LNK file enabling convenient desktop and Start Menu access to the console wallet application. Contains target path, working directory, and icon settings for seamless Windows integration and user-friendly application launch experience. |

###### applications/minotari_console_wallet/windows/runtime/

| File | Description |
|------|-------------|
| `source_minotari_console_wallet_env.bat` | Windows batch script for environment variable configuration for Minotari Console Wallet. Sets up Windows-specific environment variables, path configurations, and system settings required for proper wallet operation. Provides Windows environment preparation ensuring correct configuration paths, library locations, and system dependencies for reliable console wallet execution on Windows platforms. |
| `start_minotari_console_wallet.bat` | Windows batch script for launching Minotari Console Wallet with proper environment setup and configuration management. Handles Windows-specific startup sequence including environment variable sourcing, configuration path setup, Tor daemon management, and wallet application launch. Provides automated Windows startup process ensuring proper environment preparation, configuration validation, and reliable wallet interface launch with error handling and logging support. |

##### applications/minotari_ledger_wallet/common/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for minotari_ledger_wallet_common crate providing shared functionality between Ledger hardware wallet application and Tari software components. Minimal dependencies including bs58 for Base58 encoding/decoding with no_std compatibility and alloc feature support. Designed for cross-compilation between embedded ledger environment (no-std) and standard Rust applications, enabling common type definitions, utilities, and data structures shared across Ledger hardware wallet integration components. |

###### applications/minotari_ledger_wallet/common/src/

| File | Description |
|------|-------------|
| `common_types.rs` | Common type definitions for Tari Ledger hardware wallet integration providing shared error codes and status words. Defines AppSW enum with comprehensive Ledger application status words including operation success (Ok), user cancellation (UserCancelled), various cryptographic failure modes (SchnorrSignatureFail, KeyDeriveFail, etc.), invalid instruction handling (InsNotSupported, WrongApduLength), and Tari-specific error conditions. Features status word conversion from numeric codes, detailed error categorization for signature failures, key derivation errors, and APDU protocol handling. Essential for proper error handling and status reporting in Ledger wallet communication. |
| `lib.rs` | Common types library for Tari Ledger hardware wallet integration providing no_std compatible shared functionality between Ledger application and Tari codebase. Exports common_types module for shared data structures, utility functions for Tari dual address handling (get_public_spend_key_bytes_from_tari_dual_address, tari_dual_address_display), and TARI_DUAL_ADDRESS_SIZE constant. Designed for cross-compilation compatibility between ledger-device-rust-sdk (no-std) and standard Tari applications, enabling secure hardware wallet operations with proper type safety and address manipulation utilities. |
| `utils.rs` | Utility functions for Tari Ledger hardware wallet common operations providing shared functionality between Ledger application and host software. Implements helper functions for address manipulation, data conversion, cryptographic utilities, and common operations used across Ledger wallet integration components. Features no_std compatibility for embedded Ledger environment while providing essential utility functions for Tari dual address handling and protocol compliance. |

##### applications/minotari_ledger_wallet/comms/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for minotari_ledger_wallet_comms crate providing communication interface between Tari software and Ledger hardware wallet devices. Dependencies include Tari core libraries (tari_crypto, tari_script, tari_common_types), Ledger transport libraries (ledger-transport, ledger-transport-hid) from Zondax for HID communication, serialization support (borsh, serde), user interaction (dialoguer), and utility libraries. Enables host computer communication with Ledger devices for secure transaction signing, key management, and cryptographic operations in Tari ecosystem. |

###### applications/minotari_ledger_wallet/comms/examples/ledger_demo/

| File | Description |
|------|-------------|
| `main.rs` | Demonstration program for Tari Ledger hardware wallet communication testing all device functionality. Implements comprehensive test suite covering device connection, key derivation, signature generation, transaction signing, and protocol validation. Features interactive prompts for device actions, error handling demonstration, and complete workflow testing for Ledger wallet integration. Essential testing tool for verifying Ledger device functionality and debugging communication issues during development and deployment. |

###### applications/minotari_ledger_wallet/comms/src/

| File | Description |
|------|-------------|
| `accessor_methods.rs` | Accessor method implementations for Tari Ledger hardware wallet communication providing high-level device interaction interfaces. Implements device communication methods, command formatting, response parsing, and protocol handling for Ledger wallet operations. Features structured access to device functionality including key derivation, signature generation, and transaction processing with proper error handling and validation. Essential interface layer abstracting low-level device communication for higher-level wallet integration. |
| `error.rs` | Error handling definitions for Tari Ledger hardware wallet communication using thiserror for comprehensive error management. Defines error types covering device communication failures, protocol errors, APDU command errors, cryptographic operation failures, and hardware wallet specific error conditions. Features automatic error conversion from transport layers, detailed error categorization, and integration with Ledger device SDK error types. Essential error handling infrastructure for robust Ledger wallet communication and user feedback. |
| `ledger_wallet.rs` | Core Ledger hardware wallet communication implementation providing device interface and protocol handling. Implements LedgerWallet struct with device connection management, APDU command processing, transaction signing workflows, key derivation operations, and comprehensive error handling. Features device discovery, connection lifecycle management, command queuing, response validation, and integration with Ledger transport layer. Central component enabling secure communication between Tari software and Ledger hardware devices for cryptocurrency operations. |
| `lib.rs` | Ledger wallet communication library providing host-side interface for Tari Ledger hardware wallet integration. Exports accessor methods for device communication, error handling, and ledger wallet functionality. Includes comprehensive test suite for script serialization verification testing PushPubKey, Nop, PushOne, and CheckSigVerify scripts with hex representation validation. Features Tari address handling, cryptographic key operations, script verification, and protocol compliance testing. Essential communication layer enabling secure interaction between Tari software and Ledger hardware devices for transaction signing and key management. |

##### applications/minotari_ledger_wallet/wallet/

| File | Description |
|------|-------------|
| `.gitignore` | Git ignore file for Tari Ledger hardware wallet application excluding build artifacts, compiled binaries, temporary files, and device-specific generated content from version control. Prevents tracking of Ledger app build outputs, target directories, device-specific compiled assets, and development artifacts ensuring clean repository state for Ledger wallet development workflow. |
| `Cargo.lock` | Cargo dependency lock file for Tari Ledger hardware wallet application ensuring reproducible builds with exact dependency versions. Contains precise version specifications and checksums for all Ledger-specific dependencies including ledger-device-sdk, cryptographic libraries, and no_std compatible crates. Critical for consistent Ledger app compilation across development environments and ensuring compatibility with specific Ledger device firmware versions and hardware constraints. |
| `Cargo.toml` | Cargo configuration for Tari Ledger hardware wallet application providing secure transaction signing on Ledger devices. Configured for BIP32 hierarchical deterministic wallet with coin type 535348, supporting secp256k1 curve, and Ledger device SDK integration. Includes cryptographic dependencies (blake2, curve25519-dalek, zeroize) with no_std compatibility, device-specific icon configurations for different Ledger models (nanox, nanosplus, stax, flex), and optimized release profile with size optimization (opt-level z, LTO enabled, panic abort). Features cargo-ledger build system integration and Ledger app metadata for MinoTari Wallet branding. |
| `README.md` | Comprehensive setup and usage documentation for Tari Ledger hardware wallet application. Covers complete development workflow including Ledger Live device verification, firmware requirements, development environment setup with rust-src and cargo-ledger installation, device management via ledgerctl Python application, Docker-based building with official ledger-app-builder image, manual installation procedures, application testing with ledger_demo example, and emulator testing with Speculos. Includes platform-specific instructions for Unix/macOS/Windows, troubleshooting common errors (application version mismatches, signature validation failures), and detailed build/install commands. Essential guide for developers working with Tari Ledger hardware wallet integration. |
| `build.rs` | Build script for Tari Ledger hardware wallet application providing device-specific compilation configuration and asset management. Handles Ledger device-specific build requirements, icon asset processing for different device types (nanox, nanosplus, stax, flex), build configuration validation, and integration with cargo-ledger build system. Features device-specific resource handling and compilation flags ensuring proper application building for various Ledger hardware platforms with appropriate memory and display constraints. |
| `ledger_app.toml` | Ledger application configuration file for Tari hardware wallet defining application metadata, device compatibility, and build settings. Specifies app name, version, author information, device support matrix (nanox, nanosplus, stax, flex), icon configurations, permissions, and Ledger-specific application parameters. Contains build configuration for cargo-ledger integration and device-specific deployment settings ensuring proper application packaging and installation on Ledger hardware devices. |
| `rust-toolchain.toml` | Rust toolchain configuration file for Tari Ledger hardware wallet application specifying exact compiler version and components required for building. Defines stable or nightly Rust channel requirements, target platform specifications, and necessary components for Ledger device compilation. Critical for ensuring consistent build environment across development teams and maintaining compatibility with Ledger device SDK requirements and embedded compilation constraints. |

###### applications/minotari_ledger_wallet/wallet/.cargo/

| File | Description |
|------|-------------|
| `config.toml` | Cargo configuration for Tari Ledger hardware wallet application providing device-specific build settings and optimization. Configures target-specific linkers, build flags, and compilation options for Ledger device environments. Features no_std compatibility settings, size optimization flags, and device-specific build configurations ensuring proper compilation for embedded Ledger hardware platforms with memory and size constraints. |

###### applications/minotari_ledger_wallet/wallet/src/

| File | Description |
|------|-------------|
| `hashing.rs` | Domain-separated consensus hashing implementation for Tari Ledger hardware wallet providing secure cryptographic hash functions with network-specific domain separation. Implements DomainSeparatedConsensusHasher with network-aware labeling (format: '{label}.n{network}'), DomainSeparatedBorshHasher for Borsh-encoded data serialization, WriteHashWrapper for digest integration, and DomainSeparatedHash output wrapper. Features network-specific domain separation for security, Borsh serialization integration for consensus encoding, chainable hash updates for multiple data items, digest abstraction for multiple hash algorithms, infallible serialization requirements, and comprehensive error handling. Essential for maintaining consensus-compatible hashing across Tari protocol operations while ensuring cryptographic security through proper domain separation on Ledger hardware devices with no_std compatibility. |
| `main.rs` | Ledger hardware wallet application for Tari cryptocurrency implementing secure key management and transaction signing. Provides APDU command handling for key derivation, Schnorr signatures, script signatures, view keys, shared secrets, and metadata signatures. Implements BIP32 hierarchical deterministic wallet (coin type 535348), Ledger SDK integration, UI menu systems for different device types (Stax, Flex), and comprehensive error handling. Supports secure cryptographic operations including script offsets, one-sided payments, and hardware-based transaction validation for Tari. |
| `utils.rs` | Comprehensive utility functions for Tari Ledger hardware wallet providing cryptographic operations, key derivation, and device interaction helpers. Implements BIP32Path struct for hierarchical deterministic key paths, derive_from_bip32_key for secure key derivation (coin type 535348) with domain-separated hashing, get_key_from_uniform_bytes/get_key_from_canonical_bytes for key conversion, alpha_hasher for script key derivation with blinding factors, get_random_nonce for cryptographic randomness using LedgerRng, device-specific error handling with UI feedback, u64_to_string for no_std number conversion, CxError to string conversion for debugging, secure 64-byte BIP32 key derivation with Secp256k1 curve and validation, and comprehensive error handling. Features domain separation (LedgerHashDomain, KeyManagerTransactionsHashDomain), secure memory management with Zeroizing, extensive validation, and device-specific user interaction. Essential foundation for all cryptographic operations and key management on Ledger hardware devices supporting Tari protocol compliance. |

###### applications/minotari_ledger_wallet/wallet/src/app_ui/

| File | Description |
|------|-------------|
| `menu.rs` | User interface menu system for Tari Ledger hardware wallet application providing device-specific UI navigation and display management. Implements menu structures, navigation logic, and display rendering for different Ledger device types (Stax, Flex with color displays vs. nanox/nanosplus with monochrome). Features context-aware menu generation, user interaction handling, and device-appropriate UI presentation for secure transaction confirmation and wallet operations on Ledger hardware. |

###### applications/minotari_ledger_wallet/wallet/src/crypto/

| File | Description |
|------|-------------|
| `commitment.rs` | Commitment cryptographic operations for Tari Ledger hardware wallet providing secure commitment generation and verification. Implements no_std compatible commitment algorithms, Pedersen commitment operations, commitment arithmetic, and validation functions for Tari's privacy-preserving transaction protocol. Features secure commitment blinding, commitment verification, and integration with Ledger device secure element for cryptographic operations ensuring transaction privacy and security on hardware wallet platform. |
| `commitment_and_public_key_signature.rs` | Commitment and public key signature operations for Tari Ledger hardware wallet implementing combined cryptographic signature schemes. Provides no_std compatible functions for generating signatures involving both commitments and public keys, signature verification, and cryptographic proof generation. Features secure signature creation using Ledger device secure element, commitment-based signature schemes, and integration with Tari's advanced cryptographic protocols for privacy-preserving transaction validation. |
| `commitment_factory.rs` | Commitment factory implementation for Tari Ledger hardware wallet providing standardized commitment generation and management. Implements no_std compatible commitment factory pattern for consistent commitment creation, parameter management, and cryptographic operations. Features commitment generation workflows, parameter validation, and integration with Ledger device cryptographic capabilities ensuring standardized and secure commitment operations across all Tari privacy-preserving transaction protocols. |
| `hashing.rs` | Cryptographic hashing operations for Tari Ledger hardware wallet providing secure hash functions and domain separation. Implements no_std compatible hashing algorithms, domain-separated hash functions, and message digest operations required for Tari cryptographic protocols. Features Blake2b hashing, domain separation for security, hash-based key derivation, and integration with Ledger device cryptographic capabilities ensuring consistent and secure hashing operations across all wallet functions. |
| `keys.rs` | Cryptographic key management for Tari Ledger hardware wallet providing secure key derivation, generation, and handling. Implements no_std compatible key operations including BIP32 hierarchical deterministic key derivation, private key generation, public key computation, and key validation. Features secure key storage using Ledger device secure element, key derivation path handling, and integration with Tari key management protocols ensuring secure cryptographic key operations on hardware wallet platform. |
| `mod.rs` | Cryptographic module aggregation for Tari Ledger hardware wallet organizing all cryptographic operations and algorithms. Exports commitment operations, signature schemes, key management, hashing functions, and Schnorr signature implementations. Provides centralized access to all cryptographic functionality required for Tari protocol compliance on Ledger hardware devices with no_std compatibility and secure element integration for enhanced security and performance. |
| `schnorr.rs` | Schnorr signature implementation for Tari Ledger hardware wallet providing secure digital signature operations. Implements no_std compatible Schnorr signature generation, verification, and key operations using curve25519-dalek for elliptic curve cryptography. Features secure signature creation with Ledger device secure element, nonce generation, signature verification, and integration with Tari's Schnorr signature protocols ensuring cryptographically secure transaction signing on hardware wallet platform. |

###### applications/minotari_ledger_wallet/wallet/src/handlers/

| File | Description |
|------|-------------|
| `get_dh_shared_secret.rs` | Diffie-Hellman shared secret generation handler for Tari Ledger hardware wallet application implementing secure ECDH key exchange operations. Processes APDU commands containing account/index/key derivation parameters and counterparty public key (56 bytes total) to generate shared secrets using BIP32 hierarchical key derivation. Validates input data length, derives private key using derive_from_bip32_key, performs elliptic curve point multiplication for ECDH, and returns shared secret with proper memory zeroization. Features device-specific UI feedback (SingleMessage for nanox/nanosplus, NbglStatus for stax/flex), comprehensive error handling for invalid inputs, and secure memory management with Zeroizing wrapper. Essential for privacy-preserving protocols requiring secure key exchange on Ledger hardware devices. |
| `get_one_sided_metadata_signature.rs` | One-sided metadata signature handler for Tari Ledger hardware wallet implementing secure signature generation for stealth payments. Processes APDU commands containing account/network/TXO version, sender offset key index, transaction value, commitment mask, receiver address (67 bytes), and metadata signature message. Features interactive user confirmation with device-specific UI (MultiFieldReview for nanox/nanosplus, NbglReview for stax/flex), cryptographic signature generation using CommitmentAndPublicKeySignature with ephemeral keys (r_a, r_x, ephemeral_private_key), commitment factory integration, stealth address script generation with receiver public spend key derivation, domain-separated challenge hashing, comprehensive error handling with user feedback, and Minotari currency formatting. Essential for privacy-preserving one-sided payments enabling secure metadata signatures on Ledger devices with proper user confirmation and cryptographic validation. |
| `get_public_key.rs` | Public key derivation handler for Tari Ledger hardware wallet application providing BIP32 hierarchical deterministic key generation. Processes APDU commands containing account/index/key derivation parameters (24 bytes total) to derive and return Ristretto public keys from BIP32 private keys. Validates input data length, parses little-endian encoded parameters, derives private key using derive_from_bip32_key, computes corresponding public key using elliptic curve operations, and returns public key bytes with response version. Features device-specific UI feedback for invalid data, comprehensive error handling, and secure key derivation following BIP32 standards. Essential for wallet address generation and transaction signing workflows on Ledger hardware devices. |
| `get_public_spend_key.rs` | Public spend key derivation handler for Tari Ledger hardware wallet providing BIP32 hierarchical deterministic public key generation for wallet address creation. Processes APDU commands containing 8-byte account parameter, validates input data length, derives private key using BIP32 path with STATIC_SPEND_INDEX and KeyType::Spend, computes corresponding Ristretto public key from private key, and returns versioned response with 32-byte public key. Features device-specific error handling (SingleMessage for nanox/nanosplus, NbglStatus for stax/flex), comprehensive input validation, secure key derivation following BIP32 standards, and proper response formatting. Essential for generating wallet addresses and enabling transaction reception on Ledger hardware devices with secure key management and cryptographic operations. |
| `get_schnorr_signature.rs` | Schnorr signature generation handlers for Tari Ledger hardware wallet providing dual signature modes for transaction validation and script execution. Implements handler_get_raw_schnorr_signature for general purpose signatures using RistrettoSchnorr with 104-byte input (account, private key index/type, nonce index/type, 64-byte challenge) and handler_get_script_schnorr_signature for script validation using CheckSigSchnorrSignature with 56-byte input (account, key parameters, 32-byte nonce/message). Features BIP32 key derivation for both private keys and nonces, domain-separated signature algorithms (SchnorrSigChallenge for general, CheckSigHashDomain for scripts), comprehensive error handling with device-specific UI feedback, input validation, random nonce generation for script signatures, and returns versioned responses with public nonce and signature components. Essential for cryptographic transaction signing and script validation on Ledger devices supporting Tari's privacy-preserving signature schemes. |
| `get_script_offset.rs` | Script offset calculation handler for Tari Ledger hardware wallet implementing secure multi-chunk script offset computation with attack protection. Manages ScriptOffsetCtx state across multiple APDU chunks processing sender offset keys and script private keys through chunked operations. Features chunk-based processing (chunk 0: instructions with totals, chunk 1: partial script offset, chunks 2+: indexed/derived keys), BIP32 key derivation for indexed keys, alpha-based derived key computation, unique key tracking with MIN_UNIQUE_KEYS=2 attack prevention, sender offset sum and script private key sum accumulation, final script offset calculation (script_sum - sender_sum), comprehensive error handling, state management with reset functionality, and secure key uniqueness validation. Essential for complex transaction script validation on Ledger devices ensuring script integrity while preventing key extraction attacks through cryptographic offset computation. |
| `get_script_signature.rs` | Script signature generation handlers for Tari Ledger hardware wallet providing dual modes for managed and derived script key signatures. Implements handler_get_script_signature_managed for BIP32-derived script keys (168-byte input with branch/index) and handler_get_script_signature_derived for alpha-derived script keys (184-byte input with blinding factor). Features common parameter extraction (account, network, TXO version, value, commitment private key, commitment, script message), script private key derivation (managed via BIP32 or derived via alpha_hasher), CommitmentAndPublicKeySignature generation with three random nonces (r_a, r_x, r_y), nonce uniqueness validation, PedersenCommitmentFactory integration, domain-separated challenge hashing, comprehensive error handling with device-specific UI feedback, and secure signature computation. Essential for script validation in Tari transactions enabling secure script execution verification on Ledger hardware devices with flexible key derivation strategies. |
| `get_version.rs` | Version information handler for Tari Ledger hardware wallet application providing simple firmware version reporting. Implements handler_get_version function that extracts version string from CARGO_PKG_VERSION environment variable at compile time and returns it as byte array through APDU response. Minimal implementation with no input validation or error handling, directly appending version bytes to communication channel. Essential for host applications to verify Ledger wallet firmware version compatibility and debugging, enabling version-specific feature detection and ensuring proper application-firmware compatibility during Tari wallet operations. |
| `get_view_key.rs` | View key derivation handler for Tari Ledger hardware wallet providing private view key generation for transaction scanning and wallet synchronization. Processes APDU commands containing 8-byte account parameter, validates input data length, derives view key using BIP32 path with STATIC_VIEW_INDEX and KeyType::ViewKey, and returns versioned response with 32-byte private view key. Features device-specific error handling (SingleMessage for nanox/nanosplus, NbglStatus for stax/flex), comprehensive input validation, secure BIP32 key derivation following Tari key management standards, and proper response formatting. Essential for wallet synchronization enabling blockchain scanning for relevant transactions while maintaining privacy on Ledger hardware devices through hierarchical deterministic key management. |

#### applications/minotari_merge_mining_proxy/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for minotari_merge_mining_proxy application enabling Tari merge mining with Monero through XMRig integration. Dependencies include Tari gRPC clients (base node, wallet), networking utilities, core blockchain components, and external libraries for HTTP server operations (hyper), JSON-RPC communication (jsonrpc), Monero protocol support, blockchain scraping (scraper), serialization (serde, bincode, borsh), and async runtime (tokio). Features DHAT heap profiling support for memory analysis and comprehensive merge mining proxy functionality bridging Monero mining pools with Tari blockchain. Build dependencies include tari_features for compile-time feature management. |
| `build.rs` | Build script for Minotari merge mining proxy application providing platform-specific compilation configuration and Windows resource integration. Executes tari_features::resolver::build_features() for feature flag processing on all platforms. On Windows, includes icon.res resource file linking with rerun-if-changed tracking and rustc-link-arg for resource embedding in the executable. On non-Windows platforms, performs standard build process without additional resource linking. Ensures proper application branding with icon resources while maintaining cross-platform build compatibility for the merge mining proxy application. |
| `icon.rc` | Windows resource file for Minotari merge mining proxy application icon. Simple resource definition linking 'miner' identifier to 'icon.ico' file for Windows executable icon embedding. Used during Windows build process to associate application icon with the merge mining proxy binary, providing visual branding and recognition in Windows file explorer, taskbar, and application launchers. |
| `icon.res` | [GENERATED] Windows resource file containing application icon data for the Minotari merge mining proxy executable. Binary resource data (279KB) used during Windows build process to embed icon into the application. |
| `log4rs_sample.yml` | Comprehensive log4rs configuration template for Minotari merge mining proxy providing multi-destination logging with rotation and filtering. Configures appenders for stdout (INFO+ levels, simplified format with timestamp and level) and proxy rolling file (all levels, detailed format with timestamps, targets, levels, file locations, 10MB rotation with 50 file retention). Features 30-second refresh rate, threshold filters, compound rolling policy with size triggers and fixed window rotation, comprehensive logger hierarchy covering h2/hyper (info), html5ever/selectors (error only), and customizable log directory with template substitution. Essential for production merge mining proxy monitoring, debugging, and operational insights with proper log management and performance optimization. |
| `monero_stagenet_setup.md` | Comprehensive Monero stagenet environment setup guide for testing merge mining proxy functionality. Provides detailed Linux installation instructions for complete Monero testnet infrastructure including monerod daemon (release-v0.17, stagenet mode with external RPC binding), monero-wallet-cli and monero-wallet-RPC setup, monero-pool configuration with custom pool.conf settings, onion-monero-blockchain-explorer for transaction monitoring, and XMRig miner configuration with wizard-based setup. Features system requirements (build tools, dependencies, hugepages configuration), network configuration with IP binding, wallet creation and daemon connectivity, pool mining setup with proper authentication, blockchain explorer compilation with cmake, and complete testing environment coordination. Essential documentation for developers testing Tari/Monero merge mining integration requiring full Monero stagenet infrastructure for validation and testing purposes. |

###### applications/minotari_merge_mining_proxy/linux/runtime/

| File | Description |
|------|-------------|
| `start_minotari_merge_mining_proxy.sh` | Linux shell script for launching Minotari merge mining proxy with automated configuration setup and Gnome terminal integration. Handles path initialization (base_path, config_path, exe_path), creates log4rs configuration file with init flag detection if missing, and spawns merge mining proxy in new gnome-terminal with proper working directory and configuration parameters. Provides automated startup sequence ensuring proper environment setup, configuration validation, and terminal-based proxy interface launch for Linux deployments enabling Tari/Monero merge mining operations. |
| `start_xmrig.sh` | Linux shell script for launching XMRig miner with automatic installation and configuration management for merge mining operations. Handles XMRig installation verification (~/xmrig directory), executes install_xmrig.sh if binary not found, copies staging network configuration (xmrig_config_example_stagenet.json to config.json), and spawns XMRig in new gnome-terminal. Provides comprehensive XMRig dependency management including installation fallback, configuration file deployment, error handling for missing dependencies, and automated miner launch process for Tari/Monero merge mining workflow. |

###### applications/minotari_merge_mining_proxy/osx/runtime/

| File | Description |
|------|-------------|
| `start_minotari_merge_mining_proxy.sh` | macOS startup script for Minotari merge mining proxy. Initializes log4rs_merge_mining_proxy.yml if missing, creates and executes initialization and command scripts, checks if proxy is already running on port 18081, then launches proxy in new Terminal.app window. Dependencies: lsof, minotari_merge_mining_proxy executable. Used by: macOS deployment for merge mining proxy startup with configuration management. |
| `start_xmrig.sh` | macOS startup script for XMRig mining software used with merge mining proxy. Sets up base path, config path, exe path variables. Installs XMRig if not found via install_xmrig.sh. Copies stagenet config file and spawns XMRig in new terminal. Used by: OSX merge mining setup. |

##### applications/minotari_merge_mining_proxy/src/

| File | Description |
|------|-------------|
| `block_template_data.rs` | Block template repository and data management for Minotari merge mining proxy providing template storage and retrieval functionality. Implements BlockTemplateRepository with thread-safe HashMap storage for block templates, timestamped BlockRepositoryItem for template caching, template insertion and cleanup with TTL management, hash-based template lookup, and integration with FinalBlockTemplateData. Features auxiliary chain hash generation, template data validation, concurrent access handling with RwLock, automatic cleanup of expired templates, and comprehensive error handling. Essential for managing block templates in merge mining workflow between XMRig and Tari base node. |
| `block_template_manager.rs` | Block template management for Minotari merge mining proxy coordinating between Tari base node, Monero daemon, and P2Pool for dual cryptocurrency mining. Implements BlockTemplateManager with gRPC client coordination, template retrieval from base node, coinbase transaction generation, auxiliary chain Merkle root calculation, and Monero block template integration. Features support for both standalone mining and P2Pool mining, RandomX algorithm integration, mempool synchronization validation, template caching with TTL, and comprehensive error handling for failed preconditions. Combines Tari blockchain templates with Monero mining data to create FinalBlockTemplateData containing both blockchain parameters, target difficulty calculation, and blockhashing blob generation. Essential component enabling Tari/Monero merge mining operations with proper template coordination and validation. |
| `cli.rs` | Command-line interface definitions for Minotari merge mining proxy application using Clap parser. Defines Cli struct with common CLI arguments integration (from minotari_app_utilities), non-interactive mode flag for automated operation, and ConfigOverrideProvider implementation for configuration property overrides. Supports network-specific configuration overrides, merge mining proxy configuration sections, and command-line parameter processing. Provides standardized CLI interface for merge mining proxy with configuration file integration and environment variable support. |
| `config.rs` | Configuration management for Minotari merge mining proxy defining all proxy settings and operational parameters. Implements MergeMiningProxyConfig with support for dynamic monero.fail URL discovery, Monero daemon connection settings (URL, authentication), base node and P2Pool gRPC configuration, listener address setup, origin submission control, initial sync requirements, stealth payment settings, range proof type selection, and comprehensive proxy behavior configuration. Features network-specific defaults, TLS validation settings, authentication configuration, and extensive merge mining operational parameters. Central configuration coordination for merge mining proxy operations. |
| `error.rs` | Comprehensive error handling for Minotari merge mining proxy using thiserror for structured error management. Defines MmProxyError enum covering configuration errors, merge mining errors, network errors (URI, reqwest, tonic transport), gRPC authentication and response errors, Monero daemon communication failures, block template issues, validation errors, wallet errors, and consensus builder errors. Features detailed error messages, source error chaining, and integration with all external dependencies. Provides centralized error handling ensuring proper error propagation and user feedback across all merge mining proxy operations. |
| `lib.rs` | Core library module for Minotari merge mining proxy application providing module organization and architecture validation. Enforces 64-bit architecture requirement with deny_non_64_bit_archs macro, exports CLI interface, and organizes modules including block template data management, block template manager, configuration, error handling, Monero fail URL functionality, proxy services, and merge miner execution. Provides central entry point for merge mining proxy functionality enabling Tari/Monero merge mining operations with proper architecture constraints and module coordination. |
| `main.rs` | Main entry point for the Minotari Merge Mining Proxy application. Enables merge mining of Tari with Monero by acting as a communication gateway between XMRig, Monero daemon, Tari base node, and Tari wallet. Sets terminal title, parses CLI arguments, initializes logging, and starts the merge mining service. Includes modules for block template management, proxy configuration, error handling, Monero failure detection, and test utilities. Supports DHAT heap profiling and handles both solo and pool-based merge mining configurations with self-select mode. |
| `monero_fail.rs` | Monero public node discovery service for Minotari merge mining proxy implementing automatic Monero daemon selection from monero.fail website. Defines MonerodEntry with comprehensive server metadata (address type, URL, height, availability status, response time, uptime history), get_monerod_info function for HTML scraping with table structure validation, server availability testing with connection timeouts, filtering logic (exclude tor/i2p, require full uptime history), height-based sorting for optimal node selection, and order_and_select_monerod_info for response time optimization. Features robust HTML parsing with CSS selectors, comprehensive error handling, extensive test coverage for different networks (mainnet/stagenet/testnet), server qualification with concurrent testing, and deduplication logic. Essential for reliable Monero daemon connectivity ensuring optimal merge mining performance through automated server discovery and qualification with fallback mechanisms. |
| `run_merge_miner.rs` | Main execution function for Minotari merge mining proxy orchestrating complete service startup and configuration. Implements start_merge_miner function with configuration loading, dynamic Monero daemon discovery using monero.fail API, fallback server validation, gRPC client connections (base node and P2Pool), service verification, HTTP server binding, and comprehensive error handling. Features intelligent Monero server selection with response time optimization, TLS certificate management, authentication integration, wallet payment address validation, RandomX factory initialization, and hyper server setup. Includes connect_base_node and connect_sha_p2pool functions for secure gRPC connections with interceptors, TLS configuration, and message size limits. Provides get_tari_monerod_entries for trusted server bootstrap and verify_base_node_responses for mining capability validation. Essential startup orchestration enabling merge mining operations between Tari base node, Monero daemon, and external mining clients with robust connectivity and fallback mechanisms. |
| `test.rs` | Unit tests for merge mining proxy utilities. Tests: add_aux_data functionality including data addition, merging to existing aux data, and error response handling; append_aux_chain_data functionality including chain object addition. Dependencies: serde_json, crate::common::json_rpc, crate::proxy::utils. Test approach: unit tests validating JSON RPC response manipulation and auxiliary data handling for merge mining operations. |

###### applications/minotari_merge_mining_proxy/src/common/

| File | Description |
|------|-------------|
| `json_rpc.rs` | JSON-RPC response utilities for Minotari merge mining proxy providing standardized response formatting for XMRig and Monero daemon communication. Implements default_block_accept_response for successful block submissions (XMRig-compatible format with status OK), success_response for general JSON-RPC 2.0 success responses, standard_error_response for predefined jsonrpc::StandardError types, and error_response for custom error responses with flexible error codes, messages, and data. Features proper JSON-RPC 2.0 specification compliance, request ID handling with fallback to -1, optional error data inclusion, comprehensive test coverage validating response structure and content, and XMRig compatibility for seamless mining integration. Essential for maintaining protocol compliance in merge mining proxy communication between miners, pools, and blockchain daemons. |
| `merge_mining.rs` | Coinbase transaction integration utility for Minotari merge mining proxy enabling coinbase addition to block templates. Implements add_coinbase function that takes generated coinbase output and kernel from wallet operations and integrates them into gRPC NewBlockTemplate for mining. Performs bidirectional conversion between gRPC protobuf format and internal Tari NewBlockTemplate structures, adds coinbase components to block body (outputs and kernels), and handles conversion errors with detailed error propagation. Essential utility for merge mining workflow ensuring proper coinbase transaction inclusion in dual mining operations with Monero, enabling miners to receive rewards from both blockchains simultaneously. |
| `mod.rs` | Common utilities module aggregation for Minotari merge mining proxy organizing shared functionality across the proxy application. Exports json_rpc module for JSON-RPC response formatting, merge_mining module for coinbase integration utilities, monero_rpc module for Monero daemon communication, and proxy module for core proxy functionality. Provides centralized access to all common utilities required for merge mining operations including protocol communication, transaction processing, and proxy coordination between Tari base node, Monero daemon, and mining clients. |
| `monero_rpc.rs` | Monero RPC error code definitions and utilities for Minotari merge mining proxy providing comprehensive error handling for Monero daemon communication. Defines CoreRpcErrorCode enum with all standard Monero daemon error codes from the official repository including parameter errors (-1 to -4), internal errors (-5), block processing errors (-6, -7, -10), operational errors (-9, -11 to -19), and payment-related errors. Features as_i32() conversion method and Into<i32> trait implementation for seamless integration with JSON-RPC error responses. Includes comprehensive test coverage for error code conversion. Essential for proper error handling and communication between merge mining proxy and Monero daemon with standard-compliant error reporting. |
| `proxy.rs` | HTTP response conversion utilities for Minotari merge mining proxy providing standardized response formatting and body handling. Implements convert_json_to_hyper_json_response for JSON response creation with proper headers, json_response for building JSON responses with status codes and headers, into_response for converting response parts and JSON content, into_body_from_response for converting JSON responses to Body responses, and read_body_until_end for streaming body data collection. Features automatic content-type and content-length header management, HTTP/1.1 version setting, comprehensive error handling, and extensive test coverage validating response structure, headers, and body content. Essential for HTTP protocol compliance and response coordination in merge mining proxy operations between clients and upstream services. |

###### applications/minotari_merge_mining_proxy/src/proxy/

| File | Description |
|------|-------------|
| `inner.rs` | Core merge mining proxy service implementation for Minotari providing comprehensive dual-blockchain mining coordination between Tari base node, Monero daemon, and mining clients. Implements InnerService with intelligent Monero daemon failover, block template management, transaction submission handling, and header synchronization. Features handle_get_height for combined height reporting (Monero + Tari + P2Pool), handle_submit_block for dual chain block submission with difficulty validation, handle_get_block_template for merged mining template creation with auxiliary chain integration, server availability management with round-robin failover and connection testing, comprehensive error handling with automatic server switching, and extensive logging with trace ID tracking. Includes RandomX factory integration, consensus manager coordination, wallet payment address management, and P2Pool optional integration. Essential core component enabling seamless merge mining operations with robust error handling and automatic failover mechanisms ensuring continuous mining availability. |
| `mod.rs` | Proxy module aggregation for Minotari merge mining proxy organizing core proxy functionality and service components. Exports inner module containing InnerService implementation for core merge mining logic, monerod_method module for Monero daemon method handling, service module for proxy service coordination, and utils module for proxy utility functions. Provides centralized organization of all proxy-related functionality enabling merge mining operations between Tari base node, Monero daemon, and mining clients with proper separation of concerns and modular architecture. |
| `monerod_method.rs` | Monero daemon RPC method parsing and identification for merge mining proxy implementing comprehensive method recognition and request processing. Defines MonerodMethod enum covering all standard Monero RPC calls (GetHeight, GetVersion, GetBlockTemplate, SubmitBlock, GetBlockHeaderByHash, GetLastBlockHeader, GetBlock), implements FromStr trait with method name variations and URL path support, provides Display trait for method string representation, and parse_monerod_rpc_method function for HTTP request analysis. Features GET request URL path parsing, POST request JSON-RPC method extraction, comprehensive error handling with logging, and robust method detection supporting both REST and JSON-RPC Monero daemon interfaces. Essential for routing and processing Monero daemon communications in merge mining operations. |
| `service.rs` | HTTP service implementation for Minotari merge mining proxy providing tower-service integration for handling mining requests. Implements MergeMiningProxyService wrapping InnerService with comprehensive request/response processing, asynchronous request handling using hyper Body streams, JSON-RPC method parsing for Monero daemon compatibility, and robust error handling with structured JSON-RPC responses. Features configuration management, consensus manager integration, RandomX factory coordination, wallet payment address handling, and comprehensive logging with trace IDs. Provides Service trait implementation for tower-service integration with poll_ready functionality, async request body reading, method identification and routing, and standardized error response formatting. Essential HTTP service layer enabling external mining clients to interact with merge mining proxy through standard HTTP/JSON-RPC protocols. |
| `utils.rs` | Merge mining proxy utility functions for request/response handling and data conversion. Exports: convert_reqwest_response_to_hyper_json_response(), add_aux_data(), append_aux_chain_data(), try_into_json_block_header(), request_bytes_to_value(). Dependencies: hyper, reqwest, serde_json, tari_rpc, tari_utilities. Used by: merge mining proxy server components. Handles JSON RPC response formatting, auxiliary data injection for merge mining chains, and conversion between different HTTP/RPC formats. Contains MMPROXY_AUX_KEY_NAME constant for merge mining extensions. |

##### applications/minotari_merge_mining_proxy/windows/

| File | Description |
|------|-------------|
| `start_minotari_merge_mining_proxy.lnk` | Windows shortcut file (.lnk) for launching the Minotari merge mining proxy. Links to start_minotari_merge_mining_proxy.bat script. Binary Windows file for desktop/start menu integration. Used by: Windows installation package. |
| `start_xmrig.lnk` | Windows shortcut file (.lnk) for launching XMRig mining software. Links to start_xmrig.bat script. Binary Windows file for desktop/start menu integration. Used by: Windows installation package for merge mining setup. |

###### applications/minotari_merge_mining_proxy/windows/runtime/

| File | Description |
|------|-------------|
| `source_merge_mining_proxy_env.bat` | Windows environment setup script for merge mining proxy. Validates base_path and my_exe environment variables, locates merge mining proxy executable in multiple paths (exe_path, base_path, system PATH), then launches proxy with --base-path argument. Dependencies: merge mining proxy executable. Used by: Windows start scripts for merge mining proxy initialization and execution. |
| `source_xmrig_env.bat` | Windows batch script that sources XMRig environment variables and launches XMRig. Validates xmrig_config_path and my_exe environment variables. Finds XMRig executable in TARI_XMRIG_DIR. Copies mainnet config file to XMRig directory. Dependencies: Windows runtime environment. Used by: start_xmrig.bat. |
| `start_minotari_merge_mining_proxy.bat` | Windows batch script to start the Minotari merge mining proxy. Sets executable name to minotari_merge_mining_proxy.exe, configures paths, and calls source_merge_mining_proxy_env.bat to launch the proxy. Dependencies: Windows runtime environment. Entry point for Windows merge mining proxy startup. |
| `start_xmrig.bat` | Windows batch script to start XMRig mining software for merge mining. Sets up environment variables including XMRig executable name (xmrig.exe), config path, and executable path. Calls source_xmrig_env.bat to launch XMRig. Dependencies: Windows runtime, XMRig installation. Entry point for Windows XMRig startup. |

#### applications/minotari_miner/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for minotari_miner application providing standalone Tari mining functionality. Dependencies include Tari core libraries (tari_core, tari_common, tari_common_types), gRPC integration (minotari_app_grpc), mining utilities (minotari_app_utilities with miner_input features), networking libraries (tonic with TLS support, native-tls), cross-platform utilities (crossbeam, crossterm), serialization (borsh, serde, base64), logging (log4rs with file rotation), and async runtime (tokio). Features comprehensive mining configuration with gRPC connectivity, TLS security, multi-threaded operations, and extensive logging capabilities. Core Tari mining application for standalone SHA3 mining operations. |
| `README.md` | Documentation for Minotari standalone miner application providing SHA3 mining functionality for the Tari network. Covers installation procedures, configuration options including base node gRPC connectivity, mining thread configuration, tip-only mining, proof-of-work algorithm selection, mining pool integration with Stratum protocol, wallet payment addresses, and network settings. Details comprehensive configuration parameters for standalone and pool mining scenarios, timeout settings, coinbase data customization, and mining validation. Includes caveats about current SHA3-only support and references to main project documentation for setup procedures. |
| `build.rs` | Build script for Minotari standalone miner application providing platform-specific compilation configuration. On Windows, implements icon resource linking by locating icon.res file in current directory and adding rustc-link-arg for resource embedding in the executable. Includes rerun-if-changed directive for icon.res to trigger rebuilds when icon changes. On non-Windows platforms, performs standard build process without additional resource linking. Ensures proper application branding with icon resources while maintaining cross-platform build compatibility for the standalone miner application. |
| `icon.rc` | [GENERATED] Windows resource file defining icon for minotari_miner executable. Contains resource declaration linking to icon.ico file. Used by: Windows build process to embed application icon into minotari_miner.exe executable. |
| `icon.res` | [GENERATED] Windows resource file containing application icon data for the Minotari miner executable. Binary resource data (279KB) used during Windows build process to embed icon into the application. |
| `log4rs_sample.yml` | Comprehensive log4rs configuration template for Minotari standalone miner providing multi-destination logging with rotation and filtering. Configures appenders for stdout (INFO+ levels with simplified timestamp and level format) and miner rolling file (all levels with detailed format including timestamps, targets, thread IDs, 10MB rotation with 5 file retention). Features 30-second refresh rate, threshold filters, compound rolling policy with size triggers and fixed window rotation, hierarchical logger configuration for minotari::application, minotari::miner, and minotari_miner with debug-level logging. Includes template substitution for log_dir variable and additive flag controls. Essential for production miner logging and debugging with proper log management and performance optimization. |

###### applications/minotari_miner/linux/runtime/

| File | Description |
|------|-------------|
| `start_minotari_miner.sh` | Linux startup script for Minotari miner. Initializes base path, config path, exe path variables. Starts Tor service via start_tor.sh. Creates or uses existing log4rs_miner.yml config. Spawns miner in new gnome-terminal with config and logging parameters. Dependencies: Tor, gnome-terminal. Entry point for Linux miner startup. |

###### applications/minotari_miner/osx/runtime/

| File | Description |
|------|-------------|
| `start_minotari_miner.sh` | macOS startup script for Minotari miner. Checks if Tor is running on port 9050, starts Tor in new terminal if needed. Creates or uses existing log4rs_miner.yml config. Generates miner command script and spawns in new Terminal.app. Dependencies: Tor, macOS Terminal. Entry point for macOS miner startup. |

##### applications/minotari_miner/src/

| File | Description |
|------|-------------|
| `cli.rs` | Command-line interface definitions for Minotari standalone miner application using Clap parser for comprehensive argument processing. Defines Cli struct with common CLI arguments integration, mining-specific parameters including mine-until-height, miner-max-blocks, minimum/maximum difficulty constraints, and non-interactive mode support. Implements ConfigOverrideProvider for hierarchical configuration management with network-specific overrides, command-line parameter precedence, and configuration property replacement logic. Features environment variable support (TARI_NON_INTERACTIVE), mining constraint controls, and proper configuration merging with file-based settings. Essential for miner application configuration enabling flexible mining parameters and operational modes. |
| `config.rs` | Configuration management for Minotari standalone miner providing comprehensive mining settings and operational parameters. Defines MinerConfig with base node gRPC connectivity (address, authentication, TLS), mining thread configuration, tip-only mining control, proof-of-work algorithm selection, validation timeout settings, Stratum protocol support (pool address, wallet address, worker name), coinbase extra data, network selection, error timeout handling, wallet payment addresses, and range proof type configuration. Features integration with common configuration system, SubConfigPath implementation, and comprehensive mining operational parameters for both standalone and pool mining scenarios. |
| `difficulty.rs` | Mining difficulty calculation and block header management for Minotari standalone miner supporting SHA3 and RandomX proof-of-work algorithms. Implements BlockHeaderSha3 struct with header manipulation (timestamp forwarding, nonce randomization, nonce incrementing), difficulty calculation for both SHA3 (sha3x_difficulty) and RandomX (tari_randomx_difficulty) algorithms, RandomXFactory integration for Monero compatibility, hash counter tracking for performance metrics, and gRPC protocol conversion utilities. Features comprehensive testing suite validating nonce and timestamp difficulty calculations against core implementations, proper error handling for missing RandomX factory, and conversion between internal BlockHeader and gRPC BlockHeader formats. Essential for mining operations providing accurate difficulty assessment and proof-of-work validation for dual algorithm mining support. |
| `errors.rs` | Comprehensive error handling definitions for Minotari standalone miner using thiserror for structured error management. Defines MinerError enum covering I/O errors, gRPC communication failures (status, connection, transport), mining-specific errors (NodeNotReady, MineUntilHeightReached, MinerLostBlock), data validation errors (EmptyObject, BlockHeader, Conversion), authentication errors (BasicAuthError, InvalidUri), TLS connection issues, coinbase generation errors, consensus errors, and proof-of-work specific errors (RandomXFactoryNotSet, MergeMineError, DifficultyError). Includes automatic error conversion from underlying dependencies and helper function err_empty for empty object validation. Essential error infrastructure providing comprehensive error categorization and user-friendly error messages for all mining operations and base node communications. |
| `lib.rs` | Minotari miner library entry point and main API. Exports: Cli, run_miner() async function. Dependencies: cli, run_miner, config, difficulty, errors, miner, stratum modules, tari_common. Includes architecture check for 64-bit systems only. Main entry point for the Minotari mining application, coordinating CLI parsing and miner execution. Used by: minotari_miner binary executable. |
| `main.rs` | Main entry point for the Minotari Miner application. Sets terminal title, parses CLI arguments, initializes logging with miner-specific configuration, and starts the mining process. Includes modules for CLI parsing, configuration management, difficulty calculations, error handling, core miner logic, miner runner, and Stratum protocol support. Uses async tokio runtime for mining operations and provides comprehensive error handling with exit codes. |
| `miner.rs` | Core mining engine for Minotari standalone miner implementing multi-threaded SHA3 and RandomX mining with async stream interface. Implements Miner struct with configurable thread pool, MiningReport for statistics tracking, and mining_task for proof-of-work calculation. Features include: thread spawning with custom stack size (320KB), nonce iteration with difficulty validation, dual algorithm support (SHA3/RandomX), reporting frequency optimization (300 RX, 3M SHA3 hashes), share mode for pool mining, and async communication using channels and wakers. Provides Stream trait implementation for non-blocking mining report collection, automatic thread lifecycle management, and comprehensive error handling. Essential component for Tari cryptocurrency mining operations with performance optimization and multi-algorithm flexibility. |
| `run_miner.rs` | Core miner execution logic handling mining cycles, block template retrieval, and mining operations. Exports: start_miner(), NodeClientResult, display_report(). Dependencies: minotari_app_grpc, minotari_app_utilities, tari_common, tari_core, tokio, tonic. Supports both direct base node mining and stratum pool mining. Handles connection management, block template requests, proof-of-work mining, block submission, and mining statistics reporting. Includes validation, difficulty checks, and reconnection logic for robust mining operations. |

###### applications/minotari_miner/src/stratum/

| File | Description |
|------|-------------|
| `controller.rs` | Stratum mining protocol client controller for pool mining operations. Exports: Controller struct with connection management and message handling. Dependencies: stratum error/types/stream modules, log, std mpsc channels. Handles stratum server communication, login/authentication, job template requests, solution submission, keepalive messages, and automatic reconnection. Implements JSON-RPC protocol for stratum mining including job notifications, submit responses, and error handling. Used by: stratum mining mode in run_miner. |
| `error.rs` | Error types for stratum mining protocol operations. Exports: Error enum with variants for connection, request, JSON parsing, hex parsing, time, I/O, TLS, TCP, and general errors. Dependencies: thiserror, serde_json, hex, native_tls, tari_max_size. Includes conversion implementations for various standard error types including PoisonError, SendError, and HandshakeError. Used by: stratum controller and communication modules. |
| `mod.rs` | Stratum protocol module declarations for pool mining. Exports: controller, error, stratum_controller, stratum_types, stream modules. Organizes stratum mining protocol implementation including client communication, data types, error handling, and network stream management. Used by: miner application for pool mining functionality. |
| `stream.rs` | Network stream abstraction for stratum protocol supporting both plain TCP and TLS connections. Exports: Stream enum with TcpStream and TlsStream variants. Dependencies: bufstream, native_tls, std::net. Implements unified Read, Write, BufRead interfaces for both connection types, handles TLS negotiation with hostname extraction, non-blocking I/O setup, and provides transparent stream operations for stratum controller communication. Used by: stratum controller for pool server connections. |

###### applications/minotari_miner/src/stratum/stratum_controller/

| File | Description |
|------|-------------|
| `controller.rs` | Core Stratum mining controller for Minotari miner. Exports: Controller struct. Manages mining jobs, difficulty targets, block headers, and communication with mining pool. Handles job updates, solution submission, keep-alive messages. Dependencies: mpsc channels, Miner, BlockHeader types. Used by: stratum mining implementation. |
| `mod.rs` | Module declaration for Stratum controller functionality. Exports: controller module. Simple module wrapper for controller.rs. Dependencies: None. Used by: stratum mining implementation to access Controller struct. |

###### applications/minotari_miner/src/stratum/stratum_types/

| File | Description |
|------|-------------|
| `client_message.rs` | Stratum client message types for communication between miner and stratum controller. Exports: ClientMessage enum with FoundSolution(job_id, hash, nonce), KeepAlive, Shutdown variants. Dependencies: serde. Used by: stratum controller for receiving mining results, keepalive signals, and shutdown commands from mining workers. |
| `job.rs` | Stratum job data structure for mining operations. Exports: Job struct with job_id, block, target, height fields. Serializable/deserializable for network communication. Dependencies: serde, tari_core::blocks::Block. Used by: Stratum mining protocol implementation. |
| `job_params.rs` | Stratum job parameters data structure for mining work assignments. Exports: JobParams struct with job_id, blob, target, height fields. Dependencies: serde. Used by: stratum protocol for transmitting mining jobs from pool to miners, contains block template data and difficulty targets. |
| `login_params.rs` | Stratum login parameters for pool authentication. Exports: LoginParams struct with login, pass (debug-ignored), agent fields. Dependencies: derivative, serde. Used by: stratum controller for pool login authentication, includes password field that is excluded from debug output for security. |
| `login_response.rs` | Stratum login response from mining pool servers. Exports: LoginResponse struct with id (worker identifier) and job (initial mining job) fields. Dependencies: serde, JobParams. Used by: stratum controller for handling successful login responses from pool servers, contains assigned worker ID and initial job assignment for immediate mining. |
| `miner_message.rs` | Miner message types for internal mining communication. Exports: MinerMessage enum with ReceivedJob(height, id, difficulty, header_blob), ResumeJob, StopJob, Shutdown variants. Dependencies: serde. Used by: mining threads and stratum controller for job management, mining control, and worker coordination. |
| `mod.rs` | Stratum protocol data type module declarations. Exports: client_message, job, job_params, login_params, login_response, miner_message, rpc_error, rpc_request, rpc_response, submit_params, submit_response, worker_identifier modules. Defines JSON-RPC data structures for stratum mining protocol communication between miner and pool servers. Used by: stratum controller and messaging components. |
| `rpc_error.rs` | JSON-RPC error structure for stratum protocol error reporting. Exports: RpcError struct with code (i32) and message (String) fields. Dependencies: serde. Used by: stratum protocol components for standardized error reporting including authorization failures, job template issues, and submission rejections. Implements Clone for error propagation. |
| `rpc_request.rs` | JSON-RPC request structure for stratum protocol communication. Exports: RpcRequest struct with id, jsonrpc, method, params fields. Dependencies: serde, serde_json::Value. Used by: stratum controller for building JSON-RPC requests to mining pools including login, job requests, and solution submissions. |
| `rpc_response.rs` | JSON-RPC response structure for stratum protocol communication. Exports: RpcResponse struct with id, result, error fields. Dependencies: serde, serde_json::Value, RpcError. Used by: stratum controller for parsing pool server responses including successful results and error conditions in JSON-RPC format. |
| `submit_params.rs` | Stratum submit parameters for solution submission to mining pools. Exports: SubmitParams struct with id, job_id, nonce, hash fields. Dependencies: serde. Used by: stratum controller for submitting mining solutions to pool servers, contains proof-of-work solution data including worker ID, job reference, nonce value, and computed hash. |
| `submit_response.rs` | Stratum response for mining solution submissions to pool servers. Exports: SubmitResponse struct with optional status and error fields. Dependencies: serde, RpcError. Used by: stratum controller for processing pool server responses to share submissions, indicates acceptance/rejection status and provides error details for rejected shares. |
| `worker_identifier.rs` | Stratum worker identifier for mining pool job requests. Exports: WorkerIdentifier struct with id field. Dependencies: serde. Used by: stratum controller for identifying worker sessions when requesting job templates from pool servers, maintains session state and worker tracking. |

##### applications/minotari_miner/windows/

| File | Description |
|------|-------------|
| `start_minotari_miner.lnk` | Windows shortcut file (.lnk) for launching the Minotari miner application. Links to startup batch script. Binary Windows file for desktop/start menu integration. Used by: Windows installation package. |

###### applications/minotari_miner/windows/runtime/

| File | Description |
|------|-------------|
| `source_miner_env.bat` | Windows batch script for setting up Minotari miner environment. Validates required environment variables (base_path, my_exe), locates miner executable in various paths (my_exe_path, base_path, system PATH), and launches the miner with appropriate base path configuration. Includes error handling and user feedback. |
| `start_minotari_miner.bat` | Windows batch script for starting Minotari miner. Sets up environment variables for executable paths and base directories, then calls source_miner_env.bat for additional environment configuration. Dependencies: minotari_miner.exe, source_miner_env.bat. Used by: Windows deployment and development environments for automated miner startup with proper path and environment setup. |

#### applications/minotari_node/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for minotari_node application implementing the Tari full base node. Integrates core blockchain functionality (tari_core with transactions), networking (tari_comms with RPC, tari_p2p with auto-update), storage (tari_storage), and service framework (tari_service_framework). Includes comprehensive CLI interface (clap, crossterm), interactive shell (rustyline), gRPC server (tonic), HTTP API server (axum), and monitoring capabilities (optional tari_metrics). Features embedded Tor support (libtor), console-based interface, QR code generation, and extensive logging (log4rs). Optional DHAT heap profiling and tokio-console tracing for development. Core infrastructure component maintaining Tari blockchain network integrity and providing API access. |
| `README.md` | Installation and setup documentation for Minotari Base Node application providing platform-specific installation instructions and configuration guidance. Covers macOS binary installation with executable permissions setup, Linux prerequisite installation (git, curl, build tools, OpenSSL, SQLite), and source compilation using cargo install. Documents node console commands including help, version, get-chain-metadata, list-peers, ban/unban-peer, list-connections, check-db, calc-timing, discover-peer, get-block, search operations (UTXO/kernel/STXO), mempool statistics, and node state queries. Essential user guide for base node deployment, operation, and troubleshooting with complete command reference for blockchain node management and monitoring. |
| `build.rs` | Build script for Minotari Base Node providing platform-specific compilation configuration. Uses tari_features::resolver::build_features() for feature flag resolution, includes Windows-specific icon resource linking (icon.res), and ensures proper compilation flags for different platforms. Implements conditional compilation for Windows vs non-Windows builds, providing necessary build-time configuration for the base node application across different operating systems. |
| `icon.rc` | [GENERATED] Windows resource file defining icon for minotari_node executable. Contains resource declaration linking to icon.ico file. Used by: Windows build process to embed application icon into minotari_node.exe executable. |
| `icon.res` | [GENERATED] Windows resource file containing application icon data for the Minotari base node executable. Binary resource data used during Windows build process to embed icon into the application. |
| `log4rs_sample.yml` | Sample log4rs configuration for Minotari base node with rolling file appenders. Defines multiple log destinations: console (warn+), network.log (P2P/comms), base_layer.log (application), grpc.log (gRPC), other.log (third-party), messages.log (message tracing). Includes logger routing for different components (comms, wallet, p2p, yamux, mio). Used by: base node initialization as logging configuration template. |
| `setup.sh` | macOS setup and installation script for Minotari base node. Installs XCode command line tools, Homebrew, required dependencies (pkgconfig, sqlite3, tor), downloads and extracts latest Tari binaries, starts Tor service, initializes base node configuration, and launches the node. Dependencies: curl, Homebrew ecosystem. Used by: macOS users for automated base node installation and setup from scratch. |

##### applications/minotari_node/assets/

| File | Description |
|------|-------------|
| `tari_banner.rs` | [GENERATED] ASCII art banner for Minotari Base Node application containing stylized Tari logo and branding text. Multi-line string constant with Unicode box-drawing characters, geometric patterns, and artistic text rendering displaying the Tari cryptocurrency project identity. Used for console application startup branding and visual identity. Auto-generated asset file from design assets providing consistent brand presentation across terminal interfaces and command-line applications. Part of user interface design for Minotari node applications enhancing user experience with recognizable branding elements. |
| `tari_logo.rs` | [GENERATED] ASCII art logo for Minotari Base Node application containing minimalist geometric representation of Tari cryptocurrency project branding. Multi-line string constant with Unicode block characters creating stylized logo design for console application display. Used for terminal interface branding and visual identity. Auto-generated asset file from design assets providing clean, geometric logo presentation for command-line interfaces and console-based applications. Complements tari_banner.rs with simpler logo variant suitable for compact display requirements and startup branding. |

##### applications/minotari_node/linux/

| File | Description |
|------|-------------|
| `setup_tor_service` | Linux executable script for Tor service setup and configuration. Provides automated installation and configuration of Tor service dependencies for Minotari node operation, ensuring proper network anonymization capabilities. |
| `start_all` | Linux executable script for starting all Minotari node components. Provides one-click startup of complete Minotari node infrastructure including blockchain node, network services, and supporting processes. |
| `start_minotari_node` | Linux executable symbolic link or script for starting the Minotari base node. Entry point for Linux base node startup. Links to runtime startup script. Used by: Linux installation and package management. |
| `start_tor` | Linux executable script for Tor service startup. Launches Tor daemon with appropriate configuration for Minotari node anonymous network communication, handling service dependencies and initialization. |
| `supervisord.md` | Documentation for installing and configuring Minotari base node as a Linux daemon using supervisord. Covers supervisor installation, directory structure setup, binary deployment, configuration initialization, supervisord service configuration, and daemon management commands. Includes complete supervisord.conf template for automated startup, restart, and logging. Used by: Linux system administrators for production deployments. |

###### applications/minotari_node/linux/runtime/

| File | Description |
|------|-------------|
| `linux-diag-repo.sh` | Linux diagnostic script for system information gathering. Reports kernel details (uname -a), CPU information (/proc/cpuinfo), and automatically detects Linux distribution and version using various methods (os-release, lsb_release, distribution-specific files). Determines OS name, version, and architecture for troubleshooting and system compatibility analysis. |
| `setup_tor_service.sh` | Linux shell script for configuring and setting up Tor service for Minotari node. Handles Tor service installation, configuration, and startup procedures to enable anonymous network communication for the blockchain node. |
| `start_all.sh` | Linux shell script for starting all Minotari node services simultaneously. Orchestrates the startup sequence of multiple components including the main node, Tor service, and related infrastructure services for a complete Minotari node deployment. |
| `start_minotari_node.sh` | Linux startup script for Minotari base node. Initializes paths, starts Tor service, creates base_node_id.json and log4rs_base_node.yml if missing, then spawns base node in new gnome-terminal. Dependencies: tor service, minotari_node executable. Used by: Linux deployment and development environments for automated base node startup with proper configuration initialization. |
| `start_tor.sh` | Linux shell script for starting Tor service for Minotari node. Handles Tor daemon initialization, configuration verification, and ensures proper Tor network connectivity for anonymous blockchain node communication. |

##### applications/minotari_node/osx/

| File | Description |
|------|-------------|
| `install.sh` | macOS installer script with ASCII logo and interactive setup for Minotari base node. Provides centered text display functions, platform validation, logo rendering, and installation process management. Dependencies: tput, standard bash utilities. Used by: macOS distribution packages for user-friendly installation experience with visual branding and guided setup process. |
| `osx_diag_report.sh` | macOS diagnostic script for system information collection. Similar to Linux diagnostic script but tailored for macOS-specific system information gathering, hardware detection, and troubleshooting data collection for Minotari node support. |
| `post_install.sh` | macOS post-installation script for Minotari node. Handles configuration setup, permissions, service registration, and environment preparation after initial installation on macOS systems. |
| `start_minotari_node` | macOS executable script for launching Minotari blockchain node. Provides direct startup of the main Minotari node process with macOS-specific configuration and environment setup. |
| `uninstall_pkg.sh` | macOS uninstallation script for Minotari node package. Handles complete removal of Minotari node installation including binaries, configuration files, services, and user data with proper cleanup procedures. |

##### applications/minotari_node/osx-pkg/

| File | Description |
|------|-------------|
| `ReadMe.md` | macOS package build configuration documentation with environment variables for code signing and notarization. Contains redacted credentials for Apple ID, notarization service, keychain, application certificates, and installer certificates. Used by: macOS packaging and distribution process for Minotari node PKG creation and App Store submission. |
| `build_pkg.sh` | macOS package builder script for Minotari node installer. Creates .pkg installer package with proper code signing, entitlements, and distribution configuration for macOS App Store or direct distribution. |
| `entitlements.xml` | macOS entitlements configuration file for Minotari node package. Defines security permissions and capabilities required by the application for network access, file system access, and system services on macOS. |
| `env-sample` | Sample environment configuration file for macOS Minotari node package build. Contains template environment variables and configuration options for customizing the package build process and runtime behavior. |

###### applications/minotari_node/osx-pkg/scripts/

| File | Description |
|------|-------------|
| `postinstall` | macOS installer post-installation script. Executes after package installation to configure services, set permissions, create configuration files, and perform final setup steps for Minotari node on macOS. |
| `preinstall` | macOS installer pre-installation script. Executes before package installation to check system requirements, prepare environment, and handle any necessary cleanup or prerequisite installation for Minotari node. |

###### applications/minotari_node/osx/runtime/

| File | Description |
|------|-------------|
| `start_all.sh` | macOS shell script for starting all Minotari node services. Orchestrates startup of blockchain node, Tor service, and supporting infrastructure components on macOS systems with platform-specific service management. |
| `start_minotari_node.sh` | macOS startup script for Minotari base node. Checks Tor status on port 9050, starts Tor if needed, initializes base_node_id.json and log4rs_base_node.yml, creates executable command script, then launches base node in new Terminal.app window. Dependencies: lsof, tor service, minotari_node executable. Used by: macOS deployment and development environments. Includes workaround for macOS 'open' command argument passing limitations. |
| `start_tor.sh` | macOS shell script for Tor service startup. Handles Tor daemon initialization on macOS with appropriate configuration for Minotari node anonymous network communication. |

##### applications/minotari_node/src/

| File | Description |
|------|-------------|
| `bootstrap.rs` | Base node bootstrap and service initialization orchestrating complete Tari base node infrastructure setup and service coordination. Implements BaseNodeBootstrapper with comprehensive service stack initialization including P2P networking with DHT, software updater service, base node core services, mempool management, chain metadata service, state machine coordination, and TariPulse monitoring. Features forced sync peer configuration, Tor identity management with automatic address registration, RPC service setup with wallet query support, HTTP wallet service integration, protocol extension management, and service handle coordination. Provides complete base node lifecycle management including comms spawning, transport configuration (TCP/Tor), identity persistence, and graceful service orchestration. Essential infrastructure component enabling full Tari base node functionality with proper service dependencies and communication channels. |
| `builder.rs` | Base node context builder and configuration manager. Exports: BaseNodeContext struct, configure_and_initialize_node(), build_node_context(). Dependencies: tari_common, tari_comms, tari_core blockchain/mempool/validation components, tari_p2p, tari_service_framework. Main factory for constructing the complete base node runtime including blockchain database, consensus manager, mempool, validator stack, DHT, and service handles. Provides access to all major base node components and coordinates their initialization and lifecycle management. |
| `cli.rs` | Command-line interface definition for minotari_node application. Exports: Cli struct implementing clap::Parser and ConfigOverrideProvider. Dependencies: clap, minotari_app_utilities::CommonCliArgs, tari_common::configuration. Defines CLI arguments for initialization, database rebuild, interactive mode, profiling, gRPC/mining enablement, splash screen control, and libtor configuration. Implements configuration override logic to translate CLI flags into runtime configuration properties. |
| `config.rs` | Configuration management for Minotari base node application. Exports: ApplicationConfig, BaseNodeConfig structs with network, gRPC, mining, mempool, blockchain database, and P2P configuration options. Dependencies: config, serde, tari_common configuration system, tari_core, tari_p2p. Handles configuration loading, validation, path resolution, and provides typed access to all base node settings including LMDB database config, state machine config, and optional metrics configuration. |
| `grpc_method.rs` | gRPC method definitions and routing for Minotari node. Defines available gRPC service methods, method signatures, and routing logic for incoming gRPC requests. Provides the interface between gRPC transport and service implementations. |
| `lib.rs` | Core library for Minotari base node application. Exports: run_base_node(), run_base_node_with_cli(), ApplicationConfig, BaseNodeConfig types. Main entry points for starting base node with CLI, gRPC server, metrics, recovery mode. Dependencies: tari_core, tari_comms, gRPC, tokio. Used by: main.rs executable. |
| `main.rs` | Main entry point for the Minotari Base Node application. Implements command-line interface with Clap parser, initializes logging, loads configuration, sets up node identity with peer features, and optionally configures embedded Tor (libtor) on Unix systems. Handles panic logging to minotari-node-panic.log file. Provides comprehensive help documentation for base node commands including get-chain-metadata, list-peers, ban/unban-peer, mining operations, and blockchain querying. Supports runtime profiling with tokio-console and optional DHAT heap profiling. Uses tokio async runtime and graceful shutdown handling. |
| `metrics.rs` | Metrics collection and reporting system for Minotari base node. Exports: install(), MetricsConfig struct. Sets up Prometheus metrics registry with node identity labels, optional scrape server and push gateway. Dependencies: tari_metrics, serde. Used by: lib.rs main initialization. |
| `recovery.rs` | Database recovery functionality for corrupted or damaged blockchain data. Exports: initiate_recover_db(), run_recovery() functions. Creates recovery LMDB database, validates and transfers blocks from backup to main database. Dependencies: tari_core chain_storage, LMDB backend. Used by: lib.rs when --rebuild-db flag is set. |
| `table.rs` | ASCII table rendering utility for formatted output display. Exports: Table struct, row! macro. Supports titles, separators, row counting, column width auto-sizing. Used for CLI command output formatting. Dependencies: std::io. Used by: various CLI commands for tabular data display. |
| `utils.rs` | Utility functions for Minotari base node application. Exports: format_duration_basic() function. Formats Duration objects into human-readable strings with hours, minutes, seconds. Dependencies: std::time::Duration. Used by: various components for time display formatting. |

###### applications/minotari_node/src/commands/

| File | Description |
|------|-------------|
| `cli.rs` | CLI interface banner and command display utilities for base node. Exports: print_banner() function. Dependencies: chrono, crossterm, minotari_app_utilities::consts. Handles terminal title setting, ASCII art banner display, logo rendering, copyright information, version display, and tabular command listing with box drawing characters. Includes helper functions for text formatting, centering, and table layout. Used by: base node CLI interface initialization. |
| `cli_loop.rs` | Interactive CLI event loop and command processing for base node. Exports: CliLoop struct with interactive/non-interactive modes, watch command support, and shutdown handling. Dependencies: crossterm, futures, rustyline, tari_shutdown, tokio. Handles terminal input events, keyboard shortcuts (Ctrl+C, Ctrl+L), command parsing, watch mode for status monitoring, and graceful shutdown. Supports both banner display and headless operation modes. |
| `mod.rs` | Module declarations for Minotari node command system. Exports: cli, cli_loop, command, nom_parser, parser, reader, status_line modules. Root module for CLI command infrastructure. Dependencies: None. Used by: main application to access command functionality. |
| `nom_parser.rs` | Command parser implementation using nom parser combinator library. Provides parsing functionality for Minotari node CLI commands, handling command syntax, arguments, and validation. Used by the CLI command system for input processing. |
| `parser.rs` | Main command parser module for Minotari node CLI. Coordinates command parsing, routing, and execution. Integrates with nom_parser and provides the interface between user input and command implementations. |
| `reader.rs` | Command line input reader for Minotari node CLI interface. Handles user input, command history, and interactive command line functionality. Provides readline capabilities and input validation for the CLI system. |
| `status_line.rs` | Status line display manager for Minotari node CLI. Provides real-time status information display including node state, sync progress, and system metrics in the CLI interface. Handles status formatting and updates. |

###### applications/minotari_node/src/commands/command/

| File | Description |
|------|-------------|
| `add_peer.rs` | Command implementation for adding peers to the Minotari base node. Exports: ArgsAddPeer struct, HandleCommand trait implementation. Validates peer public key, creates Peer object, adds to peer manager, and initiates connection. Dependencies: clap, tari_comms, peer management. Used by: CLI command system. |
| `ban_peer.rs` | Command implementations for banning and unbanning peers in Minotari base node. Exports: ArgsBan, ArgsUnban structs, HandleCommand implementations. Supports duration-based banning, prevents self-banning. Dependencies: clap, tari_comms connectivity. Used by: CLI command system for peer management. |
| `block_timing.rs` | Minotari node CLI command for blockchain timing analysis. Calculates maximum, minimum, and average time taken to mine blocks within a specified range. Exports Args struct and HandleCommand implementation for CommandContext. Uses BlockHeader::timing_stats() for statistical calculations. |
| `check_db.rs` | Minotari node CLI command for blockchain database integrity checking. Verifies blockchain database for missing blocks and headers by iterating through block heights and checking for gaps. Exports Args struct and HandleCommand implementation. Provides detailed reporting of database consistency issues. |
| `check_for_updates.rs` | Minotari node CLI command for checking software updates. Connects to update servers or repositories to check for newer versions of Minotari node software. Exports Args struct and HandleCommand implementation for version checking and update notifications. |
| `create_tls_certs.rs` | Minotari node CLI command for TLS certificate generation. Creates TLS certificates for secure communication between node components and external clients. Exports Args struct and HandleCommand implementation. Handles certificate generation, validation, and storage. |
| `dial_peer.rs` | Minotari node CLI command for manually connecting to network peers. Initiates direct connection to specified peer addresses for network testing and debugging. Exports Args struct and HandleCommand implementation. Handles peer connection establishment and error reporting. |
| `discover_peer.rs` | Minotari node CLI command for peer discovery functionality. Searches for and discovers new peers in the Tari network using various discovery mechanisms. Exports Args struct and HandleCommand implementation. Provides network peer discovery and connection testing. |
| `get_block.rs` | CLI command for retrieving and displaying blockchain blocks by height or hash. Exports: Args struct, HandleCommand implementation. Dependencies: anyhow, async_trait, clap, tari_common_types, tari_utilities. Supports both text and JSON output formats, includes orphan block lookup, and provides detailed block and accumulated data display. Used by: base node CLI for block inspection and debugging. |
| `get_chain_metadata.rs` | Minotari node CLI command for retrieving blockchain metadata. Displays current blockchain state information including best block height, accumulated difficulty, and chain statistics. Exports Args struct and HandleCommand implementation using node service metadata APIs. |
| `get_db_stats.rs` | Minotari node CLI command for database statistics reporting. Retrieves and displays blockchain database statistics including size, performance metrics, and storage utilization. Exports Args struct and HandleCommand implementation for database monitoring and optimization. |
| `get_mempool_state.rs` | Minotari node CLI command for retrieving mempool state information. Displays current mempool contents, transaction counts, and pending transaction details. Exports Args struct and HandleCommand implementation using mempool service APIs for transaction pool monitoring. |
| `get_mempool_stats.rs` | Minotari node CLI command for mempool statistics retrieval. Displays statistical information about the transaction mempool including size, throughput, and performance metrics. Exports Args struct and HandleCommand implementation using mempool service statistics APIs. |
| `get_network_stats.rs` | Minotari node CLI command for network statistics reporting. Displays network connectivity metrics, peer counts, bandwidth usage, and communication statistics. Exports Args struct and HandleCommand implementation for network monitoring and diagnostics. |
| `get_peer.rs` | Minotari node CLI command for retrieving peer information. Displays detailed information about specific network peers including connection status, address, and peer metadata. Exports Args struct and HandleCommand implementation for peer inspection and debugging. |
| `get_state_info.rs` | Minotari node CLI command for retrieving node state information. Displays comprehensive node state including sync status, blockchain height, and operational status. Exports Args struct and HandleCommand implementation for node status monitoring. |
| `header_stats.rs` | Minotari node CLI command for blockchain header statistics analysis. Calculates and displays statistical information about block headers including difficulty trends, timing patterns, and header validation metrics. Exports Args struct and HandleCommand implementation. |
| `list_bad_blocks.rs` | Minotari node CLI command for listing invalid blocks. Displays blocks that failed validation or were rejected by the blockchain consensus mechanism. Exports Args struct and HandleCommand implementation for blockchain debugging and forensic analysis. |
| `list_banned_peers.rs` | Minotari node CLI command for listing banned network peers. Displays peers that have been blacklisted due to malicious behavior or protocol violations. Exports Args struct and HandleCommand implementation for network security monitoring. |
| `list_connections.rs` | Minotari node CLI command for listing active network connections. Displays current peer connections including connection status, protocol versions, and communication metrics. Exports Args struct and HandleCommand implementation for network connectivity monitoring. |
| `list_headers.rs` | Minotari node CLI command for listing blockchain headers. Displays block headers within specified ranges including height, hash, timestamp, and difficulty information. Exports Args struct and HandleCommand implementation for blockchain inspection. |
| `list_peers.rs` | Minotari node CLI command for listing known network peers. Displays comprehensive peer information including addresses, connection status, protocol capabilities, and peer reputation. Exports Args struct and HandleCommand implementation for network topology analysis. |
| `list_reorgs.rs` | Minotari node CLI command for listing blockchain reorganizations. Displays historical blockchain reorganization events including affected blocks, reorganization depth, and timing information. Exports Args struct and HandleCommand implementation for blockchain stability analysis. |
| `list_validator_nodes.rs` | Minotari node CLI command for listing validator nodes. Displays active validator nodes in the network including their addresses, status, and validation capabilities. Exports Args struct and HandleCommand implementation for validator network monitoring. |
| `mod.rs` | Command framework and router for base node CLI operations. Exports: Args, Command enum, HandleCommand trait, CommandContext, TypeOrHex. Dependencies: clap, async_trait, tari_comms, tari_core components, tari_p2p. Defines all available CLI commands (status, get_block, add_peer, etc.), command parsing, execution routing, timeout handling, and provides unified interface to blockchain, network, mempool, and state machine services. Central dispatch system for all base node operations. |
| `period_stats.rs` | Minotari node CLI command for period-based statistics analysis. Calculates and displays blockchain statistics over specified time periods including block production rates, difficulty adjustments, and network performance metrics. Exports Args struct and HandleCommand implementation. |
| `ping_peer.rs` | Minotari node CLI command for pinging network peers. Tests network connectivity and latency to specific peers for network diagnostics and connection quality assessment. Exports Args struct and HandleCommand implementation with ping response metrics. |
| `quit.rs` | Minotari node CLI command for graceful node shutdown. Triggers shutdown signal to terminate the node safely with proper cleanup and resource deallocation. Exports Args struct and HandleCommand implementation using shutdown trigger mechanism. |
| `reset_offline_peers.rs` | Minotari node CLI command for resetting offline peer status. Clears offline status flags for peers that may have recovered connectivity, allowing reconnection attempts. Exports Args struct and HandleCommand implementation for peer state management. |
| `rewind_blockchain.rs` | Minotari node CLI command for blockchain rewind operations. Reverts blockchain state to a previous block height for recovery from corruption or reorganization events. Exports Args struct and HandleCommand implementation with safety validation. |
| `search_kernel.rs` | Minotari node CLI command for searching transaction kernels. Searches blockchain for specific transaction kernels by hash or other criteria for transaction verification and debugging. Exports Args struct and HandleCommand implementation. |
| `search_utxo.rs` | Minotari node CLI command for searching unspent transaction outputs (UTXOs). Searches blockchain for specific UTXOs by hash or commitment for transaction verification and balance checking. Exports Args struct and HandleCommand implementation. |
| `status.rs` | Status command implementation for displaying node state information. Exports: Args struct, HandleCommand implementation. Shows network state, tip height, mempool stats, connections, banned peers, messages, RPC sessions, liveness status. Dependencies: clap, StatusLine. Used by: CLI command system. |
| `test_peer_liveness.rs` | Minotari node CLI command for testing peer connectivity and liveness. Performs comprehensive connectivity tests on network peers to assess their availability and responsiveness. Exports Args struct and HandleCommand implementation for network diagnostics. |
| `unban_all_peers.rs` | Minotari node CLI command for unbanning all blacklisted peers. Clears all peer bans and allows previously banned peers to reconnect to the network. Exports Args struct and HandleCommand implementation for network access management. |
| `version.rs` | Minotari node CLI command for displaying version information. Shows current software version, build information, and compatibility details for the Minotari node. Exports Args struct and HandleCommand implementation for version reporting. |
| `watch_command.rs` | Minotari node CLI command for watching and monitoring other commands. Provides real-time monitoring and repeated execution of other CLI commands for continuous system observation. Exports Args struct and HandleCommand implementation. |
| `whoami.rs` | Minotari node CLI command for displaying node identity information. Shows node ID, public key, network address, and other identifying information for the current node. Exports Args struct and HandleCommand implementation. |

###### applications/minotari_node/src/grpc/

| File | Description |
|------|-------------|
| `base_node_grpc_server.rs` | Main gRPC server implementation for base node providing blockchain and network APIs. Exports: BaseNodeGrpcServer with extensive gRPC service methods. Dependencies: minotari_app_grpc, tari_core blockchain/mempool/transactions, tari_comms, tonic. Implements mining APIs (get_new_block_template, submit_block), blockchain queries (get_blocks, get_chain_metadata), mempool operations, network statistics, transaction validation, and real-time data streaming. Includes authentication, method filtering, caching, and comprehensive error handling. Central API layer for external clients and miners. |
| `blocks.rs` | Provides helper functions and utilities for handling block-related gRPC requests and responses in support of the main `base_node_grpc_server`. Encapsulates logic for fetching blocks from the database, constructing protobuf `Block` and `HistoricalBlock` messages, and handling data conversions, thereby separating block-specific query logic from the main gRPC service implementation. |
| `data_cache.rs` | Data caching layer for gRPC services. Provides caching mechanisms for frequently accessed blockchain data to improve gRPC service performance and reduce database load. Implements cache invalidation and data consistency strategies. |
| `hash_rate.rs` | gRPC service implementation for hash rate monitoring and reporting. Provides network hash rate calculation, mining difficulty statistics, and mining performance metrics through gRPC API endpoints. |
| `helpers.rs` | Utility functions for gRPC services. Contains helper functions for statistical calculations (median, mean), data conversion, and common operations used across multiple gRPC service implementations. Exports median() and mean() functions with associated tests. |
| `mod.rs` | Module declarations for Minotari node gRPC functionality. Exports: base_node_grpc_server, blocks, data_cache, hash_rate, helpers modules. Root module for gRPC API infrastructure. Dependencies: None. Used by: main application to access gRPC server and related utilities. |

###### applications/minotari_node/src/http/

| File | Description |
|------|-------------|
| `mod.rs` | HTTP service module organization for Minotari node. Main module file organizing HTTP server components, handlers, and routing. Coordinates HTTP API structure and exports for external access to REST endpoints. |
| `server.rs` | HTTP server implementation for Minotari node REST API. Manages HTTP server lifecycle, routing configuration, middleware setup, and request handling. Provides the main HTTP service interface for external clients accessing blockchain data. |

###### applications/minotari_node/src/http/handler/

| File | Description |
|------|-------------|
| `get_header_by_height.rs` | HTTP API handler for retrieving block headers by height. Provides REST endpoint to fetch specific block headers using block height as parameter. Handles HTTP request processing, validation, and response formatting for header queries. |
| `get_height_at_time.rs` | HTTP API handler for determining block height at specific timestamps. Provides REST endpoint to find the blockchain height that was active at a given time. Handles temporal blockchain queries and time-based height calculations. |
| `get_tip_info.rs` | HTTP API handler for retrieving blockchain tip information. Provides REST endpoint to get current blockchain tip data including best block height, hash, and metadata. Handles real-time blockchain state queries. |
| `mod.rs` | HTTP handler module exports and organization. Re-exports all HTTP API handlers and provides module structure for the HTTP service layer. Coordinates handler registration and routing configuration. |

##### applications/minotari_node/windows/

| File | Description |
|------|-------------|
| `README.md` | Windows installation and runtime instructions for Minotari components. Covers automatic and manual installation procedures, pre-requisites (SQLite, Tor, Visual Studio redist, XMRig), file structure, startup shortcuts, and configuration. Documents Windows-specific setup for base node, wallet, miner, and merge mining proxy. |
| `start_all.lnk` | Windows shortcut file for starting all Minotari node services. Provides convenient desktop shortcut to launch complete Minotari node infrastructure with single click on Windows systems. |
| `start_minotari_node.lnk` | Windows shortcut file for starting Minotari blockchain node. Provides desktop shortcut to launch the main Minotari node process directly on Windows systems. Links to node startup script. |
| `start_tor.lnk` | Windows shortcut file for starting Tor service. Provides desktop shortcut to launch Tor daemon for anonymous network communication on Windows systems. Links to Tor startup script. |

###### applications/minotari_node/windows/runtime/

| File | Description |
|------|-------------|
| `source_minotari_node_env.bat` | Windows batch script for setting up Minotari node environment. Configures environment variables, validates paths, and sets up runtime configuration for Minotari node execution on Windows systems. Handles executable location and path validation. |
| `start_all.bat` | Windows batch script for starting all Minotari node services. Orchestrates startup of complete Minotari node infrastructure including blockchain node, Tor service, and supporting components on Windows platforms. |
| `start_minotari_node.bat` | Windows batch script to start the Minotari node application with proper environment configuration. Initializes and loads environment variables, locates the minotari_node.exe executable, and launches the node with configured base path parameters. Includes error handling and informative messages for missing environment variables. Dependencies: Windows runtime environment, minotari_node.exe. Used by: Windows deployment for automated node startup with environment setup. |
| `start_tor.bat` | Windows batch script for starting Tor service. Launches Tor daemon with appropriate configuration for Minotari node anonymous network communication on Windows platforms. Handles Tor service initialization and error reporting. |

### base_layer/

| File | Description |
|------|-------------|
| `README.md` | Overview documentation for the Minotari base layer blockchain components. Brief description of fundamental blockchain components. Part of the Tari Cryptocurrency project. Used by: developers understanding base layer architecture. |

#### base_layer/common_types/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for tari_common_types crate. Defines common types used throughout the Tari cryptocurrency codebase. Dependencies include crypto libraries (tari_crypto, chacha20poly1305), serialization (serde, borsh), and utility crates. Version and metadata inherited from workspace. |
| `README.md` | Documentation for tari_common_types crate. Brief description of the crate's purpose as implementation of common types throughout the Tari codebase. Part of the Tari cryptocurrency project. |

##### base_layer/common_types/src/

| File | Description |
|------|-------------|
| `burnt_proof.rs` | Cryptographic proof structure for burnt coin operations. Exports: BurntProof struct with reciprocal claim key, commitment, ownership proof, range proof fields. Used for proving coin destruction in cross-chain operations. Dependencies: tari_crypto, commitment/proof types. Used by: burn transaction validation. |
| `chain_metadata.rs` | Blockchain chain metadata structure tracking chain state. Exports: ChainMetadata struct with height, hash, pruning info, difficulty, timestamp. Methods for archival/pruned node detection, pruning height calculation. Dependencies: primitive_types, serde. Used by: blockchain database, sync protocols. |
| `dammsum.rs` | DammSum checksum implementation for data integrity verification. Provides checksum calculation and validation functions used by EmojiId and other components for error detection. Exports compute_checksum() and validate_checksum() functions with CHECKSUM_BYTES constant. |
| `emoji.rs` | Emoji ID implementation for human-readable public key representation. Converts public keys to 33-character emoji strings with checksum validation. Exports EmojiId struct with bidirectional conversion between CompressedPublicKey and emoji representation. Includes comprehensive error handling and test suite. |
| `encryption.rs` | Encryption utilities and implementations for Tari common types. Provides encryption/decryption functionality, key management, and cryptographic operations used across the Tari ecosystem. Integrates with chacha20poly1305 and other crypto libraries. |
| `epoch.rs` | Epoch management and time-based operations for Tari blockchain. Defines epoch structures, epoch transitions, and time-based consensus mechanisms. Provides functionality for epoch-based validation and blockchain time management. |
| `grpc_authentication.rs` | gRPC authentication mechanisms for Tari services. Implements authentication and authorization for gRPC endpoints including token validation, user verification, and access control. Provides security layer for external gRPC API access. |
| `key_branches.rs` | Key derivation branch definitions for hierarchical deterministic wallets. Defines key branch structures and derivation paths used in Tari wallet implementations. Integrates with minotari_ledger_wallet_common for hardware wallet support. |
| `lib.rs` | Common type definitions and utilities shared across Tari base layer components. Provides burnt proof functionality, chain metadata structures, dammsum checksums, emoji ID encoding for human-readable addresses, encryption utilities, epoch handling, gRPC authentication types, key branch definitions, payment references, serialization helpers, Tari address formats, transaction types, and wallet-specific types. Includes WALLET_COMMS_AND_SPEND_KEY_BRANCH constant for key derivation. Central location for shared data structures and type definitions used throughout the Tari ecosystem. |
| `payment_reference.rs` | Payment reference implementations for transaction identification and tracking. Provides payment reference generation, validation, and management for Tari transactions. Enables payment tracking and invoice correlation. |
| `transaction.rs` | Defines transaction metadata types including `TransactionDirection` (Inbound/Outbound), `TransactionStatus` (e.g., Mined, Pending), and the `TransactionInfo` enum for representing different transaction types. Provides utilities for handling transaction metadata consistently across the wallet and related services. Does not define the core transaction structure itself. |
| `tx_id.rs` | Defines the `TxId` type alias, representing a unique identifier for a transaction as a `u64` integer. Used consistently across the wallet and related services for referencing transactions, particularly for database indexing and API calls. |
| `wallet_types.rs` | Wallet-specific type definitions and utilities. Provides data structures and operations specifically designed for wallet implementations including balance types, transaction states, and wallet configuration structures. |

###### base_layer/common_types/src/serializers/

| File | Description |
|------|-------------|
| `base64.rs` | Base64 serialization utilities for Tari data types. Provides serde-compatible base64 encoding and decoding functions for binary data serialization in JSON and other text-based formats. Used throughout the codebase for API data exchange. |
| `hex.rs` | Hexadecimal serialization utilities for Tari data types. Provides serde-compatible hex encoding and decoding functions for binary data representation. Used for displaying hashes, keys, and other binary data in human-readable format. |
| `mod.rs` | Serialization utilities module organization. Re-exports serialization functions for base64, hex, and string formats. Provides centralized access to custom serde serializers used throughout the Tari codebase. |
| `string.rs` | String serialization utilities for Tari data types. Provides serde-compatible string conversion functions for types that need custom string representation. Handles conversion between string formats and internal data structures. |

###### base_layer/common_types/src/tari_address/

| File | Description |
|------|-------------|
| `dual_address.rs` | Dual address implementation for Tari addressing system. Provides address structures that can represent both mainnet and testnet addresses, enabling cross-network compatibility and address validation for different Tari network types. |
| `mod.rs` | Tari address system module organization. Exports address types including single addresses and dual addresses. Provides the main interface for Tari address creation, validation, and manipulation across the network. |
| `single_address.rs` | Single address implementation for Tari network. Provides standard address structures for individual network addresses (mainnet or testnet). Handles address generation, validation, and encoding for single-network use cases. |

###### base_layer/common_types/src/types/

| File | Description |
|------|-------------|
| `bullet_rangeproofs.rs` | Bulletproof range proof implementations for zero-knowledge proofs. Provides range proof generation, verification, and aggregation for confidential transactions. Essential component for privacy-preserving transactions in Tari. |
| `fixed_hash.rs` | Fixed-size hash type implementations for blockchain operations. Provides fixed-length hash structures with validation, serialization, and comparison operations. Used for block hashes, transaction hashes, and other cryptographic identifiers. |
| `mod.rs` | Common types module organization for Tari base layer. Re-exports type definitions including CompressedPublicKey, UncompressedPublicKey, PrivateKey, and other fundamental types. Provides centralized access to core Tari data structures. |

#### base_layer/contacts/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for contacts management crate. Defines dependencies and configuration for contact management functionality in Tari, likely used for address book and peer contact organization. |
| `build.rs` | Build script for contacts crate. Handles compilation-time code generation, environment variable processing, or other build-time tasks specific to the contacts management functionality. |
| `diesel.toml` | Diesel CLI configuration file for the contacts service database schema generation. Specifies that the generated schema should be written to src/schema.rs file. Used by Diesel ORM for database migrations and schema management in the Tari contacts subsystem. |

###### base_layer/contacts/migrations/2023-03-01-1745356_initial/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for the initial contacts table. Drops the 'contacts' table if it exists, reversing the initial migration that created the contacts storage structure. |
| `up.sql` | Initial database migration for the contacts service. Creates the 'contacts' table with columns: address (BLOB, primary key), node_id (BLOB, unique), alias (TEXT), last_seen (DATETIME), and latency (INTEGER). This table stores contact information for peer-to-peer messaging in the Tari network. |

###### base_layer/contacts/migrations/2023-03-02-100000_add_fav_contact/

| File | Description |
|------|-------------|
| `down.sql` | Rollback migration for the favourite contacts feature. Removes the 'favourite' column from the contacts table, reversing the favorite contact functionality addition. |
| `up.sql` | Database migration adding a 'favourite' column to the contacts table. Adds an INTEGER column with default value 0 (not NULL) to support marking contacts as favorites in the Tari contacts system. |

###### base_layer/contacts/migrations/2023-03-14-101758_create_messages/

| File | Description |
|------|-------------|
| `down.sql` | Rollback migration for messages table. Drops the messages table and its associated index, removing the chat message storage functionality. |
| `up.sql` | Database migration creating the messages table for chat functionality. Creates table with columns: address (BLOB), message_id (primary key BLOB), body (BLOB), stored_at (TIMESTAMP), direction (INTEGER). Includes index on address for efficient message retrieval by contact. |

###### base_layer/contacts/migrations/2023-09-05-132343_add_metadata_to_messages/

| File | Description |
|------|-------------|
| `down.sql` | Rollback migration for message metadata. Removes the metadata column from the messages table, reverting the additional message data storage capability. |
| `up.sql` | Database migration adding metadata support to messages. Adds a metadata BLOB column to the messages table to store additional message-specific data in the Tari chat system. |

###### base_layer/contacts/migrations/2023-09-26-083422_add_delivery_confirmations_to_messages/

| File | Description |
|------|-------------|
| `down.sql` | Rollback migration for message confirmations. Removes delivery_confirmation_at and read_confirmation_at columns from the messages table, reverting message tracking functionality. |
| `up.sql` | Database migration adding message confirmation tracking. Adds delivery_confirmation_at and read_confirmation_at TIMESTAMP columns to the messages table to track when messages are delivered and read by recipients. |

###### base_layer/contacts/migrations/2024-04-30-155100_add_sent_timestamp/

| File | Description |
|------|-------------|
| `down.sql` | Rollback migration for sent timestamp. Removes the sent_at column from the messages table, reverting the message sent time tracking functionality. |
| `up.sql` | Database migration adding message sent timestamp. Adds sent_at TIMESTAMP column to the messages table to track when messages were originally sent by the sender. |

###### base_layer/contacts/migrations/2024-05-27-145200_add_from_to_fields/

| File | Description |
|------|-------------|
| `up.sql` | Major database schema refactoring migration for messages. Replaces single 'address' column with separate receiver_address and sender_address columns for clearer message routing. Updates indexes accordingly - drops old idx_messages_address and creates new indexes on receiver_address and sender_address for efficient queries. |

##### base_layer/contacts/proto/

| File | Description |
|------|-------------|
| `message.proto` | Protocol buffer definitions for the Tari contacts chat messaging system. Defines Message, MessageMetadata, Confirmation, and MessageDispatch structures for peer-to-peer communication. Includes DirectionEnum (Inbound/Outbound) and supports message confirmations for delivery and read receipts. Used for serializing chat messages over the network. |

##### base_layer/contacts/src/

| File | Description |
|------|-------------|
| `lib.rs` | Contact management system for Tari wallets providing storage and retrieval of peer contact information. Implements contacts_service for managing wallet address book functionality including adding, removing, and querying contact entries. Includes database schema definitions for persistent contact storage. Essential for wallet user experience, enabling users to save frequently used addresses with human-readable names and manage their transaction counterparties efficiently. |
| `schema.rs` | [GENERATED] Diesel ORM schema file for the contacts service database. Defines table structures for 'contacts' (address, node_id, alias, last_seen, latency, favourite) and 'messages' (receiver_address, sender_address, message_id, body, metadata, timestamps, confirmations, direction). Auto-generated by Diesel CLI from database migrations. |

###### base_layer/contacts/src/contacts_service/

| File | Description |
|------|-------------|
| `error.rs` | Error types for the Tari contacts service. Defines ContactsServiceError with variants for storage errors, transport issues, connectivity problems, message parsing failures, and size validation. Also defines ContactsServiceStorageError for database-related errors including Diesel ORM errors, migration failures, and value conversion issues. Uses thiserror for error composition and From trait implementations. |
| `handle.rs` | Service handle and API interface for the Tari contacts service. Defines ContactsServiceHandle which provides async methods for contact management: get/upsert/remove contacts, send messages, get conversation history, check online status. Includes ContactsLivenessData for peer status tracking and event streams for liveness and message events. Supports pagination for message retrieval with configurable limits. |
| `mod.rs` | Main module file for the Tari contacts service subsystem. Exports error, handle, proto, service, storage, and types modules. Defines ContactsServiceInitializer which sets up the contacts service with database backend, subscription factory, and ping configuration. Integrates with DHT, liveness service, and connectivity requester for peer communication and status tracking. |
| `service.rs` | Core service implementation for the Tari contacts messaging system. Implements ContactsService which manages contacts database, message sending/receiving, liveness tracking, and connectivity events. Handles chat messages, delivery/read confirmations, and online status determination. Supports both direct messaging (for online contacts) and store-and-forward messaging via DHT. Integrates with liveness service for peer monitoring and automatic contact status updates. |

###### base_layer/contacts/src/contacts_service/proto/

| File | Description |
|------|-------------|
| `mod.rs` | Protocol buffer module for the Tari contacts service. Manages protobuf message types and conversions for chat messaging, including generated protobuf code from message.proto. Handles serialization/deserialization for network communication of contact and message data. |

###### base_layer/contacts/src/contacts_service/storage/

| File | Description |
|------|-------------|
| `database.rs` | Database abstraction layer for the Tari contacts service. Defines ContactsBackend trait and ContactsDatabase wrapper for storage operations. Provides unified interface for contact and message storage with support for different backend implementations (SQLite, etc.). Defines database keys, values, and write operations. |
| `mod.rs` | Storage module for the Tari contacts service. Exports database abstractions and type definitions for contact and message storage. Central module organizing storage-related functionality including database backends and data types. |
| `sqlite_db.rs` | SQLite database backend implementation for the Tari contacts service. Implements ContactsBackend trait providing CRUD operations for contacts and messages. Handles database migrations, contact management (fetch, upsert, remove), message storage, confirmation updates, and conversation list queries. Includes connection pooling via PooledDbConnection and comprehensive error handling. |

###### base_layer/contacts/src/contacts_service/storage/types/

| File | Description |
|------|-------------|
| `contacts.rs` | Database-specific type definitions for contacts storage. Defines ContactSql struct and related types for SQLite database operations. Includes conversion methods between domain types (Contact) and database types, update operations, and SQL query helpers for contact management. |
| `messages.rs` | Database-specific type definitions for message storage. Defines MessagesSql, MessagesSqlInsert, and MessageUpdate structs for SQLite operations. Handles conversion between domain Message types and database representations, including metadata, timestamps, and confirmation tracking. |
| `mod.rs` | Storage types module for the Tari contacts service. Exports database-specific type definitions for contacts and messages, providing the data model layer for SQLite storage operations. |

###### base_layer/contacts/src/contacts_service/types/

| File | Description |
|------|-------------|
| `confirmation.rs` | Confirmation type definition for message delivery and read receipts. Defines Confirmation struct with message_id and timestamp for tracking when messages are delivered and read in the Tari chat system. |
| `contact.rs` | Contact type definition for the Tari contacts system. Defines Contact struct with address, node_id, alias, last_seen timestamp, latency, and favourite flag. Core data structure for representing peers in the contact list with networking metadata. |
| `message.rs` | Message type definitions for the Tari chat system. Defines Message struct with sender/receiver addresses, body, metadata, timestamps, direction, and confirmation tracking. Includes MessageId, MessageMetadata, and Direction types for comprehensive chat messaging functionality. |
| `message_builder.rs` | Builder pattern implementation for constructing Message instances. Provides MessageBuilder with fluent interface for setting message properties like body, receiver, metadata, and timestamps. Ensures proper message construction with validation. |
| `message_dispatch.rs` | Message dispatch type for network transport in the Tari chat system. Defines MessageDispatch enum containing Message, DeliveryConfirmation, or ReadConfirmation variants. Used for serializing chat-related messages for transmission over the DHT network. |
| `mod.rs` | Type definitions module for the Tari contacts service. Re-exports core types: Contact, Message types (including ChatBody, Direction, MessageId, MessageMetadata), MessageBuilder for constructing messages, MessageDispatch for network transport, and Confirmation for delivery/read receipts. Central location for all contacts service data structures. |

##### base_layer/contacts/tests/

| File | Description |
|------|-------------|
| `contacts_service.rs` | Integration tests for the Tari contacts service. Tests contact management, message sending/receiving, database operations, and service initialization. Uses in-memory transport and SQLite for testing contact CRUD operations, message confirmation, and peer communication scenarios. |

#### base_layer/core/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for tari_core, the main protocol library containing core Tari blockchain components. Features include base_node (with MMR, transactions, mempool), ledger integration, metrics, and protocol buffers. Dependencies include cryptographic libraries (tari_crypto, chacha20poly1305), networking (tari_comms, tari_p2p), storage (diesel, lmdb), and consensus components (randomx-rs, monero). Contains benchmarks for mempool performance testing. |
| `README.md` | README for the tari_core crate, the foundational library of the Tari cryptocurrency project. Contains core blockchain components including transaction and block definitions, providing the fundamental data structures and algorithms for the Tari protocol implementation. |
| `build.rs` | Build script for the tari_core crate. Handles compile-time code generation, protocol buffer compilation, and feature configuration. Sets up build environment for the core Tari protocol library including protobuf message generation and conditional compilation flags. |
| `diesel.toml` | Diesel CLI configuration for the tari_core crate database schema management. Specifies schema generation settings and database migration configuration for the core blockchain storage components. |

##### base_layer/core/benches/

| File | Description |
|------|-------------|
| `mempool.rs` | Performance benchmarks for the Tari mempool implementation. Tests transaction pool operations including insertion, removal, validation, and retrieval performance. Uses Criterion benchmarking framework to measure mempool efficiency under various load conditions. |

##### base_layer/core/src/

| File | Description |
|------|-------------|
| `lib.rs` | Core Tari blockchain library providing fundamental blockchain components. Exports modules for blocks, chain storage, consensus rules, covenants, proof-of-work algorithms, validation logic, transactions, and mempool management. Includes domain-separated hash functions for Kernel MMR, Output SMT, and Input MMR using Blake2b with 32-byte output. Defines specialized Merkle Mountain Range and Sparse Merkle Tree types for blockchain data structures. Features are conditionally compiled for base_node, mempool_proto, base_node_proto, and transactions to support different build configurations. |

###### base_layer/core/src/base_node/

| File | Description |
|------|-------------|
| `metrics.rs` | Metrics collection for the Tari base node. Defines performance counters, operational statistics, and health monitoring metrics for blockchain operations. Tracks synchronization progress, transaction throughput, peer connections, and system resource utilization. |
| `mod.rs` | Minotari base node implementation providing core blockchain infrastructure services. Implements chain metadata service for blockchain state tracking, communication interface for peer interactions (LocalNodeCommsInterface), state machine service for node lifecycle management (BaseNodeStateMachine), blockchain synchronization with validation (BaseNodeSyncService), gRPC/RPC interfaces for external access, TariPulse service for heartbeat monitoring, and comprehensive metrics collection. Provides services for transaction validation, block validation, chain sync, and API exposure. Core infrastructure component maintaining Tari cryptocurrency security and integrity. |

###### base_layer/core/src/base_node/chain_metadata_service/

| File | Description |
|------|-------------|
| `error.rs` | Error types for the Tari chain metadata service. Defines ChainMetadataServiceError with variants for storage errors, connectivity issues, and metadata synchronization failures. Provides error handling for blockchain metadata operations and peer communication. |
| `handle.rs` | Service handle for the Tari chain metadata service. Provides async interface for querying and managing blockchain metadata including chain height, best block hash, accumulated difficulty, and peer synchronization state. Used by other services to access current chain information. |
| `initializer.rs` | Service initializer for the Tari chain metadata service. Sets up the chain metadata tracking service with database backends and network connectivity. Handles service lifecycle management and dependency injection for blockchain metadata synchronization. |
| `mod.rs` | Main module for the Tari chain metadata service. Exports error handling, service handle, initializer, and core service implementation. Manages blockchain metadata synchronization and provides current chain state information to other base node components. |
| `service.rs` | Core service implementation for Tari chain metadata management. Tracks blockchain metadata including height, difficulty, timestamps, and peer consensus information. Handles metadata updates from block validation, peer synchronization, and provides current chain state to requesting services. |

###### base_layer/core/src/base_node/comms_interface/

| File | Description |
|------|-------------|
| `comms_request.rs` | Communication request types for the Tari base node. Defines request message types for peer-to-peer communication including block requests, transaction queries, metadata synchronization, and consensus operations. Used in the base node's communication protocol. |
| `comms_response.rs` | Communication response types for the Tari base node. Defines response message types for peer-to-peer communication including block data, transaction information, metadata responses, and error conditions. Complements comms_request.rs for bidirectional base node communication. |
| `error.rs` | Error types for the Tari base node communication interface. Defines errors for peer communication failures, message parsing issues, network timeouts, and protocol violations. Provides comprehensive error handling for base node network operations. |
| `inbound_handlers.rs` | Inbound message handlers for the Tari base node communication interface. Processes incoming messages from peers including block announcements, transaction propagation, metadata requests, and synchronization messages. Implements protocol message handling and validation logic. |
| `local_interface.rs` | Local interface for base node communication operations. Provides internal API for local services to interact with the base node's blockchain state. Handles local queries, block submission, transaction validation, and service-to-service communication within the node. |
| `mod.rs` | Main communication interface module for the Tari base node. Exports request/response types, error handling, inbound/outbound handlers, and local interface components. Central module organizing all base node peer-to-peer and internal communication functionality. |
| `outbound_interface.rs` | Outbound interface for base node peer communication. Handles outgoing messages to other nodes including block propagation, transaction broadcasting, metadata synchronization requests, and peer discovery operations. Manages connection pools and message routing for network communication. |

###### base_layer/core/src/base_node/proto/

| File | Description |
|------|-------------|
| `chain_metadata.proto` | Protocol buffer definitions for Tari blockchain metadata. Defines chain metadata messages including height, best block hash, accumulated difficulty, timestamp, and peer consensus information. Used for synchronization and consensus operations between base nodes. |
| `chain_metadata.rs` | [GENERATED] Generated Rust bindings for chain metadata protocol buffers. Contains auto-generated code from chain_metadata.proto for serializing/deserializing blockchain metadata messages. Provides type conversions and validation for network communication. |
| `mod.rs` | Protocol buffer module for Tari base node messages. Exports generated protobuf types for chain metadata, requests, responses, RPC services, and wallet communication. Central module organizing all base node protocol buffer definitions and conversions. |
| `request.proto` | Protocol buffer definitions for Tari base node service requests. Defines BaseNodeServiceRequest with operations for fetching blocks from all chains and mempool transactions by excess signatures. Includes supporting message types: ExcessSigs, BlockHeights, Signatures, Commitments, and NewBlockTemplateRequest for various blockchain query operations. |
| `request.rs` | [GENERATED] Generated Rust bindings for base node request protocol buffers. Contains auto-generated code from request.proto for base node service requests including block queries, mempool operations, and service calls. Provides message serialization and type conversions. |
| `response.proto` | Protocol buffer definitions for Tari base node service responses. Defines BaseNodeServiceResponse with various response types: BlockResponse, HistoricalBlocks, FetchMempoolTransactionsResponse. Includes supporting message types for block headers, transaction kernels/outputs, MMR nodes, and sync status information. |
| `response.rs` | [GENERATED] Generated Rust bindings for base node response protocol buffers. Contains auto-generated code from response.proto for base node service responses including block data, transaction information, and query results. Handles response message serialization and validation. |
| `rpc.proto` | Protocol buffer definitions for Tari base node RPC services. Defines RPC service interfaces and message types for remote procedure calls between base nodes and clients. Includes blockchain query operations, transaction submission, and synchronization services. |
| `rpc.rs` | [GENERATED] Generated Rust bindings for base node RPC protocol buffers. Contains auto-generated RPC service implementations and message types from rpc.proto. Provides client and server interfaces for base node remote procedure calls and service definitions. |
| `wallet_rpc.proto` | Protocol buffer definitions for Tari wallet-to-base-node RPC communication. Defines service interfaces and message types for wallet queries including UTXO requests, transaction submission, balance queries, and blockchain synchronization operations between wallets and base nodes. |
| `wallet_rpc.rs` | [GENERATED] Generated Rust bindings for wallet RPC protocol buffers. Contains auto-generated service implementations and message types from wallet_rpc.proto. Provides client and server interfaces for wallet-to-base-node communication including UTXO queries and transaction operations. |

###### base_layer/core/src/base_node/rpc/

| File | Description |
|------|-------------|
| `mod.rs` | RPC module for the Tari base node. Exports RPC service implementations, query models, and sync utilities for base node remote procedure calls. Organizes wallet-facing RPC services and blockchain query operations. |
| `query_service.rs` | Query service implementation for Tari base node RPC. Handles blockchain query operations including block retrieval, transaction lookups, UTXO queries, and chain metadata requests. Provides read-only access to blockchain data for external clients and wallets. |
| `service.rs` | RPC service implementation for Tari base node wallet interface. Implements BaseNodeWalletService providing blockchain query operations: UTXO fetching, mempool stats, transaction submission, tip info, sync operations. Handles wallet-to-node communication with comprehensive error handling and transaction validation. |
| `sync_utxos_by_block_task.rs` | RPC task for streaming UTXOs (Unspent Transaction Outputs) by block range. Implements SyncUtxosByBlockTask that fetches outputs from blockchain database between specified block headers and streams them to clients in chunks of 2000. Exports: SyncUtxosByBlockTask struct with new() and run() methods. Dependencies: AsyncBlockchainDb, protobuf types, tokio mpsc channels. Used by: base node RPC service for UTXO synchronization. Includes proper error handling, client disconnection detection, and performance logging. |

###### base_layer/core/src/base_node/rpc/models/

| File | Description |
|------|-------------|
| `get_tip_info.rs` | RPC model for blockchain tip information queries. Defines data structures and response types for retrieving current blockchain tip information including height, hash, difficulty, and timestamp. Used by wallets and external services to query chain state. |
| `mod.rs` | RPC models module for the Tari base node. Exports data structures and response types for various RPC operations including tip information, block queries, and blockchain state requests. Provides type definitions for wallet-facing API responses. |

###### base_layer/core/src/base_node/service/

| File | Description |
|------|-------------|
| `error.rs` | Error types for base node service operations. Defines BaseNodeServiceError enum handling CommsInterfaceError, DhtOutboundError, invalid requests/responses, and block message errors. Exports: BaseNodeServiceError with get_ban_reason() method. Dependencies: CommsInterfaceError, DhtOutboundError, ExtractBlockError, BanPeriod/BanReason types. Used by: all base node service components for error handling. Implements automatic peer banning logic for invalid messages with configurable ban durations. |
| `initializer.rs` | Service initializer for base node communication and message handling. Implements BaseNodeServiceInitializer that sets up inbound/outbound message streams, comms interfaces, and spawns BaseNodeService. Exports: BaseNodeServiceInitializer struct, ExtractBlockError enum. Dependencies: blockchain DB, mempool, consensus manager, RandomXFactory, DHT, connectivity. Used by: service framework during base node startup. Creates message streams for requests/responses/blocks, handles service registration, and manages async initialization with proper error handling. |
| `mod.rs` | Module organization for base node service components. Re-exports BaseNodeServiceInitializer, BaseNodeServiceRequest, and BaseNodeServiceResponse. Dependencies: error, initializer, service, service_request, service_response modules. Used by: base node components requiring service functionality. Simple module interface providing access to core service types and initialization components. |
| `service.rs` | Core base node service handling P2P communication, request/response processing, and block propagation. Implements BaseNodeService that manages inbound/outbound message streams, waiting requests, timeouts, and peer banning. Exports: BaseNodeService, BaseNodeStreams structs with comprehensive networking methods. Dependencies: DHT, connectivity, state machine, blockchain backend, waiting requests. Used by: base node initializer as central communication hub. Features async message handling, automatic timeouts, ban management, and proper stream multiplexing with extensive error handling and logging. |
| `service_request.rs` | Request wrapper type for base node service operations. Defines BaseNodeServiceRequest struct containing request key and NodeCommsRequest. Exports: BaseNodeServiceRequest with request_key and request fields. Dependencies: NodeCommsRequest, RequestKey types. Used by: base node service for tracking and routing incoming requests. Simple data structure with serialization support for request identification and processing. |
| `service_response.rs` | Response wrapper type for base node service operations. Defines BaseNodeServiceResponse struct containing request key, response data, and sync status. Exports: BaseNodeServiceResponse with request_key, response, and is_synced fields. Dependencies: NodeCommsResponse, RequestKey types. Used by: base node service for returning processed responses with sync state information. Tracks whether the node is synchronized when responding to requests. |

###### base_layer/core/src/base_node/state_machine_service/

| File | Description |
|------|-------------|
| `handle.rs` | Handle interface for base node state machine monitoring and control. Implements StateMachineHandle providing access to state change events, status information, and shutdown signals. Exports: StateMachineHandle with event stream and status watch methods. Dependencies: broadcast/watch channels, ShutdownSignal, StateEvent, StatusInfo. Used by: base node components needing state machine monitoring. Enables multiple subscribers to state changes and status updates through cloneable channel receivers. |
| `initializer.rs` | Service initializer for base node state machine coordination. Implements BaseNodeStateMachineInitializer that creates state machine with event publishing, status monitoring, and consensus validation. Exports: BaseNodeStateMachineInitializer struct. Dependencies: blockchain DB, consensus manager, crypto factories, RandomXFactory, sync validators, DHT. Used by: service framework during base node startup. Sets up state machine with proper event channels, handles, and validation components for blockchain synchronization and consensus. |
| `mod.rs` | Module organization for base node state machine service components. Re-exports StateMachineHandle, BaseNodeStateMachine, and BaseNodeStateMachineConfig. Dependencies: handle, initializer, state_machine, states modules. Used by: base node components requiring state machine functionality. Provides clean interface to state machine core types and state management components. |
| `state_machine.rs` | Core finite state machine implementation for Tari base node synchronization and blockchain management. Implements BaseNodeStateMachine with state transitions for Starting->Listening->HeaderSync->HorizonStateSync->BlockSync states. Exports: BaseNodeStateMachine, BaseNodeStateMachineConfig structs with transition logic and event handling. Dependencies: blockchain DB, consensus manager, peer manager, DHT, RandomXFactory, sync validators. Used by: base node as central coordination component. Features comprehensive state management, bootstrap detection, event publishing, and automatic state transitions with proper error handling and metrics. |

###### base_layer/core/src/base_node/state_machine_service/states/

| File | Description |
|------|-------------|
| `block_sync.rs` | Block synchronization state for downloading and validating blockchain blocks. Implements BlockSync state that coordinates with BlockSynchronizer to download blocks from peers, validate them, and add to local chain. Exports: BlockSync struct with sync progress tracking and completion detection. Dependencies: BlockSynchronizer, sync validators, blockchain DB, connectivity. Used by: state machine during block synchronization phase. Features progress callbacks, block validation, orphan cleanup, pending header clearing, and proper error handling with chain recovery on failure. |
| `events_and_states.rs` | State machine definitions for Tari base node synchronization. Defines BaseNodeState enum with states: Starting, HeaderSync, DecideNextSync, HorizonStateSync, BlockSync, Listening, Waiting, Shutdown. Includes events and state transitions for blockchain synchronization, peer communication, and consensus management. |
| `header_sync.rs` | Header synchronization state for downloading and validating blockchain headers. Implements HeaderSyncState that manages HeaderSynchronizer to download headers from best peers, validate proof-of-work, and handle chain reorganizations. Exports: HeaderSyncState with peer management and sync status tracking. Dependencies: HeaderSynchronizer, consensus rules, RandomXFactory, blockchain DB. Used by: state machine during header synchronization phase. Features peer selection by latency/difficulty, rewind handling, progress tracking, and automatic peer removal for peers without better chains. |
| `horizon_state_sync.rs` | Horizon state synchronization for pruned mode blockchain synchronization. Implements HorizonStateSync that downloads UTXO state and kernels from a specific pruning horizon using HorizonStateSynchronization. Exports: HorizonStateSync with target height calculation and peer coordination. Dependencies: HorizonStateSynchronization, crypto factories, range proof validation, sync validators. Used by: state machine for pruned node synchronization to catch up on UTXO state. Determines sync requirements based on pruning height and downloads compressed blockchain state rather than full block history. |
| `listening.rs` | Listening state for monitoring chain metadata and detecting when synchronization is needed. Implements Listening state that processes ChainMetadataEvent messages, tracks peer metadata, determines sync mode, and triggers sync when falling behind network. Exports: Listening, ListeningInfo, PeerMetadata structs with sync detection logic. Dependencies: chain metadata service, peer manager, sync status determination. Used by: state machine as default operational state. Features peer metadata caching, initial sync detection, forced sync peer support, lagging detection with configurable delays, and comprehensive sync mode determination based on accumulated difficulty and block heights. |
| `mod.rs` | Module organization and documentation for base node finite state machine states. Re-exports all state types including BaseNodeState, BlockSync, HeaderSyncState, DecideNextSync, HorizonStateSync, Listening, Shutdown, Starting, Waiting and related event/info types. Dependencies: events_and_states, individual state modules. Used by: state machine and components needing state types. Provides comprehensive documentation of the FSM flow from Starting->Listening->HeaderSync->DecideNextSync->HorizonStateSync/BlockSync->Listening with detailed state transition descriptions and synchronization process overview. |
| `shutdown_state.rs` | Shutdown state for graceful base node termination. Implements Shutdown struct that holds a shutdown reason and provides display formatting. Exports: Shutdown with with_reason() constructor. Dependencies: standard logging. Used by: state machine for graceful shutdown handling. Simple state that logs the shutdown reason and allows the state machine to cleanly terminate operations and complete pending tasks before exiting. |
| `starting_state.rs` | Starting state for base node initialization and bootstrap detection. Implements Starting state that waits for DHT bootstrap completion and chain metadata events before transitioning to Listening state. Exports: Starting struct with bootstrap monitoring logic. Dependencies: DHT events, chain metadata service, broadcast channels. Used by: state machine during node startup. Features DHT bootstrap detection via PrimaryBootstrapComplete events, network silence detection for isolated nodes, bootstrap timeout handling, and proper transition to Listening state with network status indication. |
| `sync_decide.rs` | Decision state for determining the next synchronization phase after header sync. Implements DecideNextSync that analyzes blockchain metadata and peer capabilities to choose between horizon sync, block sync, or continuing to listening. Exports: DecideNextSync with sync mode decision logic. Dependencies: sync peers, blockchain metadata, pruning configuration. Used by: state machine after header synchronization to determine optimal sync strategy. Features peer filtering based on pruning capabilities, horizon sync eligibility for pruned nodes, block sync fallback, and intelligent peer selection based on latency and blockchain capability. |
| `waiting.rs` | Waiting state for temporary delays after synchronization failures. Implements Waiting struct that pauses the state machine for a configurable timeout before returning to normal operations. Exports: Waiting with configurable timeout duration. Dependencies: tokio async sleep. Used by: state machine after sync failures to prevent rapid retry loops. Features default 5-second timeout, async sleep implementation, and automatic transition back to active states after the delay period. Transitions from BlockSync, HeaderSyncState, and HorizonStateSync on failures. |

###### base_layer/core/src/base_node/sync/

| File | Description |
|------|-------------|
| `ban.rs` | Peer ban management for blockchain synchronization. Implements PeerBanManager that handles conditional peer banning during sync operations while respecting forced sync peer allowlists. Exports: PeerBanManager with ban_peer_if_required() method. Dependencies: ConnectivityRequester, BlockchainSyncConfig, NodeId. Used by: sync components for managing misbehaving peers. Features protection for forced sync peers from banning, configurable ban durations, proper logging of ban reasons, and integration with connectivity layer for peer management. |
| `config.rs` | Configuration settings for blockchain synchronization behavior. Defines BlockchainSyncConfig with timeout settings, ban periods, sync peer management, and validation concurrency. Exports: BlockchainSyncConfig with serialization support and sensible defaults. Dependencies: duration serialization, peer NodeId types. Used by: all sync components for configuration. Features configurable sync latency limits, adaptive timeout increases, dual ban period system (short/long), forced sync peer allowlists, validation thread control, RPC deadline management, and seed bootstrap round configuration. |
| `hooks.rs` | Callback hook system for synchronization progress reporting. Implements Hooks struct that manages various callback types for sync events including starting, progress, completion, and rewind operations. Exports: Hooks with methods for adding and calling different hook types. Dependencies: sync peer types, chain block types, horizon sync info. Used by: all synchronizers for progress reporting and event notification. Features callback management for header/block progress, sync completion events, chain rewind notifications, and horizon sync updates with thread-safe callback execution. |
| `mod.rs` | Top-level module organization for blockchain synchronization system. Re-exports all sync components including ban management, sync configuration, block/header/horizon synchronizers, validators, and RPC services. Dependencies: ban, config, block_sync, header_sync, horizon_state_sync, hooks, rpc, sync_peer, validators modules. Used by: base node for accessing complete sync functionality. Comprehensive sync module interface providing feature-gated access to all synchronization components, error types, and configuration with proper conditional compilation for different build configurations. |
| `sync_peer.rs` | Peer synchronization management for blockchain sync operations. Exports: SyncPeer struct with connection state, sync progress tracking, and peer communication methods. Dependencies: base node comms, peer manager, sync protocols. Used by: sync orchestrator, header sync, block sync. Manages individual peer sync sessions, tracks sync progress, handles peer disconnections, and maintains sync state across multiple concurrent synchronization operations. |
| `validators.rs` | Validation utilities for blockchain synchronization operations. Exports: Block and header validation functions for sync processes. Dependencies: consensus manager, block validation, chain storage. Used by: sync orchestrator, header sync, block sync. Provides specialized validation logic for synchronized blocks and headers including difficulty validation, timestamp checks, and chain integrity verification during synchronization operations. |

###### base_layer/core/src/base_node/sync/block_sync/

| File | Description |
|------|-------------|
| `error.rs` | Error types and ban logic for block synchronization operations. Defines BlockSyncError enum covering RPC errors, validation failures, connectivity issues, peer misbehavior, and latency problems. Exports: BlockSyncError with get_ban_reason() and to_short_str() methods. Dependencies: RPC types, chain storage, validation errors, ban system. Used by: block synchronization components for error handling. Features comprehensive error categorization, automatic ban reason determination with short/long ban periods, and concise error string representations for logging and metrics. |
| `mod.rs` | Module organization for block synchronization components. Re-exports BlockSyncError and BlockSynchronizer from their respective modules. Dependencies: error and synchronizer modules. Used by: sync system components requiring block synchronization functionality. Simple module interface providing access to block sync error handling and the main block synchronization implementation. |
| `synchronizer.rs` | Core block synchronization implementation for downloading and validating blockchain blocks from peers. Implements BlockSynchronizer that manages RPC connections, streams blocks, validates them, and adds to local blockchain. Exports: BlockSynchronizer with callback hooks, peer management, and adaptive latency handling. Dependencies: RPC client, block validators, blockchain DB, connectivity, peer ban manager. Used by: BlockSync state for downloading blocks. Features peer latency monitoring, adaptive timeout increases, block validation pipeline, progress callbacks, peer rotation on failures, chain continuity verification, and comprehensive error handling with automatic peer banning. |

###### base_layer/core/src/base_node/sync/header_sync/

| File | Description |
|------|-------------|
| `error.rs` | Error types and ban logic for header synchronization operations. Defines BlockHeaderSyncError enum covering RPC errors, validation failures, peer misbehavior, chain link issues, and metadata inaccuracies. Exports: BlockHeaderSyncError with get_ban_reason() method. Dependencies: RPC types, chain storage, validation errors, ban system. Used by: header synchronization components for error handling. Features comprehensive error categorization, automatic ban reason determination with differentiated ban periods for protocol violations vs connectivity issues, and special handling for peer metadata mismatches. |
| `mod.rs` | Module organization for header synchronization components. Re-exports BlockHeaderSyncError, HeaderSynchronizer, AttemptSyncResult, and HeaderSyncStatus. Defines HEADER_SYNC_INITIAL_MAX_HEADERS constant for batch sizing. Dependencies: error, validator, synchronizer modules. Used by: sync system components requiring header synchronization functionality. Simple module interface providing access to header sync error handling, synchronization logic, and result types. |
| `synchronizer.rs` | Core header synchronization implementation for downloading and validating blockchain headers from peers. Implements HeaderSynchronizer that manages chain split detection, header validation, reorg handling, and chain switching decisions. Exports: HeaderSynchronizer, AttemptSyncResult, HeaderSyncStatus, ChainSplitInfo structs with comprehensive sync logic. Dependencies: header validator, RPC client, blockchain DB, consensus rules, ban manager. Used by: HeaderSync state for downloading headers. Features chain split detection with fork hash resolution, progressive header validation, accumulated difficulty comparison, adaptive latency handling, reorg processing, and automatic chain switching when higher PoW is detected. |
| `validator.rs` | Header validation logic for blockchain header synchronization. Implements BlockHeaderSyncValidator that maintains validation state, validates proof-of-work, manages target difficulties, and accumulates validated headers. Exports: BlockHeaderSyncValidator with stateful validation methods. Dependencies: HeaderFullValidator, DifficultyCalculator, consensus rules, RandomXFactory. Used by: header synchronizer for validating downloaded headers. Features rolling timestamp management, target difficulty calculation, PoW validation, chain accumulation tracking, RandomX VM key management, and chain strength comparison for fork resolution. |

###### base_layer/core/src/base_node/sync/horizon_state_sync/

| File | Description |
|------|-------------|
| `error.rs` | Error types and ban logic for horizon state synchronization operations. Defines HorizonSyncError enum covering RPC errors, validation failures, SMT errors, range proof verification, MMR issues, and peer misbehavior. Exports: HorizonSyncError with get_ban_reason() method. Dependencies: RPC types, chain storage, validation, range proofs, MMR errors. Used by: horizon synchronization components for error handling. Features comprehensive error categorization for pruned mode sync, automatic ban reason determination, merkle tree validation errors, and transaction component validation failures with differentiated ban periods. |
| `events.rs` | Event types and status information for horizon state synchronization progress tracking. Defines HorizonSyncInfo and HorizonSyncStatus for monitoring kernel/output sync progress with peer performance metrics. Exports: HorizonSyncInfo, HorizonSyncStatus enums with formatting and progress calculation. Dependencies: SyncPeer, NodeId types. Used by: horizon synchronizer for progress reporting and state machine updates. Features progress percentage calculation, peer performance tracking with items per second, sync phase indication (Starting/Kernels/Outputs/Finalizing), and comprehensive display formatting. |
| `mod.rs` | Module organization for horizon state synchronization components. Re-exports HorizonSyncError, HorizonSyncInfo, HorizonSyncStatus, and HorizonStateSynchronization from their respective modules. Dependencies: error, events, synchronizer modules. Used by: sync system components requiring horizon state synchronization functionality. Simple module interface providing access to horizon sync error handling, progress tracking, and the main horizon synchronization implementation for pruned mode blockchain sync. |
| `synchronizer.rs` | Core horizon state synchronization implementation for pruned mode blockchain synchronization. Implements HorizonStateSynchronization that downloads kernels and UTXOs from horizon height, validates range proofs, manages SMT state, and performs final validation. Exports: HorizonStateSynchronization with pruning, validation, and commitment sum calculation. Dependencies: RPC client, range proof service, final state validator, blockchain DB. Used by: HorizonStateSync state for efficient pruned sync. Features kernel MMR validation, output SMT management, range proof batch verification, commitment sum calculation, cleanup on failure, adaptive latency handling, and comprehensive final state validation with peer management and ban logic. |

###### base_layer/core/src/base_node/sync/rpc/

| File | Description |
|------|-------------|
| `mod.rs` | RPC synchronization service module for base nodes. Defines the BaseNodeSyncService trait with methods for syncing blocks, headers, kernels, and UTXOs between nodes. Exports: BaseNodeSyncRpcService, create_base_node_sync_rpc_service(). Dependencies: tari_comms RPC framework, chain storage backend, base node comms interface. Used by: base node synchronization layer. Implements protocol "t/blksync/1" with 6 RPC methods for blockchain data synchronization. |
| `service.rs` | Implementation of BaseNodeSyncService RPC methods for blockchain synchronization. Exports: BaseNodeSyncRpcService struct with sync_blocks(), sync_headers(), sync_kernels(), sync_utxos(), get_header_by_height(), find_chain_split(), get_chain_metadata(). Dependencies: AsyncBlockchainDb, LocalNodeCommsInterface, SyncUtxosTask. Used by: base node RPC server. Implements session management, batch streaming, reorg detection, and concurrent sync limiting. Includes comprehensive error handling and metrics tracking. |
| `sync_utxos_task.rs` | UTXO synchronization task for streaming transaction outputs between base nodes. Exports: SyncUtxosTask struct with new(), run() methods. Dependencies: AsyncBlockchainDb, blockchain backend, SyncUtxosRequest/Response protos. Used by: BaseNodeSyncRpcService. Handles streaming of unspent outputs, spent commitments, and pruned genesis outputs. Includes validation of header ranges and comprehensive error handling for database consistency. |
| `tests.rs` | Unit tests for base node RPC synchronization services. Dependencies: test fixtures, mock blockchain database, RPC testing utilities. Used by: test suite. Contains integration tests for sync_blocks(), sync_headers(), sync_kernels(), sync_utxos(), and related RPC methods. Tests error conditions, edge cases, session management, and data consistency during blockchain synchronization operations. |

###### base_layer/core/src/base_node/tari_pulse_service/

| File | Description |
|------|-------------|
| `mod.rs` | Tari Pulse service module for base node health monitoring and status reporting. Exports: TariPulseService with health check functionality. Dependencies: base node components, metrics collection. Used by: base node services, monitoring systems. Provides periodic health checks, status reporting, and diagnostic information for base node operations including sync status, blockchain state, and performance metrics. |

###### base_layer/core/src/blocks/

| File | Description |
|------|-------------|
| `accumulated_data.rs` | Accumulated blockchain data structures for block and header metadata. Exports: BlockAccumulatedData, BlockHeaderAccumulatedData, UpdateBlockAccumulatedData, BlockHeaderAccumulatedDataBuilder. Dependencies: MMR pruned hashsets, proof of work, commitments. Used by: blockchain database, block validation, chain reorganization. Contains kernel MMR data, cumulative difficulty calculations, and block header chain linking information for efficient blockchain state management. |
| `block.rs` | Core block structure for the Tari blockchain implementing Mimblewimble protocol. Exports: Block, BlockBuilder, NewBlock, BlockValidationError. Dependencies: BlockHeader, AggregateBody, transactions, consensus, proof_of_work. Used by: entire blockchain layer. Contains block validation, fee calculation, coinbase verification, and block construction utilities. Includes comprehensive builder pattern for creating new blocks with proper MMR root calculations. |
| `block_header.rs` | Block header structure containing blockchain metadata and proof of work. Exports: BlockHeader, BlockHeaderValidationError. Dependencies: consensus, proof_of_work, crypto types. Used by: Block, blockchain database, validation. Contains block height, timestamps, Merkle roots for inputs/outputs/kernels, validator nodes, and nonce. Implements mining hash calculation, timing statistics, and comprehensive validation methods for blockchain integrity. |
| `error.rs` | Error types for block operations and validation. Exports: BlockError enum with BuilderMissingField, BuilderInvalidValue, HistoricalBlockContainsPrunedTxos, ChainBlockInvariantError, DifficultyOverflow variants. Dependencies: thiserror. Used by: block construction, validation, historical block processing. Provides structured error handling for block builder validation, historical block operations, and blockchain invariant violations. |
| `genesis_block.rs` | Genesis block generation for different Tari networks (MainNet, StageNet, NextNet, Igor, Esmeralda, LocalNet). Exports: get_genesis_block(), get_*_genesis_block() functions. Dependencies: Block, BlockHeader, transactions, proof_of_work, Network. Used by: consensus manager, blockchain initialization. Contains hardcoded genesis blocks with pre-mine UTXOs, proper Merkle roots, and accumulated difficulty for each network type. Includes pre-mine UTXO addition functionality. |
| `historical_block.rs` | Historical block representation for pruned blockchain storage. Exports: HistoricalBlock struct with methods for handling pruned transaction data. Dependencies: Block, AggregateBody, pruned hashsets. Used by: blockchain database, pruned node operations. Stores block header and pruned transaction body with MMR data, allowing efficient storage of historical blocks without full transaction details. Supports conversion to full blocks when unpruned data is available. |
| `mod.rs` | Blockchain block structure and management module. Defines core block types including Block, BlockBuilder, BlockHeader with validation, and specialized block types like HistoricalBlock, NewBlockTemplate, ChainBlock with accumulated data. Features conditional compilation for base_node and base_node_proto configurations. Includes genesis block creation, pre-mine handling, block error types, and domain-separated hashing for blocks security. Exports block validation errors and accumulated data structures for blockchain state management. |
| `new_block_template.rs` | Template for constructing new blocks during mining operations. Exports: NewBlockTemplate struct with header template, transaction body, and mining data. Dependencies: BlockHeader, AggregateBody, transactions. Used by: block template service, miners, block construction. Contains pre-assembled block components ready for proof-of-work mining including coinbase transactions, fee calculations, and MMR root preparations. |
| `new_blockheader_template.rs` | Template for constructing new block headers during mining. Exports: NewBlockHeaderTemplate struct with pre-filled header fields. Dependencies: BlockHeader, proof_of_work, consensus. Used by: mining services, block template construction. Provides header template with all fields except nonce and proof-of-work ready for mining operations including timestamp, previous hash, and MMR roots. |

###### base_layer/core/src/blocks/gen_block/

| File | Description |
|------|-------------|
| `Tari.Manifesto` | Tari genesis block manifesto - ASCII art and philosophical text embedded in the genesis block expressing the project's vision for privacy, freedom, and financial sovereignty. Contains the founding principles emphasizing rebellion against surveillance capitalism and the creation of a sanctuary for private financial transactions. This manifesto is embedded into the genesis block of the Tari blockchain and serves as the foundational document expressing the project's mission and values. |

###### base_layer/core/src/blocks/pre_mine/

| File | Description |
|------|-------------|
| `esmeralda_pre_mine.json` | Esmeralda network pre-mine transaction output definition in JSON format. Contains the pre-mined UTXO for the Tari Esmeralda test network including commitment, metadata signature, script, sender offset public key, and range proof details. Used for development and testing of new features before they reach other networks. |
| `igor_pre_mine.json` | Igor network pre-mine transaction output definition in JSON format. Contains the pre-mined UTXO for the Tari Igor test network including commitment, metadata signature, script, sender offset public key, and range proof details. Used for development testing and feature validation in an isolated network environment. |
| `mainnet_pre_mine.json` | Mainnet pre-mine transaction output definition in JSON format. Contains the pre-mined UTXO for the Tari mainnet including commitment, metadata signature, script, sender offset public key, and range proof details. This defines the initial distribution of tokens in the mainnet genesis block. Large file containing the complete UTXO data structure with cryptographic proofs and commitments. |
| `mod.rs` | Pre-mine token allocation and release schedule implementation for Tari tokenomics. Exports: UnlockSchedule, Apportionment, ReleaseCadence, PreMineItem structs; get_tokenomics_pre_mine_unlock_schedule(), create_pre_mine_genesis_block_info(), get_pre_mine_items() functions. Dependencies: transaction components, TariScript, key management. Used by: genesis block creation, tokenomics validation. Implements the complete Tari tokenomics specification with network rewards (70%), protocol (9%), community (5%), contributors (4%), and participants (12%) allocations with complex release schedules. |
| `nextnet_pre_mine.json` | Nextnet (testnet) pre-mine transaction output definition in JSON format. Contains the pre-mined UTXO for the Tari test network including commitment, metadata signature, script, sender offset public key, and range proof details. Used for testing network initialization and token distribution scenarios before mainnet deployment. |
| `stagenet_pre_mine.json` | Stagenet pre-mine transaction output definition in JSON format. Contains the pre-mined UTXO for the Tari staging network including commitment, metadata signature, script, sender offset public key, and range proof details. Used for staging and final validation before production deployments to mainnet. |

###### base_layer/core/src/chain_storage/

| File | Description |
|------|-------------|
| `active_validator_node.rs` | Active validator node tracking and management for DAN layer integration. Exports: ActiveValidatorNode struct with registration and epoch management. Dependencies: validator node types, epoch management, chain storage. Used by: validator node registry, DAN layer. Tracks active validator nodes, their registration status, epochs of operation, and stake amounts for the distributed application network layer of Tari. |
| `async_db.rs` | Asynchronous wrapper for blockchain database operations using tokio. Exports: AsyncBlockchainDb<B> struct with 60+ async methods mirroring BlockchainDatabase. Dependencies: tokio spawn_blocking, BlockchainDatabase, BlockchainBackend. Used by: base node services, RPC handlers, sync operations. Provides non-blocking access to blockchain data with automatic thread pool management and tracing. Includes macro-generated async functions for all database operations. |
| `block_add_result.rs` | Result types for block addition operations to the blockchain. Exports: BlockAddResult enum with Added, ChainReorg, Duplicate, OrphanBlock variants. Dependencies: ChainBlock types. Used by: blockchain database, block validation, sync operations. Provides structured results for block addition attempts including success states, reorganization information, and error conditions for blockchain state management. |
| `blockchain_backend.rs` | Blockchain database backend trait defining storage interface. Exports: BlockchainBackend trait with write(), fetch(), contains() and 40+ specialized methods. Dependencies: ChainStorageError, DbKey/DbValue types, block/transaction types. Used by: LMDB implementation, blockchain database. Defines atomic transaction support, data retrieval operations, MMR management, and UTXO operations. Requires thread-safe Send + Sync implementations with ACID transaction guarantees. |
| `blockchain_database.rs` | Primary blockchain database implementation with comprehensive chain storage functionality. Exports: BlockchainDatabase<B> struct implementing 80+ methods for blockchain operations. Dependencies: BlockchainBackend, consensus manager, validation, MMR management. Used by: base node, sync services, mining. Provides high-level blockchain storage with block addition, reorganization handling, UTXO management, MMR operations, orphan management, and extensive query capabilities. Includes transaction batching, validation, and chain state management. |
| `consts.rs` | Chain storage constants and configuration values. Exports: Database configuration constants for pruning, capacity limits, and performance tuning. Dependencies: None. Used by: blockchain database, LMDB implementation. Defines critical values like orphan storage capacity, pruning intervals, horizon depths, and database performance parameters for blockchain storage optimization. |
| `db_transaction.rs` | Database transaction abstraction for atomic blockchain operations. Exports: DbTransaction, DbKey, DbValue enums for type-safe database operations. Dependencies: blockchain data types, serialization. Used by: BlockchainBackend implementations, database operations. Provides strongly-typed transaction batching with atomic commit/rollback semantics. Includes comprehensive key-value mappings for all blockchain data types. |
| `error.rs` | Error types and handling for chain storage operations. Exports: ChainStorageError enum with database, validation, and consistency error variants. Dependencies: database backends, validation errors. Used by: all chain storage operations, error propagation. Provides structured error handling for database access failures, data corruption, validation errors, and blockchain consistency issues with detailed error context. |
| `horizon_data.rs` | Pruning horizon data management for blockchain storage optimization. Exports: HorizonData struct with pruning metadata and chain state information. Dependencies: chain metadata, block headers. Used by: pruned nodes, storage optimization. Manages blockchain pruning boundaries, tracks pruned height information, and maintains sufficient data for chain validation while reducing storage requirements in pruned node configurations. |
| `mmr_tree.rs` | Merkle Mountain Range (MMR) tree type enumeration for Tari blockchain storage. Exports: MmrTree enum with Kernel variant. Dependencies: serde for serialization. Used by: MMR operations, kernel accumulation, blockchain validation. Simple enumeration defining different types of MMR trees used in the blockchain, currently supporting only kernel MMR trees for transaction kernel accumulation and proofs. |
| `mod.rs` | Blockchain state storage abstraction layer providing modular storage components for kernels, UTXOs, and Merkle trees. Implements BlockchainDatabase interface with LMDB backend support, MMR (Merkle Mountain Range) management, target difficulty calculations, and validator node handling. Includes async database operations, block addition results, database transactions (DbTransaction, WriteOperation), horizon data for pruning, reorg handling, and comprehensive statistics tracking. Supports configurable storage backends and provides ChainTipData for current blockchain state. |
| `reorg.rs` | Blockchain reorganization data structure and utilities for Tari blockchain storage. Exports: Reorg struct representing chain reorganization events. Key fields: new_height, new_hash, prev_height, prev_hash, num_blocks_added, num_blocks_removed, local_time. Key methods: from_reorged_blocks(). Dependencies: chrono, serde, tari_common_types, ChainBlock. Used by: blockchain reorganization handling, fork resolution, chain state tracking. Records details of chain reorganizations for logging and analysis. |
| `smt_hasher.rs` | Sparse Merkle Tree (SMT) hasher implementation for Tari blockchain using JMT. Exports: OutputSmtHasher implementing SimpleHasher trait with Blake2b and domain separation. Dependencies: blake2, jmt, tari_crypto. Used by: sparse merkle tree operations, output state proofs, cryptographic tree verification. Provides domain-separated hashing for output SMT operations ensuring cryptographic security and separation from other hash contexts in the system. |
| `stats.rs` | Database statistics collection and reporting for Tari blockchain LMDB storage. Exports: DbBasicStats, DbStat, EnvInfo structs for database performance monitoring. Key methods: new(), root(), env_info(), db_stats(), total_entries(), used_pages(). Dependencies: lmdb_zero for LMDB statistics. Used by: database monitoring, performance analysis, storage optimization. Provides comprehensive database statistics including page usage, entry counts, and storage metrics for LMDB databases. |
| `target_difficulties.rs` | Target difficulty calculation utilities for Tari blockchain mining. Exports: TargetDifficulties struct and related functions for managing proof-of-work difficulty adjustments. Key functions: get_target_difficulty(), calculate_difficulty_at_heights(). Dependencies: BlockHeader, ConsensusManager, PowAlgorithm, TargetDifficultyWindow. Used by: mining difficulty adjustment, blockchain validation, consensus enforcement. Manages difficulty calculations for different proof-of-work algorithms across block heights. |
| `template_registation.rs` | Template registration entry storage structure for Tari blockchain code templates. Exports: TemplateRegistrationEntry struct containing CodeTemplateRegistration data. Dependencies: serde, tari_common_types, CodeTemplateRegistration. Used by: smart contract template registration, template storage and retrieval, validator node template management. Provides serializable storage format for registered code templates including registration data and metadata. |
| `utxo_mined_info.rs` | UTXO mining information data structures for Tari blockchain storage. Exports: OutputMinedInfo and InputSpentInfo structs tracking when outputs are mined and inputs are spent. Key fields: output, header_hash, mmr_position for OutputMinedInfo. Dependencies: serde, tari_common_types, TransactionInput, TransactionOutput. Used by: blockchain indexing, UTXO tracking, spent output detection. Provides comprehensive tracking of output lifecycle from mining to spending with block metadata. |

###### base_layer/core/src/chain_storage/lmdb_db/

| File | Description |
|------|-------------|
| `composite_key.rs` | Composite key builder for LMDB database operations in Tari blockchain storage. Exports: CompositeKey struct with generic length parameter for building complex multi-part database keys. Key methods: new(), try_from_parts(), append(), clear(). Dependencies: lmdb_zero, tari_common_types, tari_utilities. Used by: chain storage indexing operations that require compound keys for efficient querying. Implements LMDB byte conversion traits and provides safe key construction with length validation. |
| `cursors.rs` | LMDB cursor utilities for efficient database traversal and prefix-based searching in Tari blockchain storage. Exports: KeyPrefixCursor for iterating over keys with specific prefixes. Key methods: new(), next(), seek(), iterate(). Dependencies: lmdb_zero, serde, composite_key module. Used by: chain storage operations requiring efficient key iteration, range queries, and prefix-based data retrieval. Provides deserialization support and error handling for cursor operations. |
| `helpers.rs` | Serialization and deserialization helper functions for LMDB storage operations in Tari blockchain. Exports: serialize(), deserialize() functions with performance monitoring. Key features: bincode-based serialization, size hinting for optimization, timing measurements for large data structures. Dependencies: serde, bincode, tari_storage. Used by: all LMDB storage operations requiring data persistence. Includes logging for performance analysis and error handling for serialization failures. |
| `lmdb.rs` | LMDB database operations and low-level storage functions for Tari blockchain. Provides comprehensive CRUD operations including lmdb_insert, lmdb_replace, lmdb_delete, lmdb_get, and specialized functions for cursor operations, prefix searching, and bulk operations. Exports: all LMDB transaction functions. Dependencies: lmdb_zero, serde, tari_storage, tari_utilities. Used by: all blockchain data persistence operations. Includes error handling for storage full conditions, key conflicts, and transaction failures. |
| `lmdb_db.rs` | LMDB blockchain database implementation with comprehensive data storage and retrieval. Exports: LMDBDatabase struct implementing BlockchainBackend trait with 50+ methods for blockchain operations. Dependencies: lmdb-zero, JellyfishMerkleTree, tari_storage. Used by: blockchain database layer. Provides persistent storage for blocks, headers, transactions, UTXOs, and chain metadata with ACID properties, cursors, and transaction support. Includes migration capabilities and performance optimizations. |
| `lmdb_tree_reader.rs` | LMDB-backed tree reader implementing JMT (Jellyfish Merkle Tree) TreeReader trait for Tari blockchain storage. Exports: LmdbTreeReader struct for read operations on merkle trees stored in LMDB. Key methods: new(), get_node_option(), get_value_option(), get_rightmost_leaf(). Dependencies: jmt, lmdb_zero, borsh, tari_storage. Used by: merkle tree verification, state proofs, account state lookups. Provides efficient tree navigation and proof generation from LMDB storage backend. |
| `lmdb_tree_writer.rs` | LMDB-backed tree writer implementing JMT (Jellyfish Merkle Tree) TreeWriter trait for Tari blockchain storage. Exports: LmdbTreeWriter struct for write operations on merkle trees stored in LMDB. Key methods: new(), write_node_batch(), write_unique_keys_batch(), prune_stale_objects(). Dependencies: jmt, lmdb_zero, tari_storage, tari_utilities. Used by: merkle tree updates, state transitions, batch tree modifications. Provides efficient tree writing with transaction support and stale node cleanup. |
| `mod.rs` | LMDB database module entry point for Tari blockchain storage. Exports main database creation functions (create_lmdb_database, create_recovery_lmdb_database) and LMDBDatabase struct. Defines core data structures for transaction storage including TransactionOutputRowData, TransactionInputRowData, and TransactionKernelRowData. Contains hash domain definition for chain storage cryptographic operations. Used by: all blockchain storage operations. Dependencies: serde, tari_common_types, tari_crypto, transaction components. |
| `validator_node_store.rs` | Validator node storage implementation for managing validator node entries in the Tari blockchain LMDB database. Exports: ValidatorNodeStore struct with CRUD operations for validator nodes. Key methods: insert(), get(), delete(), get_shard_key(), exists(). Dependencies: lmdb_zero, tari_common_types, composite_key. Used by: validator node management, shard key operations, consensus mechanisms. Implements double indexing with validator node keys and shard ID mapping for efficient queries. |

###### base_layer/core/src/chain_storage/tests/

| File | Description |
|------|-------------|
| `blockchain_database.rs` | Comprehensive test suite for blockchain database operations. Contains test modules for: fetch_blocks (testing block retrieval by ranges), fetch_headers (header queries with various range patterns), find_headers_after_hash (hash-based header discovery), fetch_block_hashes_from_header_tip (reverse hash fetching), get_stats (database statistics), fetch_total_size_stats (storage size metrics), prepare_new_block (block template preparation), fetch_header_containing_kernel_mmr (MMR-based header lookup), clear_all_pending_headers (pending header cleanup), and validator_node_merkle_root (validator node set merkle root validation). Uses helper functions create_next_block(), apply_mmr_to_block(), and add_many_chained_blocks() for test data setup. Dependencies: BlockchainDatabase, TempDatabase, test_helpers. Test coverage includes genesis handling, range queries, boundary conditions, and MMR operations. |
| `mod.rs` | Test module aggregator for chain storage functionality. Exposes blockchain_database tests and temp_db utilities as public modules. Used by other test files to access shared testing infrastructure and database test suites. |
| `temp_db.rs` | Temporary LMDB database wrapper for testing. Provides TempLmdbDatabase struct with methods: new(), with_dbs(), default_db(), get_db(), write_transaction(), read_transaction(). Creates temporary database instances with configurable database names for isolated testing. Automatically cleans up temporary files on drop. Dependencies: lmdb_zero, tari_storage::lmdb_store, tari_test_utils. Used throughout chain storage tests for database isolation and cleanup. |

###### base_layer/core/src/common/

| File | Description |
|------|-------------|
| `borsh.rs` | Borsh serialization utilities for blockchain components. Defines traits: FromBytes (deserializes Borsh data from byte buffers using borsh_from_bytes()) and SerializedSize (calculates serialized size using get_serialized_size()). Uses ByteCounter for efficient size calculation without actual serialization. Dependencies: borsh serialization library, ByteCounter utility. Used by consensus encoding and storage systems for efficient binary serialization. |
| `byte_counter.rs` | Utility for counting bytes without actual data writes. Implements ByteCounter struct with methods: new(), get(). Implements std::io::Write trait by tracking byte counts instead of writing data. Used for calculating serialized data sizes efficiently without memory allocation. Dependencies: std::io. Used by borsh.rs and other serialization utilities for size calculations before actual serialization. |
| `mod.rs` | Common utilities and shared functionality for Tari blockchain core. Exports: various utility modules including borsh, byte_counter, one_sided, rolling_avg, rolling_vec, waiting_requests. Dependencies: blake2, tari_hashing, tari_max_size, DomainSeparatedConsensusHasher. Used by: core blockchain operations, shared utilities, common data structures. Provides foundational utilities used across the blockchain core including hash functions, data structures, and consensus helpers. |
| `one_sided.rs` | One-sided payment and stealth address cryptographic utilities. Defines domain-separated hash functions for: output encryption key generation (shared_secret_to_output_encryption_key(), secret_key_to_output_encryption_key(), public_key_to_output_encryption_key()), output spending key derivation (shared_secret_to_output_spending_key()), and stealth address hashing (diffie_hellman_stealth_domain_hasher()). Uses domain separation with WalletOutputEncryptionKeysDomain, WalletOutputRewindKeysDomain, and WalletOutputSpendingKeysDomain. Dependencies: blake2, tari_crypto, tari_hashing, tari_comms. Used by wallet and transaction systems for one-sided payment privacy features. |
| `rolling_avg.rs` | Rolling average calculator for time-based metrics. Implements RollingAverageTime struct with methods: new(), add_sample(), calc_samples_per_second(), calculate_average(), calculate_average_with_min_samples(). Uses RollingVec for efficient windowed storage of Duration samples. Provides statistical calculations for performance monitoring and network timing analysis. Dependencies: RollingVec, std::time. Used by network performance monitoring and timing analysis systems. |
| `rolling_vec.rs` | Fixed-capacity vector with rolling window behavior. Implements RollingVec<T> struct with methods: new(), push(), insert(), pop(), is_full(), capacity(), sort_unstable(). Automatically removes oldest elements when capacity is exceeded. Implements Deref to slice for transparent access and Extend trait for bulk operations. Optimized for performance monitoring and circular buffer use cases. Dependencies: std::ops. Used by RollingAverageTime and other performance monitoring utilities. |
| `waiting_requests.rs` | Asynchronous request tracking and response coordination. Defines WaitingRequests<T> struct for managing pending network requests with methods: new(), insert(), remove(). Associates RequestKey (u64) with oneshot channels and timestamps for timeout handling. Includes generate_request_key() function for creating unique request identifiers. Dependencies: tokio::sync, rand (base_node feature). Used by P2P networking layer for request-response correlation and timeout management. |

###### base_layer/core/src/consensus/

| File | Description |
|------|-------------|
| `chain_strength_comparer.rs` | Chain strength comparison algorithms for blockchain fork resolution. Defines ChainStrengthComparer trait and implementations: AccumulatedDifficultySquaredComparer (total difficulty), MoneroRandomxDifficultyComparer, TariRandomxDifficultyComparer, Sha3xDifficultyComparer (per-algorithm accumulated difficulty), HeightComparer (block height), ThenComparer (chained comparisons). Includes ChainStrengthComparerBuilder for composing comparison strategies. Function strongest_chain() provides builder entry point. Dependencies: ChainHeader, std::cmp. Used by blockchain validation and fork choice algorithms. |
| `consensus_constants.rs` | Network-specific consensus constants for blockchain operation. Exports: ConsensusConstants struct with mainnet(), stagenet(), nextnet(), localnet() configurations. Dependencies: emission schedule, proof of work, transaction weight. Used by: consensus manager, block validation, emission calculations. Contains critical blockchain parameters like block time targets, difficulty windows, emission curves, transaction weight limits, validator node settings, and proof-of-work algorithm configurations for each Tari network. |
| `consensus_encoding.rs` | Module aggregator for consensus encoding functionality. Re-exports DomainSeparatedConsensusHasher from hashing submodule. Entry point for consensus-level cryptographic hashing utilities used throughout the blockchain protocol. |
| `consensus_manager.rs` | Consensus manager for Tari blockchain providing network-specific consensus rules and constants. Exports: ConsensusManager, MaturityTranche. Key methods: new(), get_block_reward(), consensus_constants(), calculate_coinbase_and_fees(), chain_strength_comparer(). Dependencies: ConsensusConstants, NetworkConsensus, EmissionSchedule, ChainStrengthComparer. Used by: block validation, mining rewards, difficulty adjustment, transaction validation. Manages height-dependent consensus rules, emission schedules, and network-specific parameters. |
| `emission.rs` | Tari emission schedule implementation with exponential decay and tail inflation. Exports: EmissionSchedule struct implementing Emission trait with block_reward(), supply_at_block() methods. Dependencies: MicroMinotari amount types. Used by: consensus constants, block reward calculations. Implements Monero-style emission with integer math decay parameters, tail emission after decay phase, and inflation-based supply management. Includes decay_params() utility for precise floating-point to integer conversion. |
| `mod.rs` | Blockchain consensus rules and management for Tari protocol. Implements ConsensusConstants and ConsensusConstantsBuilder for network parameters, ConsensusManager for rule coordination across different networks, chain strength comparison for fork resolution, domain-separated consensus hashing for security, NetworkConsensus for network-specific rules, and emission schedule management. Provides consensus encoding utilities and manager builder with comprehensive error handling. Central coordination point for all blockchain consensus logic and network parameter management. |
| `network.rs` | Network consensus wrapper linking networks to consensus constants. Exports: NetworkConsensus struct with create_consensus_constants(), as_network() methods. Dependencies: Network enum, ConsensusConstants. Used by: consensus manager initialization. Maps Network types (MainNet, StageNet, NextNet, LocalNet, Igor, Esmeralda) to their corresponding consensus parameter sets. Provides type-safe network-to-consensus configuration binding. |

###### base_layer/core/src/consensus/consensus_encoding/

| File | Description |
|------|-------------|
| `hashing.rs` | Network-aware domain-separated consensus hashing. Implements DomainSeparatedConsensusHasher<M, D> wrapper around DomainSeparatedBorshHasher with network byte inclusion. Methods: new(), new_with_network(), finalize(), update_consensus_encode(), chain(). Automatically incorporates current network (MainNet, StageNet, etc.) into hash domain separation to prevent cross-network transaction replay attacks. Dependencies: borsh, tari_crypto::hashing, tari_common::configuration::Network. Used by consensus encoding systems for network-specific hashing. |

###### base_layer/core/src/covenants/

| File | Description |
|------|-------------|
| `arguments.rs` | Covenant argument types and serialization for Tari blockchain covenant system. Exports: CovenantArg enum with variants for different argument types including Hash, PublicKey, Commitment, Bytes, Uint. Key methods: to_bytes(), from_bytes(), require_hash(), require_commitment(). Dependencies: borsh, integer_encoding, tari_common_types. Used by: covenant evaluation, argument parsing, covenant validation. Provides type-safe argument handling for covenant operations with serialization support. |
| `byte_codes.rs` | Covenant bytecode definitions and validation for Tari blockchain covenant operations. Exports: byte code constants for arguments (ARG_HASH, ARG_PUBLIC_KEY, etc.) and filters (FILTER_IDENTITY, FILTER_AND, etc.). Key functions: is_valid_arg_code(), is_valid_filter_code(). Dependencies: none. Used by: covenant encoding/decoding, bytecode validation, covenant parsing. Defines the instruction set and validation rules for covenant bytecode operations ensuring proper covenant execution. |
| `context.rs` | Covenant execution context for evaluating covenant constraints in Tari blockchain. Exports: CovenantContext struct containing transaction inputs, outputs, and current output being evaluated. Key methods: new(), filter_outputs_by(), evaluate_covenant(). Dependencies: CovenantArg, CovenantError, CovenantFilter, CovenantToken, TransactionInput. Used by: covenant validation, transaction verification, output spending constraint checking. Provides runtime context for covenant evaluation with access to transaction data. |
| `covenant.rs` | Covenant implementation for UTXO spending restrictions. Exports: Covenant struct with execution(), to_bytes(), from_bytes(), push_opcode() methods. Dependencies: covenant filters, tokens, context, encoder/decoder. Used by: transaction outputs, UTXO validation. Implements covenant script execution with token-based operations, size limits (4096 bytes), and Borsh serialization. Enables programmable spending conditions on UTXOs per RFC-0250. |
| `decoder.rs` | Covenant bytecode decoder for parsing covenant binary data in Tari blockchain. Exports: CovenantDecoder struct and decoding functions for converting bytecode to covenant tokens. Key methods: decode(), parse_filter(), parse_argument(). Dependencies: byte_codes, arguments, filters, error types. Used by: covenant validation, transaction parsing, covenant deserialization. Provides robust parsing of covenant bytecode with comprehensive error handling and validation of covenant structure. |
| `encoder.rs` | Covenant bytecode encoder for serializing covenant tokens to binary format in Tari blockchain. Exports: CovenantEncoder struct and encoding functions for converting covenant tokens to bytecode. Key methods: encode(), write_filter(), write_argument(). Dependencies: byte_codes, arguments, filters. Used by: covenant creation, transaction building, covenant serialization. Provides efficient encoding of covenant structures to compact bytecode representation with proper formatting. |
| `error.rs` | Covenant error types and error handling for Tari blockchain covenant operations. Exports: CovenantError enum with variants for different covenant failure types including InvalidArgument, InvalidFilter, DecodingError, EncodingError. Dependencies: thiserror for error derivation. Used by: all covenant operations, error propagation, covenant validation failures. Provides comprehensive error handling for covenant parsing, validation, and execution with descriptive error messages. |
| `fields.rs` | Output field definitions and accessors for Tari blockchain covenant system. Exports: OutputField enum defining accessible transaction output fields like commitment, script, features, sender_offset_public_key. Key methods: get_field_value(), field_hash(). Dependencies: tari_crypto, transaction components. Used by: covenant evaluation, field access validation, output field retrieval. Provides type-safe access to transaction output fields for covenant constraint checking. |
| `macros.rs` | Utility macros for covenant development and code generation in Tari blockchain covenant system. Exports: covenant-related macros for reducing boilerplate code and ensuring consistent implementation patterns. Dependencies: covenant core types and traits. Used by: covenant filter implementations, covenant builders, repetitive covenant code patterns. Provides convenient macros for common covenant operations and reduces code duplication across covenant implementations. |
| `mod.rs` | Covenants module for Tari blockchain providing rules that restrict future spending of transactions. Implements RFC-0250 covenant specification allowing output spending conditions. Exports: Covenant, CovenantError, CovenantToken, OutputField. Dependencies: arguments, byte_codes, context, decoder, encoder, filters, output_set modules. Used by: transaction validation, output spending rules. Includes hash domain for covenant cryptographic operations and field hasher for covenant data integrity. |
| `output_set.rs` | Output set management for covenant evaluation in Tari blockchain. Exports: OutputSet struct managing collections of transaction outputs for covenant processing. Key methods: new(), add_output(), filter_outputs(), apply_covenant(). Dependencies: transaction output types, covenant evaluation context. Used by: covenant evaluation, output filtering, multi-output constraints. Provides efficient management and filtering of output collections during covenant constraint evaluation. |
| `serde.rs` | Serialization and deserialization support for covenant types in Tari blockchain. Exports: custom serde implementations for covenant types ensuring proper serialization format. Dependencies: serde framework, covenant core types. Used by: covenant persistence, network transmission, covenant storage. Provides custom serialization logic for covenant types that require special handling beyond standard serde derivations. |
| `test.rs` | Comprehensive test suite for covenant functionality in Tari blockchain. Exports: test functions for covenant encoding, decoding, validation, and execution. Dependencies: covenant core types, test utilities, transaction components. Used by: covenant testing, validation verification, regression testing. Provides extensive test coverage for covenant operations including edge cases, error conditions, and integration scenarios with transaction processing. |
| `token.rs` | Covenant token types and collection management for Tari blockchain covenant system. Exports: CovenantToken enum, CovenantTokenCollection struct for managing covenant token sequences. Key methods: new(), add_token(), evaluate(), serialize(). Dependencies: covenant arguments, filters, serialization support. Used by: covenant parsing, token sequence management, covenant evaluation. Provides structured representation of covenant programs as token sequences with validation and execution support. |

###### base_layer/core/src/covenants/filters/

| File | Description |
|------|-------------|
| `absolute_height.rs` | Absolute height covenant filter for enforcing minimum block height constraints in Tari blockchain. Exports: AbsoluteHeightFilter implementing CovenantFilter trait for height-based restrictions. Key methods: filter(), with_height(). Dependencies: CovenantFilter trait, block height utilities. Used by: time-locked transactions, height-based covenant constraints, transaction maturity enforcement. Ensures outputs can only be spent after reaching specified absolute block height. |
| `and.rs` | Logical AND covenant filter for combining multiple covenant constraints in Tari blockchain. Exports: AndFilter implementing CovenantFilter trait for conjunction operations. Key methods: filter(), with_filters(). Dependencies: CovenantFilter trait, sub-filters. Used by: complex covenant logic, multi-condition constraints, composite covenant rules. Requires all sub-filters to pass for the covenant constraint to be satisfied, enabling complex spending conditions. |
| `field_eq.rs` | Field equality covenant filter for enforcing specific field value constraints in Tari blockchain. Exports: FieldEqFilter implementing CovenantFilter trait for exact field matching. Key methods: filter(), with_field_and_value(). Dependencies: CovenantFilter trait, OutputField, field value types. Used by: field value constraints, exact match requirements, output field validation. Ensures specified output fields match exact values as defined in the covenant constraint. |
| `fields_hashed_eq.rs` | Hashed fields equality covenant filter for enforcing field hash constraints in Tari blockchain. Exports: FieldsHashedEqFilter implementing CovenantFilter trait for hash-based field validation. Key methods: filter(), with_fields_and_hash(). Dependencies: CovenantFilter trait, OutputField, hash functions. Used by: privacy-preserving field constraints, hash-based validation, field integrity checks. Validates that specified output fields hash to expected values without revealing actual field contents. |
| `fields_preserved.rs` | Fields preserved covenant filter for ensuring specific fields remain unchanged in Tari blockchain. Exports: FieldsPreservedFilter implementing CovenantFilter trait for field preservation constraints. Key methods: filter(), with_preserved_fields(). Dependencies: CovenantFilter trait, OutputField. Used by: field preservation requirements, immutability constraints, value conservation rules. Ensures specified output fields maintain identical values between input and output transactions during spending. |
| `filter.rs` | Base covenant filter trait and common functionality for Tari blockchain covenant system. Exports: CovenantFilter trait defining standard filter interface. Key methods: filter(), apply_filter(), validate_context(). Dependencies: covenant context, error types. Used by: all covenant filter implementations, filter composition, covenant evaluation engine. Provides standard interface for implementing various types of covenant constraints with consistent error handling and validation. |
| `identity.rs` | Identity covenant filter providing pass-through functionality for Tari blockchain covenant system. Exports: IdentityFilter implementing CovenantFilter trait as no-op filter. Key methods: filter() returning always true. Dependencies: CovenantFilter trait. Used by: default covenant behavior, filter composition, covenant testing. Acts as a null filter that allows all transactions to pass, useful for default cases and filter chain composition. |
| `mod.rs` | Covenant filters module entry point providing constraint filtering functionality for Tari blockchain covenants. Exports: CovenantFilter trait, specific filter implementations (absolute_height, and, field_eq, fields_hashed_eq, etc.). Dependencies: sub-modules for each filter type. Used by: covenant evaluation, constraint checking, output filtering. Provides modular filter system for implementing various covenant constraints and conditions on transaction outputs. |
| `not.rs` | Logical NOT covenant filter for negating covenant constraints in Tari blockchain. Exports: NotFilter implementing CovenantFilter trait for negation operations. Key methods: filter(), with_inner_filter(). Dependencies: CovenantFilter trait, inner filter. Used by: negative constraints, exclusion rules, inverted covenant logic. Reverses the result of its inner filter, allowing for negative constraints and exclusion-based covenant rules. |
| `or.rs` | Logical OR covenant filter for alternative covenant constraints in Tari blockchain. Exports: OrFilter implementing CovenantFilter trait for disjunction operations. Key methods: filter(), with_filters(). Dependencies: CovenantFilter trait, sub-filters. Used by: alternative constraints, multiple choice conditions, flexible covenant rules. Requires any of the sub-filters to pass for the covenant constraint to be satisfied, enabling flexible spending conditions. |
| `output_hash_eq.rs` | Output hash equality covenant filter for enforcing specific output hash constraints in Tari blockchain. Exports: OutputHashEqFilter implementing CovenantFilter trait for output hash validation. Key methods: filter(), with_expected_hash(). Dependencies: CovenantFilter trait, hash functions, output types. Used by: output integrity verification, hash-based constraints, output validation. Ensures transaction outputs match expected hash values for security and validation purposes. |
| `test.rs` | Test utilities and test cases for covenant filters in Tari blockchain. Exports: test helper functions, mock implementations, and test scenarios for covenant filter validation. Dependencies: covenant filter implementations, test framework utilities. Used by: covenant filter testing, validation testing, filter behavior verification. Provides comprehensive test coverage for all covenant filter types ensuring correct behavior and edge case handling. |
| `xor.rs` | Logical XOR covenant filter for exclusive-or covenant constraints in Tari blockchain. Exports: XorFilter implementing CovenantFilter trait for exclusive disjunction operations. Key methods: filter(), with_filters(). Dependencies: CovenantFilter trait, sub-filters. Used by: exclusive choice constraints, mutually exclusive conditions, either-or covenant rules. Requires exactly one of the sub-filters to pass, enabling exclusive choice constraints in covenant logic. |

###### base_layer/core/src/iterators/

| File | Description |
|------|-------------|
| `chunk.rs` | Chunk iterator utilities for processing data in fixed-size chunks in Tari blockchain. Exports: ChunkIterator and related chunking functionality for efficient batch processing. Dependencies: standard library iterator traits. Used by: batch processing operations, database queries, memory-efficient data processing. Provides utilities for breaking large datasets into manageable chunks for processing without memory overflow. |
| `mod.rs` | Iterator utilities module providing specialized iterator implementations for Tari blockchain operations. Exports: custom iterator types and utilities including chunk iterators and data processing helpers. Dependencies: chunk module and other iterator utilities. Used by: data processing, batch operations, efficient traversal of blockchain data structures. Provides foundational iterator utilities for efficient data processing throughout the blockchain core. |

###### base_layer/core/src/mempool/

| File | Description |
|------|-------------|
| `config.rs` | Mempool configuration structure for Tari blockchain mempool settings. Exports: MempoolConfig struct with settings for unconfirmed pool, reorg pool, and mempool behavior. Key fields: unconfirmed_pool, reorg_pool, weight_tx_skip_count. Dependencies: serde, tari_common, ReorgPoolConfig, UnconfirmedPoolConfig. Used by: mempool initialization, node configuration, pool size management. Implements Default trait and SubConfigPath for configuration management and validation. |
| `error.rs` | Mempool error types and error handling for Tari blockchain mempool operations. Exports: MempoolError enum with variants for different failure types including InternalError, TransactionValidationError, BannedTransaction, RwLockPoisonError. Dependencies: thiserror, tokio, tari_service_framework, UnconfirmedPoolError, TransactionError. Used by: all mempool operations, error propagation, transaction validation failures. Provides comprehensive error handling for mempool transaction management and validation. |
| `mempool.rs` | Main mempool implementation managing unconfirmed transactions in the Tari blockchain. Exports: Mempool struct with async transaction management methods. Key methods: insert(), insert_all(), process_published_block(), process_reorg(), retrieve(), snapshot(). Dependencies: MempoolStorage, ConsensusManager, TransactionValidator. Used by: node transaction processing, block creation, reorg handling. Provides thread-safe access to transaction pools with RwLock and async task spawning for concurrent operations. |
| `mempool_storage.rs` | Core mempool storage implementation managing unconfirmed and reorg transaction pools. Exports: MempoolStorage struct with insert(), process_published_block(), retrieve_by_excess_sig() methods. Dependencies: UnconfirmedPool, ReorgPool, TransactionValidator, ConsensusManager. Used by: Mempool wrapper, base node. Handles transaction validation, fee checking, pool management, block processing, and reorg handling. Maintains transaction state across blockchain reorganizations with comprehensive statistics and retrieval operations. |
| `metrics.rs` | Prometheus metrics definitions for mempool monitoring. Provides metric functions: inbound_transactions() (IntCounter for valid inbound transactions), rejected_inbound_transactions() (IntCounter for rejected transactions), unconfirmed_pool_size() (IntGauge for unconfirmed transaction count), reorg_pool_size() (IntGauge for reorg pool transaction count). Uses lazy static initialization for metric registration. Dependencies: once_cell, tari_metrics. Used by mempool services for operational monitoring and observability. |
| `mod.rs` | Transaction memory pool management for Tari base node implementing transaction queuing and validation before block inclusion. Provides Mempool for transaction storage, unconfirmed pool for pending transactions, reorg pool for reorganization handling, priority management for transaction ordering, and comprehensive RPC service (MempoolRpcService). Includes mempool configuration, synchronization protocols, transaction storage responses (TxStorageResponse), fee statistics (FeePerGramStat), and metrics collection. Features memory management with shrink hashmap optimization and mempool service initialization for base node integration. |
| `shrink_hashmap.rs` | Memory optimization utility for HashMap shrinking. Provides shrink_hashmap function that reduces HashMap capacity when it has more than 100 unused slots, maintaining a buffer of 100 extra capacity for efficient growth. Returns old and new capacity for monitoring. Used by mempool components to reduce memory footprint during periods of low transaction volume. |

###### base_layer/core/src/mempool/priority/

| File | Description |
|------|-------------|
| `mod.rs` | Module aggregator for transaction priority functionality. Re-exports FeePriority and PrioritizedTransaction from prioritized_transaction submodule. Entry point for mempool transaction prioritization logic used in transaction ordering and selection. |
| `prioritized_transaction.rs` | Transaction prioritization system for mempool ordering. Defines FeePriority struct with priority calculation based on fee-per-byte, transaction age, and signature uniqueness. PrioritizedTransaction wraps transactions with calculated priority, weight, and dependency information. Methods: FeePriority::new(), PrioritizedTransaction::new(). Uses big-endian encoding for consistent ordering in BTreeMap structures. Dependencies: Transaction, TransactionWeight, SystemTime. Used by mempool for transaction selection and ordering based on economic incentives and fairness. |

###### base_layer/core/src/mempool/proto/

| File | Description |
|------|-------------|
| `mod.rs` | Module aggregator for mempool protocol buffer conversions. Re-exports protocol buffer types: InventoryIndexes, TransactionInventory, TransactionItem from the generated protobuf code. Includes conversion implementations in submodules: state_response, stats_response, sync_protocol, tx_storage_response. Entry point for mempool network protocol serialization and deserialization. |
| `state_response.proto` | Protobuf message definition for mempool state responses. Defines StateResponse message containing lists of transactions in the unconfirmed pool and transaction signatures in the reorg pool. Used by mempool RPC services for broadcasting current mempool state. Imports transaction.proto and types.proto for message dependencies. |
| `state_response.rs` | Protocol buffer conversion implementations for mempool state responses. Implements bidirectional TryFrom/TryInto conversions between StateResponse and ProtoStateResponse structures. Handles conversion of unconfirmed_pool (transactions) and reorg_pool (signature data) collections with proper error handling for malformed data. Dependencies: std::convert, Arc wrapping. Used by mempool synchronization protocol for network state transfer. |
| `stats_response.proto` | Protobuf message definition for mempool statistics responses. Defines StatsResponse message with counters for unconfirmed transactions, reorg transactions, and unconfirmed weight. Used by mempool RPC services to provide metrics about current mempool state and capacity utilization. |
| `stats_response.rs` | Protocol buffer conversion implementations for mempool statistics. Implements bidirectional TryFrom/From conversions between StatsResponse and ProtoStatsResponse. Converts mempool metrics: unconfirmed_txs (count), reorg_txs (count), unconfirmed_weight (total weight). Dependencies: std::convert. Used by mempool RPC services for providing operational statistics to clients and monitoring systems. |
| `sync_protocol.proto` | Protobuf message definitions for mempool synchronization protocol. Defines TransactionInventory (list of kernel excess signatures for transaction identification), TransactionItem (wrapped transaction), and InventoryIndexes (list of indexes). Used for peer-to-peer mempool synchronization to identify and request missing transactions between nodes. |
| `sync_protocol.rs` | Protocol buffer utility implementations for mempool synchronization. Provides convenience method empty() for TransactionItem to create empty transaction items in sync protocols. Used by mempool synchronization logic for handling empty or missing transaction data in network communication. |
| `tx_storage_response.proto` | Protobuf enum and message definitions for transaction storage responses. Defines TxStorageResponse enum with values for unconfirmed pool, reorg pool, not stored, and none states. Contains TxStorage message wrapper. Used by mempool RPC services to indicate where a transaction is stored or if it's not found. |
| `tx_storage_response.rs` | Protocol buffer conversion implementations for transaction storage status. Implements bidirectional conversions between TxStorageResponse and proto equivalents. Handles storage states: UnconfirmedPool, ReorgPool, NotStored, NotStoredOrphan, NotStoredTimeLocked, NotStoredAlreadySpent, NotStoredConsensus, NotStoredAlreadyMined, NotStoredFeeTooLow. Maps various rejection reasons to generic NotStored for protocol simplicity. Dependencies: std::convert. Used by mempool services to communicate transaction acceptance/rejection status. |

###### base_layer/core/src/mempool/reorg_pool/

| File | Description |
|------|-------------|
| `mod.rs` | Module definition for blockchain reorganization pool. Exports ReorgPool and ReorgPoolConfig from the reorg_pool submodule. The reorg pool stores transactions that were recently added to blocks to handle blockchain reorganizations by recovering and re-adding transactions when blocks are removed during reorgs. |
| `reorg_pool.rs` | Core implementation of blockchain reorganization pool for transaction recovery. Contains ReorgPool struct that stores transactions from recently mined blocks indexed by signatures and height. Provides methods for inserting transactions, retrieving by excess signatures, removing double-spends, and handling blockchain reorganizations. Key features: automatic expiry by height, duplicate prevention, efficient lookup by signature, comprehensive test suite. Used by mempool service during chain reorg events to recover transactions for re-submission. |

###### base_layer/core/src/mempool/rpc/

| File | Description |
|------|-------------|
| `mod.rs` | RPC interface definitions for mempool services. Exports MempoolRpcService and defines the MempoolService trait with methods for getting stats, state, transaction status, and submitting transactions. Uses tari_rpc macro to generate RPC server and client structs. Provides factory function create_mempool_rpc_service() for service instantiation. Central interface for all mempool remote procedure calls. |
| `service.rs` | Implementation of mempool RPC service methods. Contains MempoolRpcService struct that wraps MempoolHandle and implements the MempoolService trait. Provides async methods for getting mempool statistics, state, transaction status by signature, and submitting transactions. Handles protocol buffer conversions and error mapping. Includes comprehensive logging and error handling for RPC operations. |
| `test.rs` | Unit tests for mempool RPC service functionality. Contains test modules for get_stats, get_state, get_tx_state_by_excess_sig, and submit_transaction RPC methods. Uses mock services and request mocks to test proper response handling, error cases, and invalid input validation. Ensures RPC service correctly converts between protobuf and internal types and handles both success and error scenarios. |

###### base_layer/core/src/mempool/service/

| File | Description |
|------|-------------|
| `error.rs` | Error type definitions for mempool service operations. Defines MempoolServiceError enum covering DHT outbound errors, invalid requests/responses, timeouts, bootstrap configuration issues, transport channel errors, and mempool-specific errors. Uses thiserror for error derivation and includes conversion traits from underlying error types. Central error handling for all mempool service communication and operations. |
| `handle.rs` | Handle interface for mempool service communication. Contains MempoolHandle struct wrapping TrySenderService for making requests to mempool service. Provides async methods for getting stats, state, transaction status by signature, submitting transactions, and retrieving fee-per-gram statistics. Acts as client-side interface for all mempool operations with proper error handling and response type conversion. |
| `inbound_handlers.rs` | Inbound message handlers for mempool service requests and events. Contains MempoolInboundHandlers that processes remote/local mempool requests, handles transaction submissions with propagation, manages block events (validation, reorg, sync), and maintains metrics. Key functionality includes transaction validation, duplicate detection, network propagation, and blockchain reorganization handling. Central orchestrator for all inbound mempool communications. |
| `initializer.rs` | Service initializer for mempool service infrastructure. Implements ServiceInitializer trait to set up mempool service with inbound transaction streams, request/response channels, outbound interfaces, and block event handling. Creates MempoolService with all required streams and handlers, registers service handles, and manages service lifecycle. Critical component for mempool service startup and integration with the broader node architecture. |
| `local_service.rs` | Local interface for mempool service communication. Contains LocalMempoolService providing async methods for local clients to interact with mempool without going through network layer. Supports getting stats/state, submitting transactions, and querying transaction status. Includes comprehensive test coverage for single and multiple service instances. Provides type-safe, ergonomic API for internal mempool access. |
| `mod.rs` | Module organization for mempool service components. Conditionally exports service implementations based on base_node feature flag. Exports error types, service initializer, local service, outbound interface, main service, request/response types, and handle. Central aggregation point for all mempool service functionality including error handling, initialization, and communication interfaces. |
| `outbound_interface.rs` | Outbound interface for mempool service communication. Contains OutboundMempoolServiceInterface that wraps an unbounded sender channel for propagating transactions to remote nodes. Provides async propagate_tx method that sends transactions while excluding specified peers to prevent broadcast loops. Simple but critical component for transaction dissemination across the Tari network. |
| `request.rs` | Request message types for mempool service communication. Defines MempoolRequest enum with variants for getting stats/state, transaction status lookup by signature, transaction submission, and fee statistics. Includes MempoolServiceRequest wrapper with request keys for tracking. Implements Display trait for debugging and logging. Foundation for all mempool service request handling. |
| `response.rs` | Response message types for mempool service communication. Defines MempoolResponse enum with variants for stats, state, transaction storage status, and fee statistics. Includes MempoolServiceResponse wrapper with request keys for correlation. Implements Display trait for debugging and logging. Companion to request types for complete mempool service communication protocol. |
| `service.rs` | Main mempool service orchestrator handling all service streams and communication. Contains MempoolService that manages inbound/outbound message handling, local requests, block events, and transaction propagation. Uses tokio::select! for concurrent stream processing. Key functionality includes transaction validation, network propagation, blockchain event handling, and service coordination. Central hub for all mempool service operations. |

###### base_layer/core/src/mempool/sync_protocol/

| File | Description |
|------|-------------|
| `error.rs` | Error types for mempool synchronization protocol. Defines MempoolProtocolError enum covering excess signature validation, substream management, message encoding/decoding, timeouts, and protocol conversion errors. Uses thiserror for error derivation and includes peer identification for debugging. Essential for robust error handling during peer-to-peer mempool synchronization operations. |
| `initializer.rs` | Service initializer for mempool synchronization protocol. Contains MempoolSyncInitializer that sets up protocol extension, waits for initial node sync completion, and spawns the MempoolSyncProtocol service. Manages protocol notification channels and coordinates with connectivity service. Critical component for enabling peer-to-peer mempool synchronization during node startup and operation. |
| `mod.rs` | Complete peer-to-peer mempool synchronization protocol implementation. Contains MempoolSyncProtocol orchestrating initiator/responder flows, MempoolPeerProtocol handling individual peer communication, and comprehensive protocol documentation. Features transaction inventory exchange, missing transaction resolution, duplicate prevention, and metrics collection. Core component for maintaining mempool consistency across the Tari network through efficient peer synchronization. |
| `test.rs` | Integration tests for mempool synchronization protocol between peer nodes. Tests the MempoolSyncProtocol and MempoolPeerProtocol components with scenarios including empty sets, transaction synchronization, duplicate handling, and protocol message exchange. Key test functions: empty_set(), synchronise(), duplicate_set(), responder(), initiator_messages(), responder_messages(). Uses mock connectivity, memory sockets, and test transaction creation. Dependencies: tari_comms, tokio, futures. Related: mempool sync_protocol module, transaction components. |

###### base_layer/core/src/mempool/test_utils/

| File | Description |
|------|-------------|
| `mock.rs` | Mock implementation for mempool service testing. Contains MempoolServiceMock with configurable responses for all mempool operations, MempoolMockState for setting test data, and factory function for creating mock service handles. Provides call counting and async response configuration. Essential testing utility for unit tests requiring mempool service simulation without real mempool functionality. |
| `mod.rs` | Module organization for mempool testing utilities. Exports mock module containing mock service implementations for testing mempool functionality. Simple module aggregation point for all mempool test utilities and helper functions. |

###### base_layer/core/src/mempool/unconfirmed_pool/

| File | Description |
|------|-------------|
| `error.rs` | Error types for the unconfirmed transaction pool module. Defines UnconfirmedPoolError enum with variants: StorageOutofSync, InternalError, TransactionNoKernels, TransactionError. Includes get_ban_reason() method for peer banning logic with BanReason and BanPeriod. Uses thiserror for error handling. Dependencies: common::BanPeriod/BanReason, TransactionError. Used by: unconfirmed pool operations for error handling and peer management. |
| `mod.rs` | Module definition and public re-exports for the unconfirmed transaction pool. Exports: UnconfirmedPoolError, UnconfirmedPool, UnconfirmedPoolConfig, RetrieveResults, TransactionKey. Defines hash domain UnconfirmedPoolOutputTokenIdHashDomain for output token ID hashing. Dependencies: tari_crypto::hash_domain. Used by: mempool for managing unconfirmed transactions before block inclusion. |
| `unconfirmed_pool.rs` | Core implementation of unconfirmed transaction pool with prioritization and validation. Contains UnconfirmedPool managing pending transactions using BTreeMap for priority ordering, HashMap for fast lookups, and comprehensive validation logic. Features fee-based prioritization, duplicate detection, double-spend prevention, transaction weight limits, and efficient insertion/removal. Includes transaction aging, memory optimization, and comprehensive statistics collection. Central component for mempool transaction management and mining prioritization. |

###### base_layer/core/src/proof_of_work/

| File | Description |
|------|-------------|
| `accumulated_difficulty.rs` | Accumulated difficulty representation for blockchain consensus. Defines AccumulatedDifficulty struct (u128 wrapper) with methods: from_u128(), as_u128(), min(), max(), checked_add_difficulty(), checked_sub_difficulty(), to_be_bytes(). Enforces minimum difficulty constraints and provides overflow-safe arithmetic operations. Dependencies: Difficulty, DifficultyError. Used by chain strength calculation and blockchain validation for cumulative work measurement. |
| `difficulty.rs` | Core difficulty representation and calculation utilities. Defines Difficulty struct (u64 wrapper) with methods: from_u64(), as_u64(), min(), max(), big_endian_difficulty(), little_endian_difficulty(), checked_div_u64(). Includes DifficultyAdjustment trait for difficulty retargeting algorithms. Uses MIN_DIFFICULTY constant (1) and U256 arithmetic for hash-to-difficulty conversion. Dependencies: primitive_types::U256, borsh, serde. Used throughout proof-of-work system for target difficulty management and hash validation. |
| `error.rs` | Error types for proof-of-work validation and difficulty adjustment. Defines PowError (InvalidProofOfWork, AchievedDifficultyBelowMin, Sha3HeaderNonEmptyPowBytes, RandomxTPowDataTooLong, AchievedDifficultyTooLow, InvalidTargetDifficulty, MergeMineError), DifficultyAdjustmentError (DecreasingAccumulatedDifficulty, Other), and DifficultyError (InvalidDifficulty, MaxBlockTimeOverflow, DivideByZero, Overflow). Includes ban reason logic for network peer management. Dependencies: thiserror, BanPeriod, BanReason. Used by consensus validation and peer management systems. |
| `lwma_diff.rs` | Linear Weighted Moving Average difficulty adjustment algorithm implementation. Defines LinearWeightedMovingAverage struct with methods: new(), add_front(), add_back(), calculate(), is_full(), num_samples(), update_target_time(). Implements DifficultyAdjustment trait. Uses LWMA_MAX_BLOCK_TIME_RATIO (6) for time clamping and VecDeque for efficient windowed calculations. Prevents negative solve times and handles overflow with u128 arithmetic. Dependencies: VecDeque, EpochTime, Difficulty. Used by consensus engine for adaptive difficulty retargeting based on recent block timing patterns. |
| `mod.rs` | Proof-of-work algorithms and difficulty management for Tari blockchain supporting hybrid mining. Implements Difficulty and AccumulatedDifficulty calculations, PowAlgorithm definitions for SHA3 and RandomX (Monero merge mining), LWMA (Linear Weighted Moving Average) difficulty adjustment, target difficulty windows, and RandomX factory for Monero compatibility. Includes difficulty adjustment algorithms, proof validation (ProofOfWork, PowData), and specialized implementations for sha3x_difficulty and monero_randomx_difficulty. Supports both standalone SHA3 mining and Monero merge mining protocols. |
| `proof_of_work.rs` | Proof-of-work data structure and utilities. Defines ProofOfWork struct with fields: pow_algo (PowAlgorithm), pow_data (PowData with size limit NOT_BEFORE_PROOF_BYTES_SIZE). Methods: new(), to_bytes(). Supports multiple mining algorithms (Sha3x, RandomX variants) with algorithm-specific auxiliary data. Dependencies: PowAlgorithm, MaxSizeBytes, borsh, serde. Used by block headers to store mining algorithm and supplemental proof data for validation. |
| `proof_of_work_algorithm.rs` | Enumeration of supported proof-of-work mining algorithms. Defines PowAlgorithm enum with variants: RandomXM (merge-mined Monero RandomX), Sha3x (standalone Tari SHA3), RandomXT (standalone Tari RandomX). Methods: is_merged_mined_randomx(), is_tari_randomx(), is_sha3(), as_u64(). Includes conversion traits: TryFrom<u64>, FromStr with multiple string variants, Display. Dependencies: borsh, serde, thiserror. Used throughout mining and validation systems to identify and handle different mining algorithms. |
| `randomx_factory.rs` | RandomX virtual machine factory and instance management. Implements RandomXFactory for creating and caching RandomX VMs with maximum capacity limits and LRU eviction. RandomXVMInstance wraps VM instances with thread-safe access for hash calculation. Features: automatic flag fallback on cache allocation failure, key-based VM caching, memory management (256MB per light-mode VM). Methods: create(), calculate_hash(), get_count(), get_flags(). Dependencies: randomx_rs, Arc, RwLock. Used by RandomX mining validation for efficient VM reuse and memory management. |
| `sha3x_pow.rs` | Tari Sha3X proof-of-work algorithm implementation. Implements triple Keccak SHA3-256 hash calculation as per RFC-0131. Functions: sha3x_difficulty() (calculates achieved difficulty), sha3_hash() (single SHA3), sha3x_difficulty_with_hash() (internal triple hash). Hashes nonce, mining hash, and PoW mode byte. Dependencies: sha3::Sha3_256, BlockHeader, Difficulty. Used for standalone Tari mining validation and testing on testnets. Includes reference miner implementation for testing. |
| `target_difficulty.rs` | Validated target difficulty achievement representation. Defines AchievedTargetDifficulty struct guaranteeing achieved difficulty meets or exceeds target. Methods: try_construct() (validates achievement before construction), achieved(), target(), pow_algo(). Immutable type-safe wrapper preventing invalid difficulty claims. Dependencies: Difficulty, PowAlgorithm. Used by consensus validation to represent verified proof-of-work achievements with algorithm context. |
| `target_difficulty_window.rs` | Windowed target difficulty calculation wrapper. Implements TargetDifficultyWindow struct wrapping LinearWeightedMovingAverage for difficulty retargeting. Methods: new(), add_back(), add_front(), is_full(), len(), is_empty(), calculate(), update_target_time(). Enforces min/max difficulty bounds using std::cmp. Dependencies: LinearWeightedMovingAverage, EpochTime, Difficulty. Used by consensus engine for difficulty adjustment based on historical block timing with configured minimum and maximum limits. |

###### base_layer/core/src/proof_of_work/monero_rx/

| File | Description |
|------|-------------|
| `error.rs` | Error types for Monero RandomX merge mining operations. Defines MergeMineError enum covering proof-of-work verification failures, difficulty calculation errors, merkle tree issues, serialization problems, and RandomX VM errors. Uses thiserror for error derivation and includes ban period recommendations for malicious behavior. Essential for robust error handling in Monero merge mining functionality. |
| `fixed_array.rs` | Fixed-size byte array implementation for RandomX operations with maximum 60-byte capacity. Defines FixedByteArray struct with Borsh serialization/deserialization, ByteArray trait implementation. Methods: new(), as_slice(), is_full(), len(), is_empty(), to_vec(). Includes safety checks for length validation and overflow protection. Dependencies: borsh, tari_utilities::ByteArray. Used by: RandomX proof-of-work components for fixed-size data structures. |
| `helpers.rs` | Helper functions for Monero RandomX merge mining operations. Provides utilities for constructing Monero data, creating block hashing blobs, auxiliary chain integration, difficulty calculations, header verification, and block serialization/deserialization. Includes comprehensive merkle tree operations and RandomX integration. Core utility functions supporting all Monero merge mining functionality in the Tari blockchain. |
| `merkle_tree.rs` | Port of Monero's tree hash algorithm and merkle proof system for merge mining. Key functions: tree_hash() for calculating merkle roots, create_merkle_proof() for generating proofs. Defines MerkleProof struct with path verification, coinbase validation, position calculation. Includes cn_fast_hash() using Keccak-256. Max tree depth: 32 levels. Dependencies: monero crate, integer_encoding, borsh. Used by: merge mining operations, block verification. Extensively tested with quickcheck and real Monero block data. |
| `merkle_tree_parameters.rs` | Merkle tree parameters for merge mining following P2Pool specification. Defines MerkleTreeParameters struct with number_of_chains and aux_nonce fields. Provides varint encoding/decoding with bit manipulation functions: from_varint(), to_varint(). Includes helper functions for bit encoding/decoding of chain count and nonce values. Dependencies: monero::VarInt, serde, thiserror. Used by: merge mining protocol for auxiliary chain configuration. Extensively tested with quickcheck property testing. |
| `mod.rs` | Module aggregation for Monero RandomX merge mining functionality. Exports MergeMineError, helper functions for Monero block construction and validation, FixedByteArray utility, MoneroPowData, merkle tree operations, and re-exports Monero consensus types. Provides comprehensive toolkit for Monero merge mining including block hashing, auxiliary chain integration, difficulty calculations, and header verification. |
| `pow_data.rs` | MoneroPowData structure for RandomX Monero merged mining proof-of-work. Contains serialization/deserialization logic for Monero block headers and merge mining data including RandomX VM key, transaction count, merkle proofs, and coinbase data. Exports: MoneroPowData struct with validation methods is_coinbase_valid_merkle_root(), to_blockhashing_blob(), randomx_key(). Dependencies: monero crate, tari_utilities, tiny_keccak, borsh serialization. Used by: Monero RandomX PoW verification system. Implements Borsh serialization for persistence and includes comprehensive test coverage for max size validation. |

###### base_layer/core/src/proto/

| File | Description |
|------|-------------|
| `block.proto` | Protobuf schema definitions for Tari blockchain blocks and related structures. Defines ProofOfWork (algorithm and supplemental data), BlockHeader (metadata, merkle roots, timestamps, nonce), Block (header + aggregate body), NewBlock (minimal propagation format), HistoricalBlock (with confirmations), and BlockHeaderAccumulatedData (difficulty tracking). Core protocol definitions for block structure, consensus, and network propagation in the Tari blockchain. |
| `block.rs` | Protocol buffer conversion implementations for blockchain blocks. Provides bidirectional TryFrom conversions between proto::Block/HistoricalBlock/NewBlock and native Rust types. Exports: TryFrom implementations for Block, HistoricalBlock, NewBlock, BlockHeaderAccumulatedData. Dependencies: proto definitions, block types, difficulty calculations. Used by: Network serialization, blockchain storage, block validation. Handles conversion of accumulated difficulty data with proper byte ordering and error handling for malformed data. |
| `block_header.rs` | Protocol buffer conversion implementations for blockchain block headers. Provides bidirectional conversions between proto::BlockHeader/ProofOfWork and native BlockHeader/ProofOfWork types. Exports: TryFrom conversions for BlockHeader and ProofOfWork. Dependencies: proto definitions, BlockHeader, ProofOfWork, FixedHash types. Used by: Network protocol, block header serialization, consensus validation. Handles conversion of timestamps, merkle roots, proof-of-work data, and validator node information with proper error handling. |
| `mod.rs` | Protocol buffer definitions and generated code imports for Tari core types and services. Includes auto-generated protobuf modules for base_node, core types, mempool, transaction_protocol, and general types from OUT_DIR during build. Provides transaction utilities, block definitions, block header structures, sidechain features, and type implementations. Central location for all protobuf-related functionality enabling gRPC communication and serialization across Tari components. Features conditional compilation for different protocol feature sets. |
| `sidechain_feature.proto` | Protocol buffer definition for sidechain feature types. Defines message structures for ValidatorNodeRegistration, TemplateRegistration, and ConfidentialOutputData. Exports: SideChainFeature oneof, ValidatorNodeRegistration, TemplateRegistration, ConfidentialOutputData, TemplateType variants (Wasm/Flow/Manifest), BuildInfo. Dependencies: types.proto. Used by: Sidechain functionality, validator node registration, template deployment, confidential transactions. Supports different template types (WASM, Flow, Manifest) and includes build information for reproducible deployments. |
| `sidechain_feature.rs` | Protocol buffer conversion implementations for sidechain features. Provides bidirectional conversions between proto sidechain types and native Rust transaction components. Exports: TryFrom conversions for SideChainFeature, ValidatorNodeRegistration, CodeTemplateRegistration, ConfidentialOutputData, TemplateType, BuildInfo. Dependencies: proto definitions, transaction components, MaxSizeString, CompressedPublicKey. Used by: Sidechain transaction processing, validator registration, template deployment. Handles conversion of public keys, signatures, template metadata, and build information with comprehensive error handling. |
| `transaction.proto` | Protocol buffer definitions for transaction structures in Tari blockchain. Defines core transaction components: TransactionKernel (excess, signatures, fees), TransactionInput (spending references), TransactionOutput (new ownership), OutputFeatures (UTXO metadata), AggregateBody (collection of inputs/outputs/kernels), and Transaction. Exports: TransactionKernel, TransactionInput, TransactionOutput, OutputFeatures, AggregateBody, Transaction messages. Dependencies: types.proto, sidechain_feature.proto. Used by: Network protocol, transaction serialization, blockchain validation. Implements Mimblewimble transaction structure with cut-through support. |
| `transaction.rs` | Protocol buffer conversion implementations for transaction components. Provides comprehensive bidirectional conversions between proto transaction types and native Rust structures. Exports: TryFrom conversions for TransactionKernel, TransactionInput, TransactionOutput, OutputFeatures, AggregateBody, Transaction. Dependencies: proto definitions, transaction components, range proofs, TariScript, encryption. Used by: Network serialization, transaction validation, blockchain storage. Handles both compact and full transaction input formats, encrypted data, range proofs, and script execution with extensive error handling. |
| `types.proto` | Core protobuf type definitions for Tari protocol. Defines fundamental types including HashOutput, Commitment, Signature, SignerSignature, ComAndPubSignature, PrivateKey, and RangeProof. Used throughout the protocol for cryptographic primitives, transaction components, and network communication. Foundation protobuf schema for all Tari blockchain data structures and cryptographic operations. |
| `types_impls.rs` | Protocol buffer type conversion implementations for Tari core types. Provides bidirectional conversion traits (TryFrom/From) between protobuf message types and internal Rust types. Exports: TryFrom/From implementations for Commitment, Signature, ComAndPubSignature, HashOutput, and PrivateKey. Dependencies: tari_common_types, tari_utilities, super::types (proto). Used by: components needing protobuf serialization/deserialization. Handles safe conversion with error handling for malformed data. |

###### base_layer/core/src/test_helpers/

| File | Description |
|------|-------------|
| `block_spec.rs` | Block specification system for test blockchain generation. Provides declarative DSL for creating test blocks with configurable properties. Exports: BlockSpec, BlockSpecs, block_spec!, block_specs! macros. Dependencies: proof_of_work::Difficulty, transaction components. Used by: integration tests, blockchain test builders. Features builder pattern with fluent API for specifying difficulty, rewards, parent relationships, and transactions. |
| `blockchain.rs` | Comprehensive blockchain testing utilities for creating test databases and blockchain instances. Provides helpers for creating temporary LMDB databases, test blockchains with custom consensus rules, and blockchain simulation. Exports: create_new_blockchain(), create_test_db(), TempDatabase, TestBlockchain, create_chained_blocks(), create_main_chain(), create_orphan_chain(). Dependencies: LMDB storage, consensus manager, validators, JellyfishMerkleTree for SMT. Used by: Unit tests, integration tests, blockchain validation testing. Includes sophisticated blockchain building with proper SMT updates and mining simulation. |
| `mod.rs` | Test helper utilities for blockchain and transaction testing. Provides common functions for creating test blocks, consensus rules, and peer management. Exports: create_consensus_rules(), create_orphan_block(), create_block(), mine_to_difficulty(), peer management utilities. Dependencies: blockchain components, consensus, crypto, peer management. Used throughout test suites for consistent test setup. Includes MMR application and test key generation utilities. |

###### base_layer/core/src/transactions/

| File | Description |
|------|-------------|
| `aggregated_body.rs` | Implementation of AggregateBody representing Mimblewimble transaction/block structure. Contains sorted collections of inputs, outputs, and kernels with methods for adding components, validation, fee calculation, coinbase checking, and UTXO rules enforcement. Supports blockchain reorganization, duplicate detection, weight calculation, and merkle root computation. Core component for both individual transactions and block construction in the Mimblewimble protocol. |
| `coinbase_builder.rs` | Builder for coinbase transactions with emission schedule and stealth address support. Contains CoinbaseBuilder supporting standard and stealth coinbase outputs, emission calculation, maturity enforcement, and one-sided payments. Handles validator node payments, burn outputs, and comprehensive fee validation. Critical component for block construction and mining reward distribution in the Tari blockchain. |
| `crypto_factories.rs` | Cryptographic factory wrapper for commitment and range proof services. Provides unified access to crypto operations with Arc-based sharing for efficient cloning. Exports: CryptoFactories struct with commitment and range_proof factories. Dependencies: tari_common_types commitment/range proof services. Used by: transaction validation, proof generation/verification. Encapsulates factory initialization with configurable range proof bit length. |
| `fee.rs` | Transaction fee calculation wrapper around TransactionWeight. Defines Fee struct containing TransactionWeight for fee computation. Key methods: calculate() for computing absolute fees given fee-per-gram rate and transaction components, calculate_body() for AggregateBody fee calculation. Uses saturating multiplication to prevent overflow. Dependencies: MicroMinotari, TransactionWeight, AggregateBody. Used by: transaction validation, mempool, wallet for fee estimation and verification. |
| `format_currency.rs` | Currency formatting utility for adding thousand separators to numeric strings. Single function format_currency() that takes a string value and separator character, returns formatted string with separators every 3 digits in the whole number part. Preserves decimal places. Used by: tari_amount display methods, UI components for user-friendly currency display. Example: "12345.67" becomes "12,345.67" with comma separator. |
| `mod.rs` | Core transaction processing module for Tari blockchain. Exports CryptoFactories for cryptographic operations, CoinbaseBuilder for creating coinbase transactions, fee calculation utilities, TariAmount for currency handling, transaction components (inputs, outputs, kernels), and transaction protocols for sender/receiver interactions. Includes aggregated body functionality for transaction batching, currency formatting utilities, transaction weight calculations, and key management. Provides test helpers for transaction-related testing when base_node feature is enabled. |
| `tari_amount.rs` | Core currency amount types for Tari blockchain. Defines MicroMinotari (base unit, µT) and Minotari (full unit, T) with conversion rate 1 T = 1,000,000 µT. Implements arithmetic operations, checked math, currency formatting, string parsing. Constants: uT = 1 µT, T = 1,000,000 µT. Dependencies: decimal_rs, newtype_ops, borsh, serde, tari_crypto. Used throughout: transaction values, fee calculations, wallet operations. Provides safe amount handling with overflow protection and precision control. |
| `test_helpers.rs` | Comprehensive transaction testing utilities and builders. Provides test parameter generation, UTXO creation, transaction schemas, and wallet output builders. Exports: TestParams, UtxoTestParams, TransactionSchema, create_tx(), spend_utxos(), tx! macro, txn_schema! macro. Dependencies: key management, crypto, script execution, transaction components. Used by: transaction tests, wallet tests. Features include random signature generation, coinbase creation, and transaction protocol building. |
| `weight.rs` | Transaction weight calculation system for fee computation. Defines WeightParams with component weights (kernel: 10g, input: 8g, output: 53g, features/scripts: 16 bytes/gram) and TransactionWeight wrapper. Key methods: calculate() for weight computation, calculate_body() for AggregateBody weight, round_up_features_and_scripts_size() for proper rounding. Excludes coinbase outputs/kernels from weight calculations. Dependencies: AggregateBody, NonZeroU64. Used by: fee calculation, transaction validation, block weight limits. |

###### base_layer/core/src/transactions/transaction_components/

| File | Description |
|------|-------------|
| `encrypted_data.rs` | Encrypted data implementation using XChaCha20-Poly1305 encryption for transaction values and payment metadata. Provides secure encryption/decryption of UTXO values, masks, and payment IDs with transaction type classification. Exports: EncryptedData struct with encrypt_data()/decrypt_data(), PaymentId enum (Empty/U256/Open/AddressAndData/TransactionInfo), TxType enum for transaction categorization. Dependencies: XChaCha20Poly1305, Blake2b, TariAddress, MicroMinotari, MaxSizeBytes. Used by: Transaction outputs, UTXO value encryption, payment tracking. Supports various payment ID formats with proper serialization and secure nonce generation. |
| `error.rs` | Error handling for transaction components with comprehensive error variants. Defines TransactionError enum covering builder errors, serialization failures, signature validation, range proof errors, script execution, and wallet integration. Exports: TransactionError enum with From trait implementations. Dependencies: ScriptError, RangeProofError, KeyManagerServiceError, EncryptedDataError, LedgerDeviceError. Used by: All transaction-related operations throughout the codebase. Provides structured error handling with proper error propagation from cryptographic operations, hardware wallets, and blockchain validation. |
| `kernel_builder.rs` | Builder pattern implementation for constructing TransactionKernel objects. Provides fluent API for building kernels with features, fees, lock heights, excess commitments, signatures, and burn commitments. Exports: KernelBuilder struct with builder methods with_features(), with_fee(), with_lock_height(), with_excess(), with_signature(), with_burn_commitment(), build(). Dependencies: TransactionKernel, KernelFeatures, MicroMinotari, CompressedCommitment. Used by: Transaction construction, kernel creation, testing. Validates that required fields (excess and signature) are provided before building. |
| `kernel_features.rs` | Bitflags-based feature flags for transaction kernels. Defines KernelFeatures with COINBASE_KERNEL and BURN_KERNEL flags to distinguish kernel types and enforce different validation rules. Exports: KernelFeatures struct with create_coinbase(), create_burn(), is_burned(), is_coinbase() methods. Dependencies: bitflags crate, borsh/serde serialization. Used by: Transaction kernels, kernel validation, consensus rules. Provides type-safe kernel classification with efficient bitwise operations and comprehensive validation testing. |
| `kernel_sum.rs` | Simple data structure for aggregating transaction kernel commitments and fees. Contains KernelSum struct with commitment sum and total fees for efficient kernel validation and fee calculation. Exports: KernelSum struct with sum (CompressedCommitment) and fees (MicroMinotari) fields. Dependencies: CompressedCommitment, MicroMinotari types. Used by: Transaction validation, kernel aggregation, fee computation. Provides lightweight accumulator for kernel mathematics in Mimblewimble protocol. |
| `mod.rs` | Central module for transaction component definitions and exports. Aggregates all transaction-related types including Transaction, TransactionBuilder, inputs/outputs/kernels, features, errors, encrypted data, and side-chain components. Defines transaction limits (MAX_TRANSACTION_INPUTS/OUTPUTS/RECIPIENTS) and cryptographic types. Implements canonical hashing function for transaction outputs. Foundation module for all Tari transaction functionality and Mimblewimble protocol implementation. |
| `output_features.rs` | Output feature metadata defining UTXO characteristics and sidechain functionality. Provides OutputFeatures with output type, maturity, coinbase extras, sidechain features, and range proof types. Exports: OutputFeatures struct with factory methods create_coinbase(), create_burn_output(), for_template_registration(), for_validator_node_registration(). Dependencies: OutputType, SideChainFeature, RangeProofType, MaxSizeBytes/String. Used by: Transaction outputs, UTXO validation, sidechain operations. Supports coinbase outputs, burned outputs, template registration, and validator node registration with proper type checking. |
| `output_features_version.rs` | Version enumeration for OutputFeatures structures supporting backwards compatibility and protocol evolution. Defines OutputFeaturesVersion enum with V0/V1 variants and conversion utilities. Exports: OutputFeaturesVersion enum with get_current_version(), as_u8(), TryFrom&lt;u8&gt; conversion. Dependencies: borsh/serde serialization, strum Display derive. Used by: OutputFeatures versioning, protocol upgrades, backwards compatibility. Ensures proper handling of feature evolution across network protocol versions with safe conversions. |
| `output_type.rs` | Output type classification enum defining different UTXO categories and their validation rules. Provides OutputType variants: Standard, Coinbase, Burn, ValidatorNodeRegistration, CodeTemplateRegistration. Exports: OutputType enum with as_byte(), from_byte(), all(), is_sidechain_type() methods. Dependencies: num_derive/num_traits for primitive conversion, serde serialization. Used by: UTXO classification, transaction validation, consensus rules. Enables type-safe output categorization with efficient byte-level serialization and comprehensive test coverage. |
| `range_proof_type.rs` | Range proof type enumeration specifying cryptographic proof methods for transaction amounts. Defines RangeProofType with BulletProofPlus (default) and RevealedValue variants for different privacy levels. Exports: RangeProofType enum with as_byte(), from_byte(), all() methods and FromStr parsing. Dependencies: num_derive/num_traits, serde, FromStr trait. Used by: Range proof generation, UTXO privacy settings, transaction validation. Supports configuration-driven proof selection with proper string parsing and serialization. |
| `test.rs` | Comprehensive test suite for transaction components covering range proofs, signatures, internal consistency, and edge cases. Tests include input/output hash matching, SMT hashes, range proof verification (individual and batch), sender signature validation, kernel metadata, timelock validation, cut-through prevention, duplicate detection, and covenant validation. Dependencies: test_helpers, CryptoFactories, key managers, consensus rules, validation framework. Used by: Quality assurance, regression testing, protocol validation. Includes network-specific test variations and comprehensive coverage of transaction security properties and Mimblewimble protocol compliance. |
| `transaction.rs` | Core Transaction structure for Tari blockchain implementing Mimblewimble protocol. Contains kernel offset, aggregate body (inputs/outputs/kernels), and script offset to prevent cut-through attacks. Exports: Transaction struct with methods calculate_weight(), max_input_maturity(), max_kernel_timelock(), min_spendable_height(), first_kernel_excess_sig(). Dependencies: AggregateBody, TransactionWeight, PrivateKey. Used by: Transaction building, validation, blockchain processing. Implements Add trait for transaction aggregation and Display for debugging. Enforces proper UTXO lifecycle management. |
| `transaction_builder.rs` | Builder pattern implementation for constructing complete Transaction objects. Provides fluent API for assembling transactions with inputs, outputs, kernels, offsets, and script offsets. Exports: TransactionBuilder struct with methods add_offset(), add_script_offset(), add_input(), add_output(), add_inputs(), add_outputs(), with_kernel(), with_reward(), build(). Dependencies: Transaction, AggregateBody, TransactionInput/Output/Kernel, PrivateKey. Used by: Transaction assembly, wallet operations, testing. Automatically sorts transaction body components and validates required offsets before building. |
| `transaction_input.rs` | Transaction input implementation for spending existing outputs. Supports both compact (hash-only) and full data variants for bandwidth optimization. Exports: TransactionInput, SpentOutput enum. Dependencies: script execution, crypto signatures, transaction components. Used by: transaction validation, blockchain verification. Includes script execution, signature validation, maturity checks, and canonical hashing for input ordering. |
| `transaction_input_version.rs` | Transaction input versioning system for protocol evolution. Defines version enumeration with conversion utilities. Exports: TransactionInputVersion enum (V0, V1), get_current_version(), conversion methods. Dependencies: borsh, serde. Used by: transaction input creation, validation, serialization. Enables backward compatibility and protocol upgrades with discriminated union serialization. |
| `transaction_kernel.rs` | Transaction kernel for Mimblewimble excess tracking and metadata. Contains fee, lock height, excess commitment, and aggregated signature. Exports: TransactionKernel, signature challenge builders, verification methods. Dependencies: crypto signatures, kernel features, hashing. Used by: transaction validation, block validation, mining. Implements Schnorr signature verification for transaction excess with burn commitment support. |
| `transaction_kernel_version.rs` | Transaction kernel versioning system for protocol compatibility. Defines kernel version enumeration with current version tracking. Exports: TransactionKernelVersion enum (V0), get_current_version(), conversion utilities. Dependencies: borsh, serde. Used by: kernel creation, validation, signature challenges. Enables kernel format evolution while maintaining backward compatibility. |
| `transaction_output.rs` | Transaction output implementation with commitment, range proof, and script support. Handles both BulletProof+ and RevealedValue range proof types. Exports: TransactionOutput, verification methods, metadata signature builders, batch verification. Dependencies: range proofs, commitments, scripts, covenants. Used by: transaction creation, UTXO validation, wallet operations. Features metadata signature verification and efficient batch range proof validation. |
| `transaction_output_version.rs` | Transaction output versioning system for protocol evolution. Defines output version enumeration with current version tracking. Exports: TransactionOutputVersion enum (V0, V1), get_current_version(), conversion utilities. Dependencies: borsh, serde. Used by: output creation, validation, serialization. Enables output format evolution while maintaining backward compatibility through discriminated union serialization. |
| `unblinded_output.rs` | Unblinded output representation with known value and spending key. Used for import/export and wallet operations where complete output information is available. Exports: UnblindedOutput struct, conversion methods to/from WalletOutput. Dependencies: key management, crypto, script execution. Used by: wallet operations, UTXO management, transaction building. Features value-based ordering for UTXO selection and secure key handling for debugging. |
| `wallet_output.rs` | Wallet output implementation for UTXO management with key ID references. Represents outputs where value and spending keys are known via key manager. Exports: WalletOutput struct, conversion methods to TransactionInput/TransactionOutput. Dependencies: key management, crypto, transaction components. Used by: wallet operations, transaction building, UTXO selection. Features multi-party script signatures, range proof generation, and commitment derivation. |
| `wallet_output_builder.rs` | Builder pattern implementation for constructing WalletOutput instances. Provides fluent API for step-by-step output construction with validation. Exports: WalletOutputBuilder with builder methods, signature generation support. Dependencies: key management, crypto, output components. Used by: wallet output creation, transaction building. Features metadata signature creation, multi-party signing, and comprehensive validation before building. |

###### base_layer/core/src/transactions/transaction_components/side_chain/

| File | Description |
|------|-------------|
| `confidential_output.rs` | Simple data structure for confidential output claims in sidechain operations. Contains ConfidentialOutputData with a claim public key for output recovery or ownership proof. Exports: ConfidentialOutputData struct with claim_public_key field. Dependencies: CompressedPublicKey, borsh/serde serialization. Used by: Confidential transactions, burn outputs with recovery, sidechain privacy. Enables claiming of confidential or burned outputs using cryptographic proof of key ownership. |
| `mod.rs` | Module aggregator for sidechain-related transaction components and cryptographic utilities. Exports sidechain types: SideChainFeature, ConfidentialOutputData, CodeTemplateRegistration, ValidatorNodeRegistration, ValidatorNodeSignature, BuildInfo, TemplateType. Dependencies: Blake2b hasher, DomainSeparatedHasher, constituent submodules. Used by: Sidechain transactions, template registration, validator operations. Provides domain-separated hash functions for contract acceptance and signer signatures with Blake256 hashers. |
| `sidechain_feature.rs` | Enum for sidechain-specific features attached to transaction outputs. Defines SideChainFeature with ValidatorNodeRegistration, CodeTemplateRegistration, and ConfidentialOutput variants. Exports: SideChainFeature enum with accessor methods code_template_registration(), validator_node_registration(), confidential_output_data(). Dependencies: borsh/serde serialization, constituent sidechain types. Used by: Output features, sidechain functionality, transaction validation. Provides type-safe access to different sidechain operations embedded in transaction outputs. |
| `template_registration.rs` | Data structures for registering reusable code templates on the sidechain. Defines CodeTemplateRegistration with author credentials, template metadata, build info, and binary references. Exports: CodeTemplateRegistration, TemplateType (Wasm/Flow/Manifest), BuildInfo structs. Dependencies: CompressedPublicKey, Signature, MaxSizeString/Bytes for size-limited fields. Used by: Template deployment, sidechain code registration, reproducible builds. Enables secure template publication with cryptographic author verification and build reproducibility through repo URLs and commit hashes. |
| `validator_node_registration.rs` | Validator node registration system with cryptographic proof of ownership and shard key derivation. Contains ValidatorNodeRegistration with signature verification and epoch-based shard key generation. Exports: ValidatorNodeRegistration with is_valid_signature_for(), derive_shard_key(), public_key(), signature() methods. Dependencies: ValidatorNodeSignature, Blake2b, VnEpoch, FixedHash, DomainSeparatedHasher. Used by: Validator node registration, shard assignment, epoch management. Implements deterministic shard key rotation based on public key and epoch intervals with comprehensive test coverage. |
| `validator_node_signature.rs` | Cryptographic signature implementation for validator node authentication using domain-separated Schnorr signatures. Provides ValidatorNodeSignature with secure signing and verification for validator operations. Exports: ValidatorNodeSignature with sign(), is_valid_signature_for(), public_key(), signature() methods, ValidatorNodeHashDomain. Dependencies: Blake2b, DomainSeparatedHasher, CompressedPublicKey, Signature, UncompressedSignature. Used by: Validator authentication, node registration, signature verification. Implements domain-separated challenge construction for security and uses 64-byte uniform challenges for Schnorr signatures. |

###### base_layer/core/src/transactions/transaction_key_manager/

| File | Description |
|------|-------------|
| `error.rs` | Error types for transaction key management operations. Defines comprehensive error handling for key manager services and storage operations. Exports: CoreKeyManagerError, KeyManagerServiceError, KeyManagerStorageError enums. Dependencies: diesel, crypto, key manager, storage errors. Used by: key management operations throughout transaction system. Includes errors for key operations, storage, serialization, and hardware wallet integration. |
| `initializer.rs` | Service initializer for transaction key manager integration with service framework. Implements ServiceInitializer trait for dependency injection. Exports: TransactionKeyManagerInitializer struct. Dependencies: service framework, key manager storage, crypto factories. Used by: service initialization, dependency injection container. Handles async initialization of key manager services with proper backend configuration. |
| `inner.rs` | Core implementation of transaction key manager with comprehensive cryptographic operations. Provides key derivation, signature generation, range proof construction, and hardware wallet support. Exports: TransactionKeyManager implementation, signature methods, key derivation. Dependencies: crypto operations, ledger integration, key management. Used by: all transaction operations requiring key management. Features Ledger wallet integration and secure key handling. |
| `interface.rs` | Transaction key manager interface definitions and key ID types. Defines comprehensive API for cryptographic operations in transaction system. Exports: TransactionKeyManagerInterface trait, TariKeyId enum, KeySet structs. Dependencies: crypto types, key manager, address handling. Used by: transaction building, signature generation, key management. Includes support for managed, derived, imported, and zero keys with branch-based organization. |
| `key_manager.rs` | Core key management structures for derived keys and domain separation. Provides key derivation utilities with proper security domains. Exports: DerivedKey, DerivedPublicKey structs, derivation methods. Dependencies: crypto hashing, key manager domains. Used by: key derivation operations, secure key handling. Features domain-separated key derivation with zeroization for security. |
| `memory_db_key_manager.rs` | In-memory database key manager for testing and development. Provides temporary key manager instances with SQLite in-memory storage. Exports: MemoryDbKeyManager type alias, creation functions. Dependencies: SQLite storage, key manager, crypto factories. Used by: testing, development environments, temporary operations. Features configurable range proof sizes and random database naming for isolation. |
| `mod.rs` | Module organization for transaction key management functionality. Exports TransactionKeyManagerWrapper, key management interfaces, initializer, memory database implementation, error types, storage layer, and schema definitions. Provides complete key management infrastructure for transaction creation including hierarchical deterministic key derivation, secure storage, and transaction signing capabilities. |
| `schema.rs` | [GENERATED] Diesel ORM database schema for transaction key manager storage. Defines table structures for imported keys and key manager state. Exports: imported_keys, key_manager_states table definitions. Dependencies: diesel ORM. Used by: key manager storage operations, database migrations. Auto-generated by Diesel CLI - do not modify manually. |
| `wrapper.rs` | Wrapper implementation providing async interface for transaction key manager operations. Bridges synchronous key manager with async transaction system. Exports: TransactionKeyManagerWrapper with full async API. Dependencies: key manager, storage backend, crypto operations. Used by: transaction building, wallet operations, async contexts. Provides thread-safe access to key management operations with RwLock protection. |

###### base_layer/core/src/transactions/transaction_key_manager/migrations/2025-01-20-091130_initial/

| File | Description |
|------|-------------|
| `down.sql` | [GENERATED] Database migration rollback script for the transaction key manager. Drops the `key_manager_states` and `imported_keys` tables to completely revert the initial database schema. This is a destructive migration used by the Diesel migration system. |
| `up.sql` | [GENERATED] Database migration SQL script for transaction key manager initialization. Creates key_manager_states table (branch seeds, primary key indices) and imported_keys table (private/public key pairs). Used by: SQLite key manager database setup. Dependencies: None (pure SQL). Regenerated by: Diesel migration system. Contains schema for persistent key management storage with timestamps for key lifecycle tracking. |

###### base_layer/core/src/transactions/transaction_key_manager/storage/

| File | Description |
|------|-------------|
| `mod.rs` | Storage module organization for transaction key manager persistence. Provides module structure for database and other storage implementations. Exports: database storage, storage interfaces. Dependencies: database backends, storage implementations. Used by: key manager storage operations, module organization. Organizes storage layer for transaction key management system. |

###### base_layer/core/src/transactions/transaction_key_manager/storage/database/

| File | Description |
|------|-------------|
| `backend.rs` | Database backend trait for transaction key manager storage abstraction. Defines interface for key manager storage operations across different database implementations. Exports: TransactionKeyManagerBackend trait. Dependencies: storage error types. Used by: key manager storage implementations, database abstraction layer. Enables pluggable storage backends for key management operations. |
| `mod.rs` | Database storage module for transaction key manager. Aggregates database backend implementations and provides unified storage interface. Exports: backend traits, database implementations. Dependencies: storage backends, key manager operations. Used by: key manager initialization, storage layer abstraction. Organizes database-related storage components for key management. |

###### base_layer/core/src/transactions/transaction_key_manager/storage/sqlite_db/

| File | Description |
|------|-------------|
| `imported_keys.rs` | SQLite storage implementation for imported private keys in key manager. Handles persistence and retrieval of imported keys with encryption. Exports: imported key storage operations. Dependencies: diesel ORM, SQLite, encryption. Used by: key import/export, key manager storage. Provides secure storage for externally imported private keys with proper encryption handling. |
| `key_manager_state.rs` | SQLite storage for key manager state and branch seed management. Maintains key derivation state and branch information for deterministic key generation. Exports: state persistence operations. Dependencies: diesel ORM, key manager state. Used by: key derivation, state management, key manager initialization. Ensures consistent key generation through persistent state tracking. |
| `mod.rs` | SQLite database implementation for transaction key manager storage. Integrates imported keys and state management with database operations. Exports: TransactionKeyManagerSqliteDatabase, storage operations. Dependencies: diesel ORM, SQLite, encryption. Used by: key manager persistence, database operations. Provides complete SQLite-based storage solution for transaction key management. |

###### base_layer/core/src/transactions/transaction_protocol/

| File | Description |
|------|-------------|
| `mod.rs` | Transaction protocol module for multi-party transaction construction. Organizes transaction building protocols and message passing. Exports: transaction protocols, sender/receiver implementations. Dependencies: transaction components, key management. Used by: wallet operations, multi-party transactions. Provides infrastructure for secure transaction construction between parties. |
| `recipient.rs` | Recipient implementation for multi-party transaction protocol. Handles recipient side of transaction construction with signature generation. Exports: recipient transaction building, message handling. Dependencies: transaction components, key management, crypto. Used by: wallet operations, transaction receiving. Provides secure transaction construction from recipient perspective with proper validation. |
| `sender.rs` | Sender implementation for multi-party transaction protocol. Handles sender side of transaction construction with input management and fee calculation. Exports: sender transaction building, protocol management. Dependencies: transaction components, key management, fee calculation. Used by: wallet operations, transaction sending. Manages transaction inputs, outputs, and coordinates with recipients for secure transaction building. |
| `single_receiver.rs` | Single receiver transaction protocol implementation for simplified transaction construction. Optimized protocol for single-party receiving scenarios. Exports: single receiver protocol, simplified transaction building. Dependencies: transaction components, key management. Used by: one-sided transactions, simplified wallet operations. Provides streamlined transaction construction when only one receiver is involved. |
| `transaction_initializer.rs` | Transaction initialization and builder setup for transaction protocols. Provides initial setup and configuration for transaction construction. Exports: transaction initializers, builder setup methods. Dependencies: transaction components, consensus rules, key management. Used by: transaction protocol startup, transaction building initialization. Establishes initial state and parameters for secure transaction construction. |

###### base_layer/core/src/transactions/transaction_protocol/proto/

| File | Description |
|------|-------------|
| `mod.rs` | Protocol buffer message organization for transaction protocol communication. Provides serializable message formats for transaction construction. Exports: protobuf message types, serialization support. Dependencies: protocol buffer definitions. Used by: transaction protocol communication, message serialization. Enables network communication for multi-party transaction building. |
| `recipient_signed_message.proto` | [GENERATED] Protocol buffer definition for recipient signed messages in transaction protocol. Defines message structure for recipient's signed transaction data. Dependencies: protobuf compiler. Used by: transaction protocol communication, recipient message handling. Auto-generated protobuf schema - regenerate with protoc when modified. |
| `recipient_signed_message.rs` | [GENERATED] Rust bindings for recipient signed message protocol buffers. Auto-generated from .proto definition for transaction protocol communication. Exports: RecipientSignedMessage types, serialization methods. Dependencies: protobuf runtime. Used by: transaction protocol implementation, message serialization. Auto-generated by protoc - do not modify manually. |
| `transaction_cancelled.proto` | [GENERATED] Protocol buffer definition for transaction cancellation messages. Defines message structure for notifying transaction cancellation in multi-party protocols. Dependencies: protobuf compiler. Used by: transaction protocol cancellation, error handling. Auto-generated protobuf schema - regenerate with protoc when modified. |
| `transaction_finalized.proto` | [GENERATED] Protocol buffer definition for transaction finalization messages. Defines message structure for completed transaction data in multi-party protocols. Dependencies: protobuf compiler. Used by: transaction protocol completion, finalization handling. Auto-generated protobuf schema - regenerate with protoc when modified. |
| `transaction_metadata.proto` | [GENERATED] Protocol buffer definition for transaction metadata messages. Defines message structure for transaction metadata in multi-party protocols. Dependencies: protobuf compiler. Used by: transaction protocol metadata exchange, transaction building. Auto-generated protobuf schema - regenerate with protoc when modified. |
| `transaction_metadata.rs` | [GENERATED] Rust bindings for transaction metadata protocol buffers. Auto-generated from .proto definition for transaction metadata communication. Exports: TransactionMetadata types, serialization methods. Dependencies: protobuf runtime. Used by: transaction protocol metadata handling, message serialization. Auto-generated by protoc - do not modify manually. |
| `transaction_sender.proto` | [GENERATED] Protocol buffer definition for transaction sender messages. Defines message structure for sender's transaction data in multi-party protocols. Dependencies: protobuf compiler. Used by: transaction protocol communication, sender message handling. Auto-generated protobuf schema - regenerate with protoc when modified. |
| `transaction_sender.rs` | [GENERATED] Rust bindings for transaction sender protocol buffers. Auto-generated from .proto definition for sender transaction communication. Exports: TransactionSender types, serialization methods. Dependencies: protobuf runtime. Used by: transaction protocol sender implementation, message serialization. Auto-generated by protoc - do not modify manually. |

###### base_layer/core/src/validation/

| File | Description |
|------|-------------|
| `chain_balance.rs` | Chain balance validation for ensuring economic consistency. Validates that transaction inputs and outputs maintain proper balance across the blockchain. Exports: balance validation functions, economic consistency checks. Dependencies: transaction components, blockchain storage. Used by: block validation, economic security. Ensures the Mimblewimble balance property is maintained across the entire chain. |
| `difficulty_calculator.rs` | Difficulty calculation and validation for proof-of-work consensus. Manages target difficulty adjustments and RandomX algorithm integration. Exports: DifficultyCalculator, validation methods. Dependencies: consensus rules, RandomX factory, proof-of-work validation. Used by: mining, block validation, difficulty adjustment algorithm. Includes RandomX virtual machine key management and target difficulty verification. |
| `error.rs` | Comprehensive validation error handling for blockchain operations. Defines ValidationError enum covering block validation, transaction validation, proof-of-work errors, consensus failures, and storage errors. Exports: ValidationError enum with get_ban_reason() method for network penalty decisions. Dependencies: BlockValidationError, TransactionError, ProofOfWorkError, ChainStorageError, CovenantError. Used by: All validation operations throughout blockchain processing. Provides ban reason determination for network misbehavior and maps various error types to appropriate network penalties. |
| `helpers.rs` | Validation helper functions for blockchain and transaction verification. Provides common validation utilities used across validation components. Exports: UTXO checks, duplicate detection, MMR validation, difficulty validation. Dependencies: blockchain storage, consensus rules, transaction components. Used by: all validation modules, consensus verification. Contains reusable validation logic for consistent verification across the system. |
| `mocks.rs` | Mock implementations for validation testing. Provides test doubles and mock validators for unit testing validation components. Exports: mock validators, test validation implementations. Dependencies: validation traits, test utilities. Used by: validation tests, unit testing, integration testing. Enables isolated testing of validation logic without full blockchain context. |
| `mod.rs` | Blockchain validation framework implementing comprehensive validation pipeline for blocks, transactions, and headers. Provides Validation trait implementations including BlockBodyValidator, CandidateBlockValidator, HeaderChainLinkedValidator, TransactionValidator, and FinalHorizonStateValidation. Includes difficulty calculation, chain balance validation, aggregate body validation, header validation, transaction validation, and MockValidator for testing. Features ValidationPipeline for chaining validators, helper utilities, and comprehensive error handling. Ensures blockchain integrity through multi-layered validation processes. |
| `test.rs` | Comprehensive validation system tests. Tests integration of validation components across the validation pipeline. Dependencies: validation components, test helpers, blockchain utilities. Used by: validation testing, integration testing, CI/CD validation. Ensures proper coordination between different validation layers and consensus mechanisms. |
| `traits.rs` | Validation trait definitions for blockchain components. Defines interfaces for block body validation, candidate block validation, transaction validation, internal consistency checking, header chain validation, and final horizon state validation. Exports: BlockBodyValidator, CandidateBlockValidator, TransactionValidator, InternalConsistencyValidator, HeaderChainLinkedValidator, FinalHorizonStateValidation traits. Dependencies: Block, Transaction, ChainBlock, ValidationError types. Used by: Validation pipeline, consensus implementation, blockchain verification. Provides pluggable validation architecture with different validation stages. |

###### base_layer/core/src/validation/aggregate_body/

| File | Description |
|------|-------------|
| `aggregate_body_chain_validator.rs` | Chain-linked validation for aggregate transaction bodies in blocks. Validates transaction inputs exist as spendable UTXOs and prevents double-spending. Exports: AggregateBodyChainLinkedValidator, validation methods. Dependencies: blockchain storage, consensus rules, transaction components. Used by: block validation, transaction verification. Performs comprehensive checks including UTXO existence, duplicate detection, and coinbase validation. |
| `aggregate_body_internal_validator.rs` | Internal consistency validation for aggregate transaction bodies. Validates transaction body structure without requiring chain context. Exports: AggregateBodyInternalValidator, validation methods. Dependencies: transaction components, consensus rules. Used by: transaction validation, block body validation. Performs structural validation including signature verification, balance checks, and internal consistency rules. |
| `mod.rs` | Aggregate body validation module organization. Combines internal consistency and chain-linked validation for transaction bodies. Exports: validation traits, validator implementations. Dependencies: validation components, transaction bodies. Used by: block validation, transaction verification. Organizes validation logic for aggregate transaction bodies in blocks. |

###### base_layer/core/src/validation/block_body/

| File | Description |
|------|-------------|
| `block_body_full_validator.rs` | Full block body validation with chain context and proof-of-work verification. Combines internal consistency and chain-linked validation. Exports: BlockBodyFullValidator, comprehensive validation methods. Dependencies: consensus, proof-of-work, storage, MMR validation. Used by: block acceptance, mining validation. Integrates transaction validation with header verification and MMR root checking. |
| `block_body_internal_validator.rs` | Internal consistency validation for block bodies. Validates block structure and transaction organization without chain context. Exports: BlockBodyInternalValidator, validation methods. Dependencies: block components, transaction validation. Used by: block validation pipeline, mining validation. Ensures block body structural integrity and transaction consistency. |
| `mod.rs` | Block body validation module organization. Combines internal and full validation for block bodies. Exports: validation traits, validator implementations. Dependencies: validation components, block structures. Used by: block validation pipeline, consensus validation. Organizes block body validation logic with proper separation of concerns. |
| `test.rs` | Unit tests for block body validation components. Tests internal and full validation logic for various block scenarios. Dependencies: test helpers, validation components, test blockchain utilities. Used by: validation testing, CI/CD validation checks. Ensures block body validation works correctly across different consensus scenarios and edge cases. |

###### base_layer/core/src/validation/header/

| File | Description |
|------|-------------|
| `header_full_validator.rs` | Full block header validation with chain context and proof-of-work verification. Validates headers against blockchain state and consensus rules. Exports: HeaderFullValidator, comprehensive header validation. Dependencies: consensus rules, proof-of-work, blockchain storage. Used by: block acceptance, header chain validation. Integrates timestamp, difficulty, and proof-of-work validation with chain context. |
| `mod.rs` | Block header validation module organization. Provides comprehensive header validation combining structural and chain-linked checks. Exports: header validation traits, validator implementations. Dependencies: validation components, header structures. Used by: block validation pipeline, header chain verification. Organizes header validation logic for blockchain consensus. |

###### base_layer/core/src/validation/transaction/

| File | Description |
|------|-------------|
| `mod.rs` | Transaction validation module organization. Combines internal consistency and chain-linked validation for individual transactions. Exports: transaction validation traits, validator implementations. Dependencies: validation components, transaction structures. Used by: transaction verification, mempool validation. Organizes transaction-level validation logic for consensus compliance. |
| `transaction_chain_validator.rs` | Chain-linked validation for individual transactions. Validates transactions against blockchain state and UTXO set. Exports: TransactionChainValidator, chain validation methods. Dependencies: blockchain storage, transaction components, consensus rules. Used by: transaction verification, mempool validation. Ensures transactions are valid against current blockchain state. |
| `transaction_full_validator.rs` | Full transaction validation combining internal consistency and chain context. Provides comprehensive validation for individual transactions. Exports: TransactionFullValidator, complete validation methods. Dependencies: validation components, blockchain storage, consensus rules. Used by: transaction acceptance, mempool validation. Integrates all validation aspects for complete transaction verification. |
| `transaction_internal_validator.rs` | Internal consistency validation for individual transactions. Validates transaction structure without requiring blockchain context. Exports: TransactionInternalValidator, structural validation methods. Dependencies: transaction components, crypto verification. Used by: transaction validation pipeline, structural verification. Ensures transaction internal consistency including signatures, range proofs, and balance. |

##### base_layer/core/tests/

| File | Description |
|------|-------------|
| `core_integration_tests.rs` | Core integration tests for base layer functionality. Tests integration between major components like consensus, validation, and storage. Dependencies: all core components, test helpers, blockchain utilities. Used by: integration testing, CI/CD validation, system verification. Critical for ensuring overall blockchain system reliability and integrity. |

###### base_layer/core/tests/chain_storage_tests/

| File | Description |
|------|-------------|
| `chain_backend.rs` | Integration tests for blockchain storage backend implementations. Tests chain storage operations across different backend types. Dependencies: chain storage, test helpers, blockchain utilities. Used by: storage testing, backend verification, CI/CD testing. Ensures consistent behavior across different blockchain storage implementations. |
| `chain_storage.rs` | Comprehensive integration tests for blockchain chain storage functionality. Tests block storage, retrieval, and chain operations. Dependencies: chain storage, test blockchain builders, validation. Used by: storage integration testing, CI/CD validation. Verifies chain storage operations work correctly across different scenarios and edge cases. |
| `mod.rs` | Test module organization for chain storage integration tests. Organizes storage backend and functionality tests. Exports: test modules, test utilities. Dependencies: chain storage test components. Used by: integration testing, storage verification. Provides structure for comprehensive chain storage testing across different backends and scenarios. |

###### base_layer/core/tests/helpers/

| File | Description |
|------|-------------|
| `block_builders.rs` | Test helper utilities for constructing blocks and blockchain components in Tari tests. Exports: create_coinbase(), create_genesis_block(), create_genesis_block_with_coinbase_value(), create_genesis_block_with_utxos(), chain_block(), append_block(), generate_new_block(), find_header_with_achieved_difficulty(), construct_chained_blocks(). Dependencies: JMT, MMR components, transaction components, consensus, key manager. Used by: blockchain integration tests. Features genesis block creation with configurable coinbase, chained block construction, MMR root calculation, proof-of-work mining simulation, and block database operations. |
| `block_malleability.rs` | Test helpers for detecting block malleability attacks in Tari blockchain. Exports: check_input_malleability(), check_output_malleability(), check_kernel_malleability(). Dependencies: Block types, transaction components, test blockchain. Used by: blockchain security tests. Verifies that modifications to block inputs, outputs, or kernels are properly detected through MMR root changes, ensuring blockchain integrity and preventing malleability attacks. |
| `block_proxy.rs` | Simple wrapper struct for ChainBlock used in tests. Exports: BlockProxy struct with new() constructor. Dependencies: ChainBlock type. Used by: test frameworks requiring named block references. Provides a named proxy around ChainBlock instances for easier test identification and comparison, implementing PartialEq for block comparison. |
| `chain_metadata.rs` | Mock chain metadata service for testing peer chain synchronization. Exports: MockChainMetadata struct with new(), chain_metadata_handle(), subscription(), publish_event(), publish_chain_metadata(). Dependencies: ChainMetadata, ChainMetadataHandle, broadcast channels. Used by: base node synchronization tests. Simulates peer chain metadata updates for testing blockchain synchronization logic without requiring real network peers. |
| `database.rs` | Database test utilities for creating orphan blocks and test blocks. Exports: create_orphan_block(), create_block(). Dependencies: Block types, consensus manager, transaction components, coinbase creation helpers. Used by: blockchain database tests. Creates blocks that are not connected to the main chain for testing block validation, database operations, and orphan block handling scenarios. |
| `event_stream.rs` | Test utility for handling event streams with timeouts. Exports: event_stream_next() function. Dependencies: tokio broadcast channels, time utilities. Used by: event-driven tests. Provides timeout-based event reception from broadcast channels, handling lag errors and closed channels for robust test event handling. |
| `mock_state_machine.rs` | Mock base node state machine for testing purposes. Exports: MockBaseNodeStateMachine, MockBaseNodeStateMachineInitializer. Dependencies: StateMachineHandle, service framework components, watch channels. Used by: base node service tests. Simulates base node state transitions and status reporting without full state machine complexity for isolated testing. |
| `mod.rs` | Module declaration file that exports test helper modules for Tari base blockchain testing. Provides a comprehensive suite of utilities including block builders, blockchain samples, mock components, and database helpers. Exports: block_builders, block_malleability, block_proxy, chain_metadata, database, event_stream, mock_state_machine, nodes, sample_blockchains, sync, test_block_builder, test_blockchain. Used by: integration tests throughout base_layer/core/tests. Key functionality includes transaction schema macros, blockchain bootstrap utilities, and testing infrastructure for the Tari blockchain protocol. |
| `nodes.rs` | Comprehensive test node builder and network setup utilities. Exports: NodeInterfaces, BaseNodeBuilder, wait_until_online(), create_network_with_multiple_base_nodes_with_config(), random_node_identity(). Dependencies: comms stack, p2p services, mempool, blockchain database, consensus. Used by: integration tests requiring full node setup. Creates test networks with configurable base nodes, complete with all services and networking for end-to-end testing scenarios. |
| `sample_blockchains.rs` | Pre-built sample blockchain scenarios for testing. Exports: create_blockchain_db_no_cut_through(), consensus_constants(), create_new_blockchain(), create_new_blockchain_with_constants(), create_new_blockchain_lmdb(). Dependencies: consensus manager, block builders, transaction schemas. Used by: blockchain behavior tests. Creates specific blockchain configurations with known transaction patterns, UTXOs, and block sequences for consistent testing scenarios. |
| `sync.rs` | Comprehensive synchronization testing utilities for base node state machine operations. Exports: sync state initialization, execution helpers, network setup functions, blockchain manipulation utilities. Dependencies: state machine components, consensus, blockchain database, P2P services. Used by: synchronization integration tests. Provides header sync, block sync, horizon sync testing, multi-node network creation, block manipulation, peer management, and complex blockchain scenario construction for sync testing. |
| `test_block_builder.rs` | Fluent test block builder for creating test blockchain scenarios. Exports: TestBlockBuilder, TestBlockBuilderInner with chainable methods. Dependencies: transaction components. Used by: blockchain tests requiring custom block construction. Provides fluent API for specifying block relationships, difficulty, and transactions in test scenarios with parent-child block relationships. |
| `test_blockchain.rs` | High-level test blockchain implementation with named block management. Exports: TestBlockchain with block building, adding, and querying operations. Dependencies: blockchain database, consensus, test block builder, sample blockchains. Used by: complex blockchain scenario tests. Provides named block references, chain traversal, orphan tracking, and comprehensive blockchain state management for sophisticated test scenarios. |

###### base_layer/core/tests/tests/

| File | Description |
|------|-------------|
| `async_db.rs` | Asynchronous database operations integration tests. Tests: async header fetching, block fetching, rewinding, block addition, orphan handling. Dependencies: async blockchain database wrapper, test blockchain helpers, transaction schemas. Used by: database layer testing. Validates asynchronous database operations including concurrent access, data consistency, and proper async/await patterns for blockchain storage operations. |
| `base_node_rpc.rs` | Base node RPC service integration tests covering wallet and sync operations. Tests: transaction submission, querying, batch operations, UTXO fetching, height lookups, sync operations. Dependencies: RPC services, base node builder, consensus, transaction helpers. Used by: RPC layer testing. Validates complete RPC functionality including transaction lifecycle, mempool interactions, blockchain queries, and synchronization protocols with comprehensive error handling scenarios. |
| `block_sync.rs` | Integration tests for Tari blockchain block synchronization functionality. Tests block sync between nodes, peer banning scenarios, and coinbase spending validation. Key tests: test_block_sync_happy_path (basic sync verification), test_block_sync_peer_supplies_no_blocks_with_ban (peer misbehavior), test_block_sync_peer_supplies_not_all_blocks_with_ban (incomplete responses), test_block_sync_with_conbase_spend_happy_path (coinbase transaction validation). Dependencies: tari_core state machine, sync helpers, blockchain database config. Used by: cargo test integration. Validates block propagation, peer interaction protocols, and blockchain integrity during synchronization. |
| `block_validation.rs` | Comprehensive integration tests for Tari blockchain block validation and proof-of-work verification. Tests Monero merge mining validation, RandomX implementation, transaction malleability protection, and various validation failure scenarios. Key tests: test_monero_blocks (Monero PoW validation), inputs_are_not_malleable (transaction input tampering), test_orphan_validator (orphan block validation), test_header_validation (header verification), test_block_sync_body_validator (block body validation). Dependencies: tari_core validation modules, proof_of_work, consensus, cryptographic factories. Used by: blockchain validation pipeline. Critical for maintaining blockchain security and consensus rules. |
| `header_sync.rs` | Integration tests for Tari blockchain header synchronization protocol. Tests header sync scenarios including happy path sync, fork handling, peer metadata validation, and synchronization with uneven header/block ratios. Key tests: test_header_sync_happy_path (basic header sync), test_header_sync_with_fork_happy_path (fork resolution), test_header_sync_uneven_headers_and_blocks_happy_path (mismatched header/block heights), test_header_sync_even_headers_and_blocks_peer_lies_about_pow_with_ban (peer misbehavior detection). Dependencies: tari_core state machine, sync helpers, header sync status. Used by: blockchain synchronization process. Validates header propagation, peer trust mechanisms, and chain integrity verification. |
| `horizon_sync.rs` | Integration tests for Tari blockchain horizon synchronization protocol used in pruned node operations. Tests initial horizon sync from archival and pruned nodes, consecutive horizon sync operations, and UTXO pruning validation. Key tests: test_initial_horizon_sync_from_archival_node_happy_path (archival to pruned sync), test_consecutive_horizon_sync_from_prune_node_happy_path (multi-stage pruned sync), test_initial_horizon_sync_from_prune_node_happy_path (pruned to pruned sync). Dependencies: tari_core horizon state sync, pruning horizon configuration, blockchain database config. Used by: pruned node synchronization. Validates UTXO set integrity, pruning operations, and state synchronization for resource-constrained nodes. |
| `mempool.rs` | Comprehensive integration tests for Tari mempool functionality including transaction validation, priority ordering, time-locked transactions, and zero-confirmation transaction handling. Key tests: test_insert_and_process_published_block (basic mempool operations), test_time_locked (time-locked transaction validation), test_retrieve (transaction priority retrieval), test_zero_conf (zero-confirmation transaction chains), test_reorg (blockchain reorganization handling). Dependencies: tari_core mempool, transaction validation, consensus manager, crypto factories. Used by: mempool service integration tests. Validates transaction pool management, fee-based prioritization, and complex transaction dependency resolution. |
| `mod.rs` | Module declaration file for core integration test modules and utility functions. Exports: async_db, base_node_rpc, block_sync, block_validation, header_sync, horizon_sync, mempool, node_comms_interface, node_service, node_state_machine test modules. Provides: assert_block_add_result_added() helper function for validating block addition results. Dependencies: tari_core blocks and chain_storage. Used by: integration test framework. Central organization point for all core blockchain integration tests with shared test utilities. |
| `node_comms_interface.rs` | Integration tests for Tari base node communication interface including inbound request handling and overflow protection. Tests metadata retrieval, kernel fetching, header fetching, UTXO queries, block fetching, and transaction protocol overflow scenarios. Key tests: inbound_get_metadata (chain metadata requests), inbound_fetch_kernel_by_excess_sig (kernel lookups), inbound_fetch_headers (header range queries), inbound_fetch_utxos (UTXO set queries), test_sender_transaction_protocol_for_overflow (overflow attack protection), inbound_fetch_blocks_before_horizon_height (pruned node queries). Dependencies: tari_core comms interface, mempool, consensus manager, transaction key manager. Used by: node communication layer. Validates peer-to-peer protocol handling and security measures. |
| `node_service.rs` | Integration tests for Tari base node service functionality including block propagation, validation, and local node operations. Tests multi-node block propagation, invalid block handling, peer banning, and block template generation. Key tests: propagate_and_forward_many_valid_blocks (multi-hop block propagation), propagate_and_forward_invalid_block_hash (invalid hash handling), propagate_and_forward_invalid_block (malicious block rejection), local_get_metadata (local node queries), local_get_new_block_template_and_get_new_block (block template generation), local_get_new_block_with_zero_conf (zero-conf transaction blocks). Dependencies: tari_core base node services, consensus manager, crypto factories, block builders. Used by: base node service integration. Validates distributed block propagation and local node functionality. |
| `node_state_machine.rs` | Integration tests for Tari base node state machine behavior including listening state, synchronization triggers, and event handling. Tests state transitions when nodes fall behind, initial synchronization detection, and state machine event propagation. Key tests: test_listening_lagging (detection of falling behind network), test_listening_initial_fallen_behind (initial sync requirements), test_event_channel (state change event system). Dependencies: tari_core base node state machine, chain metadata service, sync validators, mock components. Used by: base node state management. Validates node state transitions, peer discovery, and synchronization decision logic critical for maintaining network consensus. |

#### base_layer/key_manager/

| File | Description |
|------|-------------|
| `.gitignore` | Git ignore rules for key manager module. Excludes build artifacts, database files, and sensitive key material from version control. Used by: git version control, key manager development. Ensures sensitive files and build outputs are not committed to the repository. |
| `Cargo.toml` | Rust package manifest for key manager crate. Defines dependencies, features, and build configuration for cryptographic key management. Dependencies: crypto libraries, diesel ORM, storage. Used by: Cargo build system, dependency management. Configures key manager as standalone crate with proper crypto and storage dependencies. |
| `README.md` | Documentation for key manager module functionality and usage. Explains key management capabilities, API usage, and security considerations. Used by: developers, documentation, key manager integration. Provides comprehensive guide for understanding and using the key manager component. |
| `diesel.toml` | Diesel ORM configuration for key manager database operations. Configures database migration paths and code generation settings. Dependencies: diesel CLI, migration files. Used by: database migrations, code generation, diesel tooling. Configures Diesel ORM for key manager storage operations. |

###### base_layer/key_manager/migrations/2023-03-31-130611_initial/

| File | Description |
|------|-------------|
| `down.sql` | [GENERATED] Diesel migration rollback SQL for initial key manager schema. Removes initial database tables and structures. Dependencies: diesel migration system. Used by: database rollback, migration management. Auto-generated migration file - modify schema and regenerate if needed. |
| `up.sql` | [GENERATED] Diesel migration SQL for initial key manager schema creation. Creates initial database tables for key management. Dependencies: diesel migration system. Used by: database initialization, schema setup. Auto-generated migration file - modify schema and regenerate if needed. |

###### base_layer/key_manager/migrations/2023-05-08-150000_imported_table/

| File | Description |
|------|-------------|
| `down.sql` | [GENERATED] Diesel migration rollback SQL for imported keys table. Removes imported keys table and related structures. Dependencies: diesel migration system. Used by: database rollback, migration management. Auto-generated migration file for imported keys feature. |
| `up.sql` | [GENERATED] Diesel migration SQL for imported keys table creation. Creates table for storing imported private keys. Dependencies: diesel migration system. Used by: database schema evolution, imported key storage. Auto-generated migration file for imported keys feature. |

##### base_layer/key_manager/src/

| File | Description |
|------|-------------|
| `cipher_seed.rs` | Cipher seed implementation for secure key derivation and storage. Provides encrypted seed management for deterministic key generation. Exports: CipherSeed struct, encryption/decryption methods. Dependencies: encryption libraries, key derivation. Used by: key manager initialization, seed storage. Implements BIP39-compatible seed phrases with encryption for secure key backup and recovery. |
| `diacritics.rs` | Diacritical mark handling for mnemonic phrase normalization. Provides Unicode normalization for consistent seed phrase handling across different languages. Exports: diacritic removal functions, text normalization utilities. Dependencies: Unicode handling libraries. Used by: mnemonic processing, seed phrase validation. Ensures consistent handling of international characters in recovery phrases. |
| `error.rs` | Error types for key manager operations and storage. Defines comprehensive error handling for key management, encryption, and storage operations. Exports: KeyManagerError enum, error conversion traits. Dependencies: storage errors, crypto errors. Used by: key manager operations, error handling throughout key management system. Provides detailed error information for debugging and user feedback. |
| `key_manager.rs` | Core key manager implementation with hierarchical deterministic key derivation. Provides secure key generation, storage, and management using BIP32-style derivation. Exports: KeyManager struct, key derivation methods, branch management. Dependencies: crypto libraries, storage backends. Used by: wallet operations, transaction key management. Implements secure key hierarchy with proper domain separation and branch isolation. |
| `lib.rs` | Cryptographic key management library providing secure seed phrase handling, cipher seed encryption, and hierarchical key derivation. Implements SeedWords with hidden/secure string storage, mnemonic word list support, PBKDF-based key derivation, domain-separated hashing (KeyManagerDomain), and birthday calculation for wallet synchronization. Includes cipher seed utilities with MAC verification, diacritic handling for international mnemonic phrases, and optional key manager service. Features secure memory handling with zeroization and safe array abstractions for protecting sensitive cryptographic material. |
| `mnemonic.rs` | Mnemonic seed phrase system for encoding/decoding secret keys. Exports: MnemonicLanguage enum (ChineseSimplified, English, French, Italian, Japanese, Korean, Spanish), Mnemonic trait, from_bytes/to_bytes functions. Supports automatic language detection, word validation, and bidirectional conversion between byte arrays and mnemonic phrases. Dependencies: mnemonic_wordlists, diacritics, SeedWords. Includes comprehensive test suite for all supported languages. |
| `mnemonic_wordlists.rs` | BIP-39 mnemonic word lists for multiple languages. Contains sorted arrays of 2048 words each for: Chinese Simplified, English, French, Italian, Japanese, Korean, Spanish. Used by mnemonic module for encoding/decoding secret keys into human-readable phrases. Words are pre-sorted for binary search optimization. Diacritics removed from French and Spanish. Based on Bitcoin BIP-39 specification. |
| `schema.rs` | [GENERATED] Diesel database schema defining table structures for key manager SQLite database. Tables: imported_keys (id, private_key, public_key, timestamp), key_manager_states (id, branch_seed, primary_key_index, timestamp). Generated automatically by Diesel CLI from migrations. Used by key manager SQLite backend for ORM operations. |

###### base_layer/key_manager/src/key_manager_service/

| File | Description |
|------|-------------|
| `error.rs` | Error types for key manager service operations. Exports: KeyManagerServiceError, KeyManagerStorageError enums. Dependencies: diesel, storage errors, crypto errors, utilities. Used by: key manager service, storage layers. Comprehensive error handling for key operations including branch management, serialization, range proofs, Ledger hardware wallet interactions, and storage operations with proper error chaining. |
| `handle.rs` | Thread-safe handle for key manager service operations. Exports: KeyManagerHandle struct implementing KeyManagerInterface. Dependencies: key manager inner, cipher seed, database backend, async traits. Used by: wallet services, transaction key management. Provides async access to hierarchical key derivation operations with RwLock protection for concurrent access to key manager functionality. |
| `initializer.rs` | Service initializer for the key manager that implements the ServiceInitializer trait. Exports KeyManagerInitializer struct which takes a KeyManagerBackend and CipherSeed to initialize the key manager service. Dependencies: tari_service_framework, tari_crypto, cipher_seed module, key_manager_service modules. Used by service framework for bootstrapping key management functionality. Handles registration of KeyManagerHandle with service context. |
| `interface.rs` | Core interfaces and types for key manager service. Exports: KeyManagerInterface trait, KeyId enum, KeyAndId struct, AddResult enum, KeyManagerBranch enum. Dependencies: crypto keys, serde, byte arrays. Used by: key manager implementations, wallet components. Defines the API contract for hierarchical key derivation including managed, derived, imported, and zero key types with branch management and serialization support. |
| `mod.rs` | Main module file for key_manager_service defining the public API. Exports: KeyManagerServiceError, KeyManagerHandle, KeyManagerInitializer, KeyManagerInner, KeyId, SerializedKeyString, AddResult, KeyAndId, KeyManagerBranch, KeyManagerInterface. Contains Blake2b digest type alias KeyDigest. Includes diesel migration setup notes for SQLite database. Entry point for key manager functionality. |
| `service.rs` | Core key manager service implementation with hierarchical key derivation. Exports: KeyManagerInner struct with key derivation operations. Dependencies: key managers, database backend, cipher seed, crypto hashing. Used by: key manager handle. Implements branch-based key management, key derivation with domain separation, key searching, index management, and imported key handling with persistent storage integration. |

###### base_layer/key_manager/src/key_manager_service/storage/

| File | Description |
|------|-------------|
| `mod.rs` | Storage module entry point exposing database and sqlite_db submodules. Provides access to database abstraction layer (KeyManagerBackend trait, KeyManagerDatabase) and SQLite-specific implementation (KeyManagerSqliteDatabase). Used by key manager service to persist key state and imported keys. |

###### base_layer/key_manager/src/key_manager_service/storage/database/

| File | Description |
|------|-------------|
| `backend.rs` | Trait definition for KeyManagerBackend defining required storage operations for key manager service. Exports KeyManagerBackend trait with methods: get_key_manager, add_key_manager, increment_key_index, set_key_index, insert_imported_key, get_imported_key. Generic over PublicKey type. Dependencies: tari_crypto keys, KeyManagerStorageError, KeyManagerState. Implemented by storage backends like SQLite. |
| `mod.rs` | Database abstraction layer for key manager storage. Exports: KeyManagerBackend trait, KeyManagerState struct (branch_seed, primary_key_index), ImportedKey struct, KeyManagerDatabase wrapper. KeyManagerDatabase wraps backend implementations and provides high-level operations: get/set key manager state, increment/set key index, insert/get imported keys. Generic over backend type and public key type. |

###### base_layer/key_manager/src/key_manager_service/storage/sqlite_db/

| File | Description |
|------|-------------|
| `imported_keys.rs` | SQLite database models and operations for imported keys table. Exports: ImportedKeySql (queryable), NewImportedKeySql (insertable). Implements encryption/decryption of private keys using XChaCha20Poly1305. Methods: new_from_imported_key (encrypted creation), commit (database insert), index (retrieve all), get_key (find by public key), to_imported_key (decrypt and convert). Dependencies: diesel, chacha20poly1305, tari_common_types encryption, schema imported_keys table. |
| `key_manager_state.rs` | SQLite database models for key_manager_states table. Exports: KeyManagerStateSql (queryable), NewKeyManagerStateSql (insertable), KeyManagerStateUpdateSql (changeset). Implements encryption/decryption of primary_key_index using XChaCha20Poly1305. Methods: index (get all states), get_state (by branch), set_state (upsert), set_index (update key index). Conversions between domain KeyManagerState and SQL models. Dependencies: diesel, chacha20poly1305, tari_common_types encryption. |
| `mod.rs` | SQLite implementation of KeyManagerBackend trait. Exports: KeyManagerSqliteDatabase which implements KeyManagerBackend for SQLite. Handles database migrations, connection pooling, and encrypted storage of key manager state and imported keys. Methods include performance logging and error handling. Dependencies: diesel_migrations, tari_common_sqlite, chacha20poly1305. Includes embedded migrations and comprehensive test suite for CRUD operations. |

#### base_layer/mmr/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for tari_mmr crate providing Merkle Mountain Range implementation. Dependencies: tari_utilities, tari_crypto, thiserror, borsh, digest, log, serde. Dev dependencies: rand, blake2, serde_json, bincode, criterion. Includes benchmarks for MMR and SMT performance testing. Library for cryptographic data structures supporting blockchain operations. |
| `README.md` | Documentation for Merkle Mountain Range (MMR) implementation. Explains MMR as binary tree where each parent is concatenated hash of children. Supports easy addition and proof of existence. Links to Peter Todd's original specification and Grin implementation docs. Describes bagging of peaks to create single merkle root for multiple binary trees. |

##### base_layer/mmr/benches/

| File | Description |
|------|-------------|
| `mmr.rs` | Performance benchmark suite for Merkle Mountain Range (MMR) operations using Criterion framework. Tests MMR construction performance by building MMRs with varying sizes (100, 1K, 10K, 100K hashes). Uses Blake2b-256 hash function with domain separation. Exports: benchmark functions for Criterion. Dependencies: blake2, criterion, tari_crypto, tari_mmr. Tests MMR push operations under controlled conditions using batch iteration. |
| `smt.rs` | Performance benchmark suite for Sparse Merkle Tree (SMT) operations using Criterion framework. Tests various SMT operations: insertion, deletion, root hash calculation on trees with sizes 100-100K keys. Uses Blake2b-256 hasher. Exports: benchmark functions for SMT operations including build_smt, full_root_hash, delete_half_keys, half_root_hash, delete_remaining_keys, empty_root_hash. Dependencies: blake2, criterion, tari_mmr sparse_merkle_tree. Measures performance of key upserts, deletions, and root calculations in different tree states. |

##### base_layer/mmr/src/

| File | Description |
|------|-------------|
| `backend.rs` | Generic array-like backend trait definitions for MMR storage. Exports: ArrayLike, ArrayLikeExt traits with Vec implementation. Dependencies: MMR error types. Used by: MMR implementations, storage backends. Defines storage interface for MMR operations including push, get, truncate, shift, and iteration with error handling, providing abstraction over different storage backends. |
| `balanced_binary_merkle_proof.rs` | Balanced binary Merkle tree proof generation and verification. Exports: BalancedBinaryMerkleProof, MergedBalancedBinaryMerkleProof structs with proof operations. Dependencies: digest traits, balanced binary Merkle tree, hashing utilities. Used by: blockchain validation, proof systems. Implements Merkle inclusion proofs with verification, proof merging for batch verification, and comprehensive error handling for tree-based cryptographic proofs. |
| `balanced_binary_merkle_tree.rs` | Balanced binary Merkle tree implementation for cryptographic proofs. Exports: BalancedBinaryMerkleTree struct with tree operations, BalancedBinaryMerkleTreeError enum. Dependencies: digest traits, hashing utilities, serde support. Used by: proof systems, blockchain validation. Provides complete binary tree construction from leaves, Merkle root calculation, leaf lookup by hash, and tree integrity validation with efficient node indexing. |
| `common.rs` | Core MMR utility functions and mathematical operations. Exports: node_index(), leaf_index(), is_leaf(), find_peaks(), family(), family_branch(), bintree_height(), peak_map_height(), is_left_sibling(), hash_together(), checked_n_leaves(). Dependencies: digest traits, MMR error types. Used by: MMR implementations, proof generation. Provides essential MMR navigation, peak detection, tree traversal, and mathematical utilities for Merkle Mountain Range operations. |
| `error.rs` | Error types for Merkle Mountain Range operations. Exports: MerkleMountainRangeError enum with error variants. Dependencies: thiserror. Used by: all MMR components. Defines comprehensive error handling for MMR operations including data corruption, backend errors, hash validation, size limits, and range validation with helper methods for error construction. |
| `functions.rs` | High-level MMR utility functions for pruning and root calculation. Exports: PrunedMmr type alias, prune_mmr(), calculate_mmr_root(). Dependencies: MMR types, pruned hash set, digest traits. Used by: blockchain storage, MMR optimization. Provides MMR pruning functionality to reduce storage requirements and efficient root calculation for MMR validation scenarios. |
| `lib.rs` | Merkle Mountain Range (MMR) implementation for efficient append-only authenticated data structures. Provides MerkleMountainRange for blockchain state commitments, MerkleProof for inclusion proofs, BalancedBinaryMerkleTree for complete binary trees, and sparse merkle trees for efficient key-value storage. Includes memory and persistent backends (MemBackendVec), pruning capabilities (pruned_hashset), and comprehensive node navigation formulas. Features detailed documentation of MMR construction, node numbering conventions, and mathematical relationships for tree traversal. |
| `mem_backend_vec.rs` | In-memory vector backend for Merkle Mountain Range storage. Exports MemBackendVec struct implementing ArrayLike trait with thread-safe Arc<RwLock<Vec<T>>> storage. Provides push, get, set, len, truncate operations for MMR nodes. Used for testing and temporary MMR storage. Alternative to persistent storage backends. |
| `merkle_mountain_range.rs` | Core Merkle Mountain Range implementation with append-only semantics. Exports: MerkleMountainRange struct with comprehensive MMR operations. Dependencies: backend storage, digest traits, common utilities, pruned hash set. Used by: blockchain components, cryptographic proofs. Implements full MMR functionality including hash insertion, root calculation, validation, search operations, and pruning support with generic backend storage abstraction. |
| `merkle_proof.rs` | Merkle proof implementation for MMR inclusion verification. Exports: MerkleProofError, MerkleProof struct for validating element existence in Merkle Mountain Range. Supports proof generation, verification, and serialization. Dependencies: digest, tari_utilities, common MMR functions. Handles peak hashing and root verification for cryptographic proof systems. |
| `pruned_hashset.rs` | Specialized hash storage backend for Merkle Mountain Ranges that stores only peaks from a base offset. Implements memory-efficient MMR backend by storing only peak hashes from historical data plus new hashes. Exports: PrunedHashSet struct implementing ArrayLike trait. Dependencies: serde, digest, common::find_peaks, MerkleMountainRange. Used by: MMR backends for pruned storage. Key feature: Only stores peak hashes for historical data, saving memory while maintaining MMR functionality. Supports conversion from full MMR. |
| `serde_support.rs` | Serialization support utilities for MMR hash vectors. Provides custom serde serialization/deserialization for Vec&lt;Hash&gt; with human-readable (hex) and binary format support. Exports: hash module with serialize() and deserialize() functions for hash vectors. Dependencies: serde, tari_utilities::hex, crate::Hash. Used by: MMR structures requiring hash vector serialization. Handles both hex string format for human-readable serializers and binary format for compact serialization. |

###### base_layer/mmr/src/sparse_merkle_tree/

| File | Description |
|------|-------------|
| `bit_utils.rs` | Bit manipulation utilities for Sparse Merkle Tree operations. Provides bit-level operations for SMT navigation and key processing. Exports: get_bit(), count_common_prefix(), height_key(), bit_to_dir(), traverse_direction(), TraverseDirection enum. Dependencies: sparse_merkle_tree::{NodeKey, SMTError}. Used by: SMT implementation for tree traversal and key manipulation. Key functions: bit extraction, common prefix calculation for determining tree divergence points, branch key generation, and traversal direction determination. |
| `error.rs` | Error types for Sparse Merkle Tree operations. Defines comprehensive error enum for all SMT failure modes. Exports: SMTError enum with variants for array size, invalid branches, child key validation, node type mismatches, illegal keys, stale hashes, proof construction failures, and key existence conflicts. Dependencies: thiserror, NodeKey. Used by: All SMT modules for error handling. Provides detailed error context for debugging tree operations and proof generation. |
| `mod.rs` | Sparse Merkle Tree (SMT) module providing mutable Merkle tree with CRUD operations. Exports: SMTError, Node types (BranchNode, EmptyNode, LeafNode), NodeHash, NodeKey, ValueHash, SparseMerkleTree, UpdateResult, DeleteResult, proofs (InclusionProof, ExclusionProof). Supports inclusion and exclusion proofs. Example shows tree construction with Blake2b hashing and key-value operations. |
| `node.rs` | Core node types and hash utilities for Sparse Merkle Tree implementation. Defines Node enum (Empty, Leaf, Branch), hash types (NodeHash, ValueHash, NodeKey), and path iteration. Exports: Node enum, EmptyNode, LeafNode, BranchNode structs, hash types, PathIterator. Dependencies: digest, serde, bit_utils. Used by: SMT main implementation. Key features: 32-byte hash types with display formatting, lazy hash calculation for branch nodes, path iteration for tree traversal, node construction with validation. Implements core tree structure with type safety. |
| `proofs.rs` | Merkle proof implementation for Sparse Merkle Tree inclusion and exclusion proofs. Provides cryptographic proofs for key existence (inclusion) and non-existence (exclusion) in SMT. Exports: InclusionProof, ExclusionProof structs with validation methods. Dependencies: digest, SMT node types, bit_utils. Used by: SMT for generating and verifying membership proofs. Key features: proof generation from tree state, root hash validation, support for both inclusion and exclusion scenarios. Enables efficient verification of tree membership without full tree data. |
| `tree.rs` | Core SparseMerkleTree implementation with full CRUD operations. Exports: UpdateResult, DeleteResult enums, SparseMerkleTree struct. Methods: new, upsert, delete, get, generate inclusion/exclusion proofs, hash calculation. Generic over digest algorithms. Supports tree traversal, node operations, and cryptographic proof generation. Serializable with serde. |

##### base_layer/mmr/tests/

| File | Description |
|------|-------------|
| `mmr_integration_tests.rs` | MMR integration test entry point that organizes test modules. Minimal test runner that imports MMR support utilities and test modules for comprehensive Merkle Mountain Range functionality testing. Exports: test module structure. Used by: Cargo test infrastructure to organize integration tests. Enables running cryptographic integrity tests, performance benchmarks, and various MMR operations crucial for blockchain data structures. |

###### base_layer/mmr/tests/support/

| File | Description |
|------|-------------|
| `mod.rs` | Test support utilities for MMR integration tests. Provides common testing infrastructure including hash generation, MMR creation, and hash combination utilities. Exports: MmrTestHasherBlake256 type, TestMmr type, create_mmr(), int_to_hash(), combine_hashes(). Dependencies: blake2, tari_crypto, tari_mmr. Used by: MMR integration tests. Key features: domain-separated Blake256 hasher for test consistency, utilities for creating test MMRs with specified sizes, integer-to-hash conversion for deterministic test data. |

###### base_layer/mmr/tests/tests/

| File | Description |
|------|-------------|
| `mem_backend_vec.rs` | Unit tests for MemBackendVec ArrayLike implementation. Tests vector-based MMR backend operations including length, push, get, truncate, shift, and clear operations. Exports: test functions for MemBackendVec functionality. Dependencies: tari_mmr::{ArrayLike, ArrayLikeExt, MemBackendVec}. Used by: Cargo test framework. Validates that MemBackendVec correctly implements the ArrayLike trait for use as MMR storage backend. Tests both basic operations and edge cases for in-memory MMR storage. |
| `merkle_mountain_range.rs` | Comprehensive integration tests for Merkle Mountain Range core functionality. Tests MMR construction, root calculation, equality checks, validation, state restoration from leaf hashes, and leaf index finding. Exports: test functions for MMR operations. Dependencies: tari_mmr::common::LeafIndex, support test utilities. Used by: Cargo test framework. Key tests: zero-length MMR behavior, incremental MMR building with root verification, MMR equality comparisons, validation of large MMRs, leaf hash querying and restoration, leaf index lookup operations. Validates the structural integrity and core operations of the MMR. |
| `merkle_proof.rs` | Integration tests for MMR Merkle proof generation and verification. Tests proof creation for various MMR sizes, verification against roots, serialization/deserialization of proofs. Exports: test functions for MerkleProof functionality. Dependencies: tari_mmr::{MerkleProof, MerkleProofError}, tari_utilities::hex, support utilities. Used by: Cargo test framework. Key tests: zero-size MMR error handling, proof generation for all positions in small MMRs, medium and large MMR proof verification, leaf-specific proof generation, JSON and bincode serialization round-trips. Validates cryptographic integrity of MMR proofs. |
| `mod.rs` | Module declaration file organizing MMR test modules. Declares all test submodules for MMR functionality testing. Exports: test module organization. Dependencies: Individual test modules. Used by: Rust module system and Cargo test framework. Provides structure for MMR tests including memory backend tests, core MMR tests, proof tests, pruned MMR tests, and hash algorithm-specific tests. Enables organized test execution and discovery. |
| `pruned_mmr.rs` | Integration tests for pruned MMR functionality and root calculation utilities. Tests pruned MMR creation from full MMRs, functionality preservation after pruning, and standalone root calculation functions. Exports: test functions for pruned MMR operations. Dependencies: std::convert::TryFrom, rand, tari_mmr functions, support utilities. Used by: Cargo test framework. Key tests: empty pruned MMR handling, pruned MMR functionality with various sizes, random testing of root calculations, validation that pruned MMRs maintain equivalent behavior to full MMRs while using less memory. Tests memory optimization strategies. |
| `with_blake512_hash.rs` | Integration test validating MMR implementation with Blake2b-512 hash function. Tests MMR construction and hash generation with 512-bit Blake2b hasher against pre-computed expected values. Exports: hash_values() function, create_mmr() function, hash validation test. Dependencies: blake2, tari_crypto, tari_mmr, tari_utilities::hex. Used by: Cargo test framework. Contains hardcoded expected hash values for MMR with 23 leaf nodes using Blake2b-512 hasher. Validates hash calculation correctness and domain separation for MMR operations with larger hash outputs. |

#### base_layer/p2p/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for tari_p2p crate providing base layer peer-to-peer communication. Dependencies: tari_comms, tari_comms_dht, service_framework, common modules, anyhow, futures, prost, rand, tokio, tower, hickory-resolver/proto. Features: test-mocks for testing, auto-update with reqwest/pgp/semver. Handles blockchain network communication and DHT operations. |
| `README.md` | Brief documentation file for Tari P2P module. Contains only title "Tari P2P" indicating this is the main documentation entry point for the peer-to-peer communication layer of the Tari blockchain base layer. |
| `build.rs` | Build script for P2P module that compiles Protocol Buffer definitions. Generates Rust code from .proto files in src/proto directory using tari_common protobuf compiler. Exports: Compiled protobuf Rust code. Dependencies: tari_common::build::ProtobufCompiler. Used by: Cargo build system. Automatically rebuilds when .proto files change. Generates type-safe Rust bindings for P2P protocol message definitions used in network communication. |

##### base_layer/p2p/examples/

| File | Description |
|------|-------------|
| `README.md` | Documentation for P2P crate examples with usage instructions and requirements. Describes available examples including node identity generation and ping-pong networking demo. Documents C dependencies (ncurses), example descriptions, and command-line usage. Used by: Developers learning P2P functionality. Key examples: gen_node_identity.rs for creating node identity files, pingpong.rs for basic P2P messaging demonstration. Provides setup instructions and parameter descriptions for running P2P examples. |
| `example-log-config.yml` | Log4rs configuration example for P2P networking applications. Configures file-based logging for network components with detailed pattern formatting. Exports: Logging configuration for P2P examples. Dependencies: log4rs framework. Used by: P2P example applications. Defines separate log files for network communications and pingpong example, with trace-level logging and detailed timestamp/thread information. Essential for debugging P2P network issues and monitoring communication flows. |
| `gen_node_identity.rs` | Command-line utility for generating random node identity JSON files. Creates node identities with public/secret keys, node ID, and network address for P2P peer connections. Exports: CLI application binary. Dependencies: clap, rand, tari_comms, tari_utilities. Used by: Developers setting up P2P test networks. Generates random network addresses with localhost IP and random high ports. Creates JSON files containing serialized NodeIdentity objects for use in other P2P examples and testing scenarios. Essential tool for P2P network setup and testing. |
| `gen_tor_identity.rs` | Async command-line utility for generating Tor hidden service identity files. Creates Tor identity for anonymous P2P communication through Tor network. Exports: CLI application binary. Dependencies: clap, tari_comms::tor, tari_utilities, tokio. Used by: Developers setting up anonymous P2P networks. Connects to Tor control server, creates hidden service, and exports Tor identity as JSON. Essential for privacy-focused P2P deployments using Tor hidden services for network anonymity. |

###### base_layer/p2p/examples/sample_identities/

| File | Description |
|------|-------------|
| `node-identity1.json` | [GENERATED] Sample node identity JSON file for P2P example applications. Contains pre-generated node identity with public/private keys, node ID, and network address for testing purposes. Used by: P2P example applications and demos. Generated by: gen_node_identity.rs example. Provides ready-to-use peer identity for testing P2P networking without manual key generation. Essential for running P2P examples and demonstrations. |
| `node-identity2.json` | [GENERATED] Second sample node identity JSON file for P2P example applications. Contains pre-generated node identity for multi-peer testing scenarios. Used by: P2P example applications requiring multiple peer identities. Generated by: gen_node_identity.rs example. Enables testing of peer-to-peer communication with distinct node identities. Companion to node-identity1.json for demonstration of bidirectional P2P communication. |

##### base_layer/p2p/src/

| File | Description |
|------|-------------|
| `config.rs` | P2P and peer discovery configuration structures. Exports: P2pConfig, PeerSeedsConfig with network configuration. Dependencies: transport config, DHT config, multiaddr, serde. Used by: P2P network initialization. Defines comprehensive network settings including peer seeds, DNS discovery, transport options, RPC limits, liveness checking, and security policies with network-specific defaults. |
| `domain_message.rs` | Domain message wrapper providing source peer and origin information for received messages. Exports DomainMessage struct containing source_peer, dht_header, authenticated_origin, and inner message. Methods: inner(), into_inner(), map(), map_result(). Supports message forwarding detection and authentication. Used throughout P2P messaging for message provenance tracking. |
| `initialization.rs` | P2P communication stack initialization and configuration module. Provides comprehensive setup for Tari P2P networking including comms, DHT, transport layers, and peer management. Exports: CommsInitializationError, P2pInitializer, utility functions for comms setup. Dependencies: tari_comms, tari_comms_dht, tari_service_framework, numerous transport and config modules. Used by: Applications requiring P2P networking capabilities. Key features: multi-transport support (TCP, Tor, SOCKS5, Memory), DNS seed resolution, peer management, hidden service setup, network protocol initialization. Central orchestrator for P2P networking in Tari applications. |
| `lib.rs` | Peer-to-peer networking layer for Tari base layer communications. Provides network protocol versioning (MAJOR_NETWORK_VERSION: 0, MINOR_NETWORK_VERSION: 0), peer management, transport configuration for TCP/Tor/SOCKS5, domain message handling, and service initialization. Includes auto-update functionality, DNS resolution, authentication for SOCKS and Tor, and comprehensive test utilities. Exports transport configurations, peer seeding, protocol definitions, and communication connector for base node networking. Supports multiple transport types with backward compatibility. |
| `peer.rs` | Simple peer type definitions for P2P networking. Defines peer categorization and wrapper structures for typed peer handling. Exports: PeerType enum (BaseNode, ValidatorNode, Wallet, TokenWallet), PeerWithType struct. Dependencies: tari_comms::peer_manager::Peer. Used by: P2P layer for peer type management. Provides basic peer classification system for different node types in the Tari network. Minimal wrapper around comms peer functionality with type annotations. |
| `peer_seeds.rs` | DNS seed resolver for peer discovery in Tari P2P network. Exports: DnsSeedResolver (connects to DNS servers with/without DNSSEC), SeedPeer (parsed DNS seed record containing public key and addresses). Dependencies: tari_comms, tari_common::DnsNameServer, anyhow, log. Used by: P2P connection bootstrapping. Handles secure DNS queries for peer seed records, parses TXT records format 'pubkey::address', converts to Peer objects for peer manager. |
| `socks_authentication.rs` | SOCKS proxy authentication mechanisms for P2P networking. Handles SOCKS5 authentication protocols for proxy connections. Dependencies: likely tari_comms networking primitives. Used by: P2P connection layer when connecting through SOCKS proxies. Implements authentication handshake and credential management for proxy connections. |
| `tari_message.rs` | Tari message type definition and protobuf integration. Re-exports TariMessageType from proto::message_type module. Implements ToProtoEnum trait for TariMessageType enabling conversion to i32 for protocol buffer serialization. Core message type system for P2P communication in Tari network. |
| `test_utils.rs` | Testing utilities for P2P layer functionality. Provides helper functions, mock objects, and test fixtures for P2P component testing. Dependencies: tari_comms test utilities, likely tokio for async testing. Used by: P2P tests for creating test peers, mock connections, and test scenarios. Contains factory functions for test data generation and test environment setup. |
| `tor_authentication.rs` | Tor network authentication and connection handling for P2P networking. Manages Tor hidden service connections, authentication, and onion routing setup. Dependencies: likely tor client libraries and tari_comms. Used by: P2P layer for anonymous networking through Tor. Handles Tor control port authentication, hidden service creation, and onion address management. |
| `transport.rs` | Transport layer configuration for P2P communications. Exports: TransportConfig supporting multiple transport types (TCP, Tor, SOCKS5, Memory), TcpTransportConfig, TorTransportConfig with authentication and identity management, Socks5TransportConfig, MemoryTransportConfig. Integrates with tari_comms for network transport abstraction. Supports proxy authentication and Tor hidden services. |

###### base_layer/p2p/src/auto_update/

| File | Description |
|------|-------------|
| `dns.rs` | DNS-based software update checking service. Exports: DnsSoftwareUpdate, UpdateSpec structs with DNS TXT record parsing. Dependencies: DNS client, auto update config, application types. Used by: software update service. Queries DNS TXT records for software updates, validates update specifications with version comparison, enforces majority consensus for update acceptance, and provides secure update discovery mechanism. |
| `error.rs` | Error types for auto update functionality. Exports: AutoUpdateError enum. Dependencies: DNS client errors, HTTP request errors, PGP signature errors. Used by: auto update components. Defines comprehensive error handling for update operations including DNS lookup failures, download errors, and cryptographic signature verification failures. |
| `mod.rs` | Automatic software update system for Tari applications with cryptographic verification. Implements secure update checking via DNS, signature verification using PGP, and download management. Exports: AutoUpdateConfig, SoftwareUpdate, check_for_updates(), Version. Dependencies: semver, pgp, reqwest, tari_common. Used by: Tari applications for automated updates. Key features: DNS-based update discovery, PGP signature verification with maintainer keys, DNSSEC support, configurable update intervals. Ensures secure and verified software updates with cryptographic integrity checks. |
| `service.rs` | Software updater service with periodic update checking. Exports: SoftwareUpdaterService, SoftwareUpdaterHandle, SoftwareUpdateNotifier. Dependencies: auto update components, service framework, async channels. Used by: application initialization. Implements periodic software update checking, provides watch-based update notifications, handles manual update requests, and manages update version tracking with configurable check intervals. |
| `signature.rs` | PGP signature verification for software update integrity. Validates signed update packages against maintainer public keys to ensure authenticity. Exports: SignedMessageVerifier struct with verification methods. Dependencies: pgp, tari_utilities::hex. Used by: Auto-update system for cryptographic verification. Key functionality: PGP signature verification, hash-to-filename mapping from signed hash files, maintainer key validation. Critical security component ensuring only authenticated updates are accepted and installed. |

###### base_layer/p2p/src/auto_update/gpg_keys/

| File | Description |
|------|-------------|
| `README.md` | Documentation for Tari developer PGP public keys and signed commit practices. Explains GPG key management for software integrity verification and provides instructions for key generation, importing, signing commits, and submitting public keys. Used by: Developers contributing to Tari project. Documents security practices for code integrity, commit signing workflows, and key distribution. Essential reference for maintaining cryptographic verification of code contributions and releases. |
| `swvheerden.asc` | PGP public key for Tari developer swvheerden for software update signature verification. Contains ASCII-armored public key used to verify signed software updates and releases. Used by: Auto-update system for cryptographic verification. Dependencies: PGP/GPG infrastructure. Critical security component ensuring only authenticated updates from verified maintainers are accepted. Part of the chain of trust for Tari software distribution. |

###### base_layer/p2p/src/comms_connector/

| File | Description |
|------|-------------|
| `inbound_connector.rs` | Inbound message connector for P2P communications pipeline. Exports: InboundDomainConnector service implementing Tower Service trait. Dependencies: DHT messages, message headers, peer messages, async channels. Used by: P2P message processing pipeline. Decrypts and deserializes DHT messages, constructs PeerMessage objects, and forwards messages to pubsub system with comprehensive error handling. |
| `mod.rs` | Communication connector module entry point. Exports: InboundDomainConnector for handling inbound domain messages, PeerMessage for peer communication, pubsub_connector and PubsubDomainConnector for publish-subscribe messaging, SubscriptionFactory and TopicSubscriptionFactory for managing subscriptions. Provides abstraction layer between comms and domain-specific messaging. |
| `peer_message.rs` | Domain-level peer message structure for P2P communication. Wraps incoming network messages with peer information, headers, and authentication details. Exports: PeerMessage struct with decoding and origin identification methods. Dependencies: tari_comms, tari_comms_dht, prost. Used by: P2P message processing pipeline. Key features: protobuf message decoding, authenticated origin tracking, DHT header management. Central data structure for processing incoming peer-to-peer messages with full context information. |
| `pubsub.rs` | Publish-subscribe messaging system for P2P domain-level communication. Implements topic-based message routing with broadcast channels and subscription management. Exports: PubsubDomainConnector, SubscriptionFactory, TopicPayload, TopicSubscriptionFactory. Dependencies: futures, tokio, tokio_stream. Used by: P2P applications for event-driven messaging. Key features: topic-based subscriptions, lag detection, message filtering, concurrent subscription handling. Enables decoupled communication between P2P services through topic-based messaging patterns. |

###### base_layer/p2p/src/dns/

| File | Description |
|------|-------------|
| `client.rs` | DNS client implementation with DNSSEC support for secure domain resolution. Provides asynchronous DNS queries with TLS/DNSSEC protection and TXT record parsing. Exports: DnsClient struct with secure and standard connection methods. Dependencies: hickory_proto, hickory_resolver, tari_common. Used by: DNS seed resolution and auto-update system. Key features: secure DNS-over-TLS, DNSSEC validation, custom resolver configuration, TXT record parsing. Critical for secure peer discovery and update verification. |
| `error.rs` | Error types for DNS client operations and resolution failures. Defines comprehensive error enum for DNS-related failure modes including protocol errors, timeouts, and configuration issues. Exports: DnsClientError enum with variants for proto errors, timeouts, resolution failures, and connection issues. Dependencies: hickory_resolver, thiserror, std::io. Used by: DNS client and seed resolution components. Provides detailed error context for DNS operations and troubleshooting network connectivity issues. |
| `mod.rs` | DNS module organization and public interface. Re-exports DNS client and error types for external use. Exports: DnsClient, DnsClientError. Dependencies: Internal dns client and error modules. Used by: P2P modules requiring DNS functionality. Provides clean public API for DNS operations including secure resolution and error handling. Simple module structure organizing DNS functionality. |

###### base_layer/p2p/src/proto/

| File | Description |
|------|-------------|
| `liveness.proto` | Protocol Buffers definition for liveness ping/pong messages in Tari P2P networking. Defines: PingPong enum (Ping=0, Pong=1), PingPongMessage (ping_pong type, nonce, metadata map), MetadataKey enum (ChainMetadata, ContactsLiveness). Used by: liveness service for peer connectivity testing. Generated into Rust code via tari_comms build process. Supports metadata attachment for chain state and contact information exchange. |
| `message_type.proto` | Protocol Buffers definition for Tari message types in P2P communication. Defines: TariMessageType enum with categories - NetMessages (PingPong=1, Chat=2), Blockchain messages (NewTransaction=65, NewBlock=66, BaseNodeRequest=69, etc.), Extended messages (Text=225, TextAck=226). Used by: message routing and type identification in P2P layer. Immutable 32-bit identifiers for network protocol message classification. |
| `mod.rs` | Protocol Buffers module declarations for P2P layer. Exports: liveness module (ping/pong protocol), message_type module (Tari message classification). Uses tari_comms::outdir_include! macro to include generated protobuf Rust code. Dependencies: Generated .rs files from .proto compilation. Used by: P2P services requiring protobuf message serialization/deserialization. Disables clippy warnings for generated code. |

###### base_layer/p2p/src/services/

| File | Description |
|------|-------------|
| `mod.rs` | Module declarations for P2P services. Exports: liveness module (peer connectivity monitoring), monitor_peers module (peer monitoring functionality), utils module (service utilities). Used by: P2P layer to organize service-related functionality. Simple module declaration file grouping related P2P service implementations. |
| `utils.rs` | Utility functions for P2P services. Provides common functionality shared across P2P service implementations. Dependencies: likely tari_comms and standard library. Used by: liveness, monitor_peers, and other P2P services for shared operations like message handling, peer validation, or common data transformations. |

###### base_layer/p2p/src/services/liveness/

| File | Description |
|------|-------------|
| `config.rs` | Configuration struct for liveness service peer monitoring. Exports: LivenessConfig with fields - auto_ping_interval (optional periodic ping duration), num_peers_per_round (default 8), monitored_peers (always pinged peers), max_allowed_ping_failures (disconnection threshold, default 2). Dependencies: std::time::Duration, tari_comms::peer_manager::NodeId. Used by: LivenessService initialization. Default implementation disables auto-ping, enables failure-based disconnection. |
| `error.rs` | Error types for liveness service operations. Exports: LivenessError enum with variants - DhtOutboundError, ConnectivityError, PeerConnectionError, DhtActorError, SendPing/PongFailed, MessageError, UnexpectedApiResponse, EventStreamError, TransportChannelError, InvalidPingPongType, NodeIdDoesNotExist, PingPongDecodeError, PeerNotFoundError, JoinError. Dependencies: tari_comms error types, tari_comms_dht errors, thiserror, tokio::task::JoinError. Used by: all liveness service components for error handling. |
| `handle.rs` | Handle and request/response types for liveness service. Exports: LivenessRequest enum (SendPing, SendPings, GetPingCount, GetPongCount, GetAvgLatency, SetMetadataEntry, AddMonitoredPeer, RemoveMonitoredPeer), LivenessResponse enum (Ok, Count, AvgLatency, NumActiveNeighbours), LivenessEvent enum (ReceivedPing, ReceivedPong, PingRoundBroadcast), PingPongEvent struct, LivenessHandle. Dependencies: tari_service_framework::reply_channel, tokio::sync::broadcast. Used by: external services to interact with liveness service, provides async API for ping operations and statistics. |
| `message.rs` | Message construction utilities for ping/pong protocols. Exports: PingPongMessage implementation with methods - new(), ping_with_metadata(), pong_with_metadata(), kind(). Re-exports: PingPong, PingPongMessage from proto module. Dependencies: rand (for nonce generation), crate::proto::liveness, state::Metadata. Used by: liveness service for creating ping/pong messages with random nonces and metadata. Generates cryptographically secure nonces using OsRng. |
| `mock.rs` | Mock implementation for liveness service testing. Exports: create_p2p_liveness_mock() (factory function), LivenessMock (mock service), LivenessMockState (shared state for testing). Key features: tracks request calls, publishes mock events, provides fake responses for all LivenessRequest types. Dependencies: tari_service_framework::reply_channel, tokio::sync::broadcast, futures. Used by: unit tests and integration tests requiring liveness service simulation. Maintains call counts and request history for test assertions. |
| `mod.rs` | Liveness service for peer health monitoring through ping/pong messaging. Exports: LivenessConfig, LivenessHandle, LivenessInitializer, various request/response/event types, PingPongEvent, Metadata, MetadataKey. Implements ServiceInitializer trait. Handles ping/pong counters, peer connectivity monitoring, and maintains basic availability statistics. Integrates with DHT and connectivity services. |
| `service.rs` | Core liveness service implementation for peer connectivity monitoring. Exports: LivenessService struct, MAX_INFLIGHT_TTL constant (30s). Key methods: run() (main service loop), handle_incoming_message(), send_ping(), send_pong(), handle_request(), start_ping_round(), disconnect_failed_peers(). Dependencies: tari_comms (connectivity, peer management), tari_comms_dht (outbound messaging), tari_service_framework, tari_shutdown. Used by: P2P service framework. Manages ping rounds, tracks latency, handles peer failures, publishes events. Contains comprehensive tests for ping/pong message handling. |
| `state.rs` | Liveness service state management for tracking ping/pong statistics and inflight pings. Exports: LivenessState (ping counts, latency tracking, inflight ping management), Metadata (wrapper for metadata key-value map). Key methods: add_inflight_ping(), record_pong(), get_avg_latency(), inc_pings_received/sent(), set_metadata_entry(). Dependencies: tari_comms::peer_manager::NodeId, crate::proto::liveness::MetadataKey. Used by: LivenessService for maintaining peer connectivity state, latency history, and ping tracking with TTL expiration. |

###### base_layer/p2p/src/services/monitor_peers/

| File | Description |
|------|-------------|
| `mod.rs` | Module declaration for peer monitoring service. Exports: service module (peer monitoring implementation). Used by: P2P layer for peer lifecycle monitoring and management. Organizes peer monitoring functionality separate from liveness checking. |
| `service.rs` | Peer monitoring service implementation for tracking peer lifecycle events. Monitors peer connections, disconnections, and state changes. Dependencies: tari_comms for peer management and connectivity events. Used by: P2P service framework for peer state tracking and lifecycle management. Complements liveness service by tracking connection-level events rather than application-level ping/pong. |

##### base_layer/p2p/tests/

| File | Description |
|------|-------------|
| `mod.rs` | Test module declarations for P2P layer. Organizes test modules for P2P functionality testing. Used by: Rust test runner to discover and execute P2P integration tests. Declares test submodules for services and support utilities. |

###### base_layer/p2p/tests/data/

| File | Description |
|------|-------------|
| `.gitkeep` | [GENERATED] Git placeholder file to preserve empty test data directory. No code content. Used by: git version control to maintain directory structure for P2P test data files that may be created during test execution. |

###### base_layer/p2p/tests/services/

| File | Description |
|------|-------------|
| `liveness.rs` | Integration tests for liveness service functionality. Tests ping/pong message handling, peer connectivity monitoring, latency tracking, and failure detection. Dependencies: liveness service components, test utilities, tokio for async testing. Used by: test suite to verify liveness service behavior in realistic network scenarios. |
| `mod.rs` | Test module declarations for P2P services. Organizes integration tests for P2P service components. Exports: liveness test module. Used by: test framework to discover and run service-level integration tests. |

###### base_layer/p2p/tests/support/

| File | Description |
|------|-------------|
| `comms_and_services.rs` | Test support utilities for communications and services setup. Provides factory functions and helpers for creating test communication infrastructure and service instances. Dependencies: tari_comms, service framework. Used by: P2P integration tests for setting up realistic test environments with multiple nodes and services. |
| `mod.rs` | Test support module declarations for P2P layer. Organizes test utilities and support code. Exports: comms_and_services module (communication test utilities). Used by: P2P integration tests to access shared test infrastructure and helper functions. |

#### base_layer/service_framework/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for tari_service_framework providing communication stack service framework. Dependencies: tari_shutdown, anyhow, async-trait, futures, log, thiserror, tokio, tower-service. Dev dependencies: tari_test_utils, tokio with multi-thread runtime, futures-test, tower. Core infrastructure for building and managing async services in the Tari communication stack. |
| `README.md` | Brief documentation for Tari Service framework. Contains only title indicating this is the main documentation entry point for the service framework that provides infrastructure for building and managing async services in the Tari communication stack. Used by: Developers building distributed applications, documentation reference for Tari's service-oriented architecture. Provides patterns and tools for service lifecycle management, dependency injection, and inter-service communication. |

##### base_layer/service_framework/examples/

| File | Description |
|------|-------------|
| `stack_builder_example.rs` | Example demonstrating service framework stack builder usage. Shows how to construct and configure service stacks using the builder pattern. Dependencies: tari_service_framework, example services. Used by: developers learning to compose multiple services into application stacks. Demonstrates service dependency injection and stack initialization. |

###### base_layer/service_framework/examples/services/

| File | Description |
|------|-------------|
| `mod.rs` | Example service module declarations for service framework. Organizes example service implementations demonstrating framework usage. Exports: service_a, service_b modules. Used by: developers learning to build and manage services within the Tari service framework. Provides practical illustrations of service initialization, inter-service communication, and lifecycle management. |
| `service_a.rs` | Example service A implementation demonstrating service framework patterns. Shows service initialization, message handling, and inter-service communication. Dependencies: tari_service_framework. Used by: developers as reference implementation for creating services within the framework. Demonstrates typical service lifecycle and communication patterns. |
| `service_b.rs` | Example service B implementation demonstrating alternative service framework patterns. Complements service_a by showing different service communication and coordination approaches. Dependencies: tari_service_framework. Used by: developers as reference for service-to-service interaction patterns and advanced framework features. |

##### base_layer/service_framework/src/

| File | Description |
|------|-------------|
| `initializer.rs` | Service initialization traits and implementations for service framework. Exports: ServiceInitializer trait (async initialization), InitializerFn (function wrapper). Key types: ServiceInitializationError (anyhow::Error). Dependencies: async_trait, ServiceInitializerContext. Used by: services to implement initialization logic, framework to manage service startup. Supports both trait implementations and function closures for initialization. |
| `lib.rs` | Async service framework providing building blocks for service-oriented architecture in Tari. Implements ServiceInitializer trait for service setup, StackBuilder for service orchestration, ServiceHandles for inter-service communication, and reply_channel for request-response patterns. Includes LazyService for deferred initialization, RegisterHandle for handle management, and tower-service integration. Provides structured approach to building complex async applications with proper service lifecycle management and dependency injection capabilities. |
| `reply_channel.rs` | Reply channel implementation for request-response patterns in service framework. Provides async request-response communication between services. Dependencies: likely tokio channels and futures. Used by: services for RPC-style communication patterns. Implements request routing, response handling, and error propagation for inter-service communication. |
| `stack.rs` | Service stack builder for initializing and managing multiple services. Exports StackBuilder for collecting service initializers and handles. Manages service lifecycle with shutdown signals, provides async initialization, and coordinates service startup. Dependencies: futures, tari_shutdown, ServiceInitializer trait. Core component for building modular service architectures. |
| `utilities.rs` | Utility functions and helpers for service framework operations. Provides common functionality shared across framework components. Dependencies: likely standard library and framework core types. Used by: framework components for shared operations like service registration, message handling, or lifecycle management. |

###### base_layer/service_framework/src/context/

| File | Description |
|------|-------------|
| `handles.rs` | Service handle management for framework context. Provides service handle storage, retrieval, and lifetime management within service contexts. Dependencies: service framework core types. Used by: service context to manage handles to other services for inter-service communication. Implements handle registry and dependency injection patterns. |
| `lazy_service.rs` | Lazy service initialization support for service framework. Enables deferred service creation and initialization until first access. Dependencies: service framework core, likely futures for async initialization. Used by: service framework to optimize startup performance and handle circular dependencies. Implements lazy loading patterns for service instantiation. |
| `mod.rs` | Service framework context module declarations. Organizes context-related functionality including service handles and lazy initialization. Exports: handles module (service handle management), lazy_service module (deferred initialization). Used by: service framework to provide context and dependency injection capabilities essential for inter-service communication and dependency management within a service-oriented architecture. |

###### base_layer/service_framework/src/tower/

| File | Description |
|------|-------------|
| `mod.rs` | Tower service integration module for service framework. Provides Tower ecosystem compatibility for service composition and middleware. Exports: service_ext module (service extensions). Used by: service framework to leverage Tower's service abstractions, middleware, and composition patterns. |
| `service_ext.rs` | Tower service extensions for enhanced service functionality. Provides extension traits and utilities for Tower services within the framework. Dependencies: tower crate, service framework types. Used by: services needing Tower middleware integration, timeout handling, or service composition. Bridges Tower ecosystem with Tari service framework. |

#### base_layer/tari_mining_helper_ffi/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for minotari_mining_helper_ffi providing C FFI bindings for mining operations. Builds as cdylib for C interop. Dependencies: tari_comms, tari_crypto, tari_core, tari_common modules, libc, thiserror, borsh, tokio. Build dependencies: tari_features, cbindgen for C header generation. Includes network-specific configuration flags. |
| `build.rs` | Build script for Tari mining helper FFI (Foreign Function Interface). Generates C/C++ bindings for mining functionality. Dependencies: likely cbindgen or similar FFI generation tools. Used by: C/C++ applications needing access to Tari mining functions. Configures compilation flags and generates header files during build process. |
| `tari_mining_helper.h` | [GENERATED] C header file for Tari mining helper FFI functions. Declares C-compatible function signatures for mining operations. Generated by: build.rs script during compilation using cbindgen. Used by: C/C++ mining applications to interface with Tari mining functionality. Contains function declarations, structs, and constants for mining operations. Auto-generated: do not modify manually. |

##### base_layer/tari_mining_helper_ffi/src/

| File | Description |
|------|-------------|
| `error.rs` | Error types for mining helper FFI interface. Exports InterfaceError enum covering null parameters, conversion failures, hash validation, difficulty checks, allocation errors, position validation, tokio runtime issues, coinbase creation, address/network validation, and KeyManager errors. Implements conversion from tari_utilities::HexError. Used for error handling in C FFI bindings. |
| `lib.rs` | Foreign Function Interface (FFI) library providing C-compatible mining utilities for external mining software integration. Implements block template manipulation (inject_coinbase, inject_nonce), share validation (share_validate, share_difficulty), public key validation (public_key_hex_validate), ByteVector utilities for memory management, and comprehensive error handling. Supports multiple networks, stealth payments, revealed value proofs, SHA3 difficulty calculations, and Tari address validation. Enables integration with mining pools, external miners, and blockchain infrastructure requiring low-level mining operations with C/C++ compatibility. |

#### base_layer/wallet/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for minotari_wallet providing Tari cryptocurrency wallet library. Major dependencies: tari_core (transactions, mempool, base_node protocols), tari_comms/comms_dht, tari_key_manager, diesel ORM, tokio async runtime, cryptography libraries (argon2, blake2, chacha20poly1305). Features: bundled_sqlite (default), c_integration, ledger support. Comprehensive wallet functionality for Tari blockchain. |
| `README.md` | Documentation for Minotari Wallet FFI (Foreign Function Interface) for mobile applications. Provides build instructions for Android and iOS wallet integration and database migration procedures. Used by: Mobile app developers integrating Tari wallet functionality. Key information: build setup for Mac/Windows, diesel CLI requirements for SQLite migrations, migration execution instructions. References wallet_ffi crate for detailed setup. Documents database schema management and SQLite migration workflows for wallet data persistence. |
| `build.rs` | Build script for wallet component compilation. Handles build-time code generation, feature flags, and compilation configuration for wallet functionality. Dependencies: likely diesel migrations, build utilities. Used by: Cargo during wallet compilation. May generate database schemas, embed migrations, or configure feature-dependent compilation. |
| `diesel.toml` | Diesel ORM configuration for wallet database operations. Configures database schema location, migration paths, and code generation settings. Used by: Diesel CLI and build process for wallet database management. Specifies schema file location and migration directory for SQL database operations. |

###### base_layer/wallet/migrations/2022-08-08-134037_initial/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for initial wallet schema. Reverts initial table creation including completed_transactions, inbound_transactions, outbound_transactions, outputs, scanned_blocks, wallet_settings, client_key_values, known_one_sided_payment_scripts. Used by: Diesel migration system to rollback to pre-wallet state. Part of 2022-08-08 initial wallet database migration. |
| `up.sql` | Initial wallet database schema migration. Creates core wallet tables: client_key_values (key-value storage), completed_transactions (finalized transactions), inbound_transactions (received), outbound_transactions (sent), outputs (UTXOs with cryptographic data), scanned_blocks (chain scanning state), wallet_settings (configuration), known_one_sided_payment_scripts (one-sided payment tracking). Establishes primary keys, constraints, and indexes for wallet operations. |

###### base_layer/wallet/migrations/2022-11-29-113713_fix_up_settings_keys/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for wallet settings key fixes. Reverts changes to wallet_settings key standardization or corrections made in 2022-11-29 migration. Used by: Diesel migration system for rollback. Part of wallet settings key normalization updates. |
| `up.sql` | Database migration to fix wallet settings key standardization. Updates or corrects wallet_settings table key values for consistency and proper functioning. Applied: 2022-11-29. Used by: wallet initialization to ensure settings keys follow expected format and naming conventions. |

###### base_layer/wallet/migrations/2022-12-07-110000/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for 2022-12-07 wallet schema changes. Reverts structural changes or additions made to wallet database schema. Used by: Diesel migration system for version rollback. Part of December 2022 wallet database updates. |
| `up.sql` | Database migration for wallet schema updates dated 2022-12-07. Adds or modifies wallet database structures for enhanced functionality. Applied: December 7, 2022. Used by: wallet service for database schema evolution and new feature support. |

###### base_layer/wallet/migrations/2022-12-09-114100_rename_metadata_to_coinbase_extra/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for metadata to coinbase_extra field rename. Reverts column name change from coinbase_extra back to metadata in relevant wallet tables. Used by: Diesel migration system for rollback. Part of December 2022 coinbase metadata field standardization. |
| `up.sql` | Database migration renaming metadata field to coinbase_extra. Updates column names in wallet tables to clarify coinbase transaction extra data handling. Applied: 2022-12-09. Used by: wallet to distinguish between general metadata and coinbase-specific extra data fields. |

###### base_layer/wallet/migrations/2023-05-05-064704_burn_tari/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for Tari burn functionality. Reverts burn-related schema changes from 2023-05-05 migration. Used by: Diesel migration system for rollback. Part of Tari burning feature removal. |
| `up.sql` | Database migration adding Tari burn functionality support. Adds schema changes to support token burning operations in wallet. Applied: 2023-05-05. Used by: wallet to track and manage Tari token burn transactions and operations. |

###### base_layer/wallet/migrations/2023-05-15-112514_encrypted_openings/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for encrypted output openings. Reverts encryption-related schema changes for output opening data from 2023-05-15 migration. Used by: Diesel migration system for rollback. Part of output encryption feature removal. |
| `up.sql` | Database migration adding encrypted output openings support. Adds schema changes to store encrypted output opening data for enhanced privacy. Applied: 2023-05-15. Used by: wallet output manager to securely store and retrieve encrypted output commitments and opening values. |

###### base_layer/wallet/migrations/2023-06-08-073134_key_ids/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for key ID schema changes. Reverts key identification system modifications from 2023-06-08 migration. Used by: Diesel migration system for rollback. Part of key management system changes. |
| `up.sql` | Database migration adding key ID tracking system. Adds schema changes to improve key identification and management within wallet. Applied: 2023-06-08. Used by: wallet key management for better tracking of cryptographic keys and their relationships. |

###### base_layer/wallet/migrations/2023-06-20-134300_rangeproof/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for range proof schema changes. Reverts range proof storage and handling modifications from 2023-06-20 migration. Used by: Diesel migration system for rollback. Part of cryptographic proof system changes. |
| `up.sql` | Database migration updating range proof handling. Modifies schema for improved range proof storage and validation in wallet outputs. Applied: 2023-06-20. Used by: wallet output manager for cryptographic range proof management and verification. |

###### base_layer/wallet/migrations/2023-10-06-10000_drop_mmr/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for MMR (Merkle Mountain Range) removal. Reverts MMR-related schema cleanup from 2023-10-06 migration. Used by: Diesel migration system for rollback. Part of MMR architecture removal from wallet. |
| `up.sql` | Database migration removing MMR (Merkle Mountain Range) data. Drops MMR-related columns and tables no longer needed in wallet architecture. Applied: 2023-10-06. Used by: wallet to clean up deprecated MMR storage and simplify schema. |

###### base_layer/wallet/migrations/2023-11-03-161500_transaction_protocol/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for transaction protocol enhancements. Reverts transaction protocol schema changes from 2023-11-03 migration. Used by: Diesel migration system for rollback. Part of transaction protocol feature removal. |
| `up.sql` | Database migration adding transaction protocol support. Adds schema changes for enhanced transaction protocol handling and state management. Applied: 2023-11-03. Used by: wallet transaction service for managing complex transaction protocols and multi-party transaction flows. |

###### base_layer/wallet/migrations/2023-11-13-082000_transaction_protocols/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for transaction protocols refinements. Reverts transaction protocol system updates from 2023-11-13 migration. Used by: Diesel migration system for rollback. |
| `up.sql` | Database migration updating transaction protocols system. Further refinements to transaction protocol storage and handling. Applied: 2023-11-13. Used by: wallet transaction service for improved protocol state management and multi-step transaction coordination. |

###### base_layer/wallet/migrations/2023-11-14-131400_coinbase/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for coinbase transaction improvements. Reverts coinbase handling enhancements from 2023-11-14 migration. Used by: Diesel migration system for rollback. |
| `up.sql` | Database migration adding coinbase transaction handling improvements. Enhances schema for better coinbase transaction tracking and management. Applied: 2023-11-14. Used by: wallet to properly handle mining rewards and coinbase-specific transaction properties. |

###### base_layer/wallet/migrations/2024-05-13-101400_payment_id/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for payment ID functionality. Reverts payment ID schema changes from 2024-05-13 migration. Used by: Diesel migration system for rollback. |
| `up.sql` | Database migration adding payment ID functionality. Adds schema support for payment identification and tracking. Applied: 2024-05-13. Used by: wallet transaction service for payment correlation and identification across transaction flows. |

###### base_layer/wallet/migrations/2024-12-05-110700-payment_id/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for payment ID system updates. Reverts payment ID refinements from 2024-12-05 migration. Used by: Diesel migration system for rollback. |
| `up.sql` | Database migration updating payment ID system. Refinements to payment ID functionality and schema. Applied: 2024-12-05. Used by: wallet for improved payment identification and transaction correlation. |

###### base_layer/wallet/migrations/2024-12-09-134400-message/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for transaction message functionality. Reverts message-related schema changes from 2024-12-09 migration. Used by: Diesel migration system for rollback. |
| `up.sql` | Database migration adding message functionality to transactions. Adds schema support for transaction messages and communication. Applied: 2024-12-09. Used by: wallet transaction service for message attachment and transaction communication features. |

###### base_layer/wallet/migrations/2025-01-06-120000_payref_support/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for PayRef support. Removes output hash columns (sent_output_hashes, received_output_hashes, change_output_hashes) and PayRef index from transaction tables. Used by: Diesel migration system to revert PayRef functionality. Part of 2025-01-06 PayRef feature rollback. |
| `up.sql` | Database migration adding PayRef support for output hash tracking. Adds sent_output_hashes, received_output_hashes, change_output_hashes BLOB columns to transaction tables (completed_transactions, outbound_transactions, inbound_transactions). Creates index on mined_in_block for PayRef lookups. Applied: 2025-01-06. Enables payment reference functionality for transaction output tracking. |

###### base_layer/wallet/migrations/2025-04-25-161400_payment_id/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for payment ID enhancements. Reverts payment ID system improvements from 2025-04-25 migration. Used by: Diesel migration system for rollback. |
| `up.sql` | Database migration for payment ID system enhancement. Latest updates to payment ID functionality and schema optimization. Applied: 2025-04-25. Used by: wallet for advanced payment identification and transaction tracking capabilities. |

###### base_layer/wallet/migrations/2025-06-06-160000_payref_table/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback for PayRef table creation. Removes PayRef table and related indexes from 2025-06-06 migration. Used by: Diesel migration system for rollback. Part of PayRef functionality removal. |
| `up.sql` | Database migration creating PayRef table for payment reference tracking. Adds dedicated table for payment reference management and lookup functionality. Applied: 2025-06-06. Used by: wallet PayRef service for efficient payment reference storage and retrieval. |

##### base_layer/wallet/src/

| File | Description |
|------|-------------|
| `config.rs` | Wallet configuration structure and settings. Exports: WalletConfig (main configuration), TransactionStage enum (transaction lifecycle stages). Key fields: p2p config, transaction/output manager configs, network selection, database settings, GRPC options, fee settings, recovery parameters. Dependencies: tari_common configuration, tari_p2p::P2pConfig, serde. Used by: wallet initialization and service configuration. Implements defaults, path resolution, and sub-config organization. |
| `error.rs` | Top-level error types for wallet operations. Defines error variants for wallet initialization, service communication, database operations, and transaction processing failures. Dependencies: thiserror, service error types. Used by: all wallet components for error handling and propagation. Aggregates errors from various wallet subsystems. |
| `lib.rs` | Core wallet library for Minotari implementing wallet functionality with modular service architecture. Provides base_node_service for blockchain interaction, connectivity_service for network management, output_manager_service for UTXO handling, transaction_service for transaction management, and utxo_scanner_service for blockchain scanning. Includes SQLite storage implementations for all services with Diesel ORM integration. Exports main Wallet struct and WalletSqlite type alias with all SQLite backends configured. Supports operation tracking, contacts management, and transaction key management with comprehensive error handling. |
| `macros.rs` | Utility macros for wallet operations. Provides convenience macros for common wallet patterns like error handling, logging, and service communication. Used by: wallet components to reduce boilerplate code and ensure consistent patterns across the wallet codebase. |
| `operation_id.rs` | Operation ID type and utilities for wallet transaction tracking. Provides unique identifiers for wallet operations and transaction correlation. Dependencies: likely UUID or similar ID generation. Used by: wallet services to track and correlate multi-step operations, transaction protocols, and async operations across service boundaries. |
| `schema.rs` | [GENERATED] Diesel ORM schema definitions for wallet database tables. Contains table definitions and column mappings for all wallet database tables including outputs, transactions, settings, and scanned blocks. Generated by: Diesel CLI from database migrations. Used by: Diesel ORM for type-safe database operations throughout wallet codebase. |
| `test_utils.rs` | Testing utilities and helper functions for wallet component testing. Provides mock objects, test fixtures, and utility functions for wallet testing scenarios. Dependencies: wallet components, test frameworks. Used by: wallet tests for creating test environments, mock services, and test data generation. |
| `wallet.rs` | Main wallet implementation orchestrating all wallet services and providing unified wallet functionality. Exports: Wallet (primary wallet interface), WalletSqlite (SQLite-backed wallet), WalletConfig (wallet configuration). Key services include transaction service, output manager, key manager, contacts service, connectivity, base node service, and UTXO scanner. Handles: wallet initialization, service coordination, P2P networking setup, identity management, and comprehensive wallet operations. Dependencies: all wallet services, P2P stack, consensus manager, crypto factories. Used as: primary entry point for wallet applications. Implements complex service orchestration with proper lifecycle management, configuration handling, and inter-service communication setup. |

###### base_layer/wallet/src/base_node_service/

| File | Description |
|------|-------------|
| `config.rs` | Configuration for wallet base node service interactions. Defines settings for base node communication, sync intervals, request timeouts, and chain monitoring parameters. Dependencies: serde for serialization. Used by: base node service for configuring blockchain interaction behavior, sync frequency, and connection management. |
| `error.rs` | Error types for wallet base node service operations. Defines error variants for base node communication failures, sync errors, validation errors, and connectivity issues. Dependencies: thiserror for error derivation, relevant service error types. Used by: base node service components for error handling and propagation. |
| `handle.rs` | Handle and request/response types for base node service communication. Exports: BaseNodeServiceHandle (async API), request/response enums for blockchain queries, chain state monitoring, and block validation. Dependencies: service framework reply channels. Used by: wallet components to interact with base node service for blockchain data and validation. |
| `mod.rs` | Base node service module declarations for wallet. Organizes base node communication functionality including configuration, error handling, service implementation, and monitoring. Exports: config, error, handle, monitor, service modules. Used by: wallet to interact with Tari base nodes for blockchain state and validation. |
| `monitor.rs` | Base node monitoring service for wallet blockchain state tracking. Monitors base node connectivity, chain tip updates, and network status. Dependencies: base node service components, connectivity monitoring. Used by: wallet to maintain awareness of blockchain state and detect chain reorganizations or connectivity issues. |
| `service.rs` | Core base node service implementation for wallet blockchain interaction. Handles base node communication, chain state queries, block validation, and transaction broadcasting. Dependencies: tari_comms, blockchain types, service framework. Used by: wallet components requiring blockchain data access, transaction submission, and chain state monitoring. Implements async request handling and chain sync logic. |

###### base_layer/wallet/src/connectivity_service/

| File | Description |
|------|-------------|
| `base_node_peer_manager.rs` | Base node peer management for wallet connectivity service. Manages connections to base nodes, peer discovery, and connection quality monitoring. Dependencies: tari_comms peer management. Used by: connectivity service to maintain reliable connections to blockchain nodes for transaction broadcasting and chain state queries. |
| `error.rs` | Error types for wallet connectivity service operations. Defines error variants for connection failures, peer discovery issues, and network communication problems. Dependencies: thiserror, tari_comms error types. Used by: connectivity service components for error handling in network operations and peer management. |
| `handle.rs` | Handle and request/response types for connectivity service communication. Exports: ConnectivityHandle (async API), request/response enums for peer management, connection monitoring, and network status queries. Dependencies: service framework reply channels. Used by: wallet components to interact with connectivity service for network management and peer operations. |
| `initializer.rs` | Service initializer for wallet connectivity service. Handles service startup, configuration loading, and dependency injection for connectivity functionality. Dependencies: service framework initializer traits. Used by: wallet service stack to initialize connectivity service with proper configuration and dependencies. |
| `interface.rs` | Interface traits and definitions for connectivity service. Defines abstract interfaces for connectivity operations, allowing for different implementations and testing. Dependencies: connectivity service types. Used by: connectivity service for abstraction and testability, enabling mock implementations and interface segregation. |
| `mock.rs` | Mock implementation for connectivity service testing. Provides fake connectivity operations and network simulation for testing wallet components. Dependencies: connectivity service interfaces. Used by: wallet tests to simulate network conditions, connection failures, and peer management scenarios without real network interactions. |
| `mod.rs` | Connectivity service module declarations for wallet network management. Organizes network connectivity functionality including peer management, error handling, service implementation, and testing. Exports: base_node_peer_manager, error, handle, initializer, interface, mock, service, test modules. Used by: wallet for managing network connections and peer relationships. |
| `service.rs` | Core connectivity service implementation for wallet network management. Handles peer discovery, connection management, network monitoring, and connectivity state tracking. Dependencies: tari_comms, service framework. Used by: wallet components requiring network connectivity for blockchain interaction, transaction broadcasting, and peer communication. Implements async network operations and connection lifecycle management. |
| `test.rs` | Unit tests for connectivity service functionality. Tests peer management, connection handling, and network state monitoring. Dependencies: connectivity service components, test utilities. Used by: test suite to verify connectivity service behavior and ensure proper network management functionality. |

###### base_layer/wallet/src/output_manager_service/

| File | Description |
|------|-------------|
| `config.rs` | Configuration for wallet output manager service. Exports: OutputManagerServiceConfig with settings - prevent_fee_gt_amount (dust protection), dust_ignore_value (100 µT default), event_channel_size (250), num_confirmations_required (3), tx_validator_batch_size (100), autoignore_onesided_utxos (privacy protection), num_of_seconds_to_revalidate_invalid_utxos (3 days). Dependencies: serde. Used by: output manager for UTXO management, fee validation, and transaction input selection behavior. |
| `error.rs` | Error types for wallet output manager service operations. Defines error variants for UTXO management failures, insufficient funds, output validation errors, and database operation failures. Dependencies: thiserror, database error types. Used by: output manager components for error handling in UTXO operations, transaction building, and output validation. |
| `handle.rs` | Handle and request/response types for output manager service communication. Exports: OutputManagerHandle (async API), request/response enums for UTXO queries, output creation, spending operations, and balance calculations. Dependencies: service framework reply channels, cryptographic types. Used by: wallet transaction service and UI components for UTXO management and balance operations. |
| `input_selection.rs` | Input selection algorithms for wallet transaction building. Implements UTXO selection strategies for optimizing transaction fees, privacy, and output consolidation. Dependencies: cryptographic types, output manager types. Used by: output manager service for choosing optimal UTXOs when constructing transactions. Includes algorithms for coin selection, dust handling, and fee optimization. |
| `mod.rs` | Output manager service module declarations for wallet UTXO management. Organizes UTXO-related functionality including configuration, error handling, input selection, and service implementation. Exports: config, error, handle, input_selection, mod submodules. Used by: wallet for managing unspent transaction outputs, transaction building, and balance calculations. |
| `resources.rs` | Resource management for output manager service operations. Handles resource allocation, cleanup, and lifecycle management for UTXO operations. Dependencies: output manager types. Used by: output manager service for managing computational resources, memory usage, and cleanup during output processing and transaction building. |
| `service.rs` | Core output manager service implementation for wallet UTXO management. Handles output creation, spending, validation, and lifecycle management. Implements transaction input selection, balance calculations, and output state tracking. Dependencies: cryptographic types, database backend, service framework. Used by: wallet transaction service for UTXO operations, transaction building, and balance management. Includes comprehensive output validation and privacy features. |

###### base_layer/wallet/src/output_manager_service/recovery/

| File | Description |
|------|-------------|
| `mod.rs` | Output recovery module declarations for wallet UTXO recovery functionality. Organizes recovery-related functionality for restoring wallet outputs from blockchain scanning. Exports: standard_outputs_recoverer module. Used by: output manager service for wallet recovery operations after seed restoration or corruption. |
| `standard_outputs_recoverer.rs` | Standard output recovery implementation for wallet UTXO restoration. Implements blockchain scanning and output detection algorithms for recovering wallet outputs after seed restoration. Dependencies: blockchain scanning, cryptographic primitives. Used by: wallet recovery process to identify and restore owned outputs from blockchain history when rebuilding wallet state. |

###### base_layer/wallet/src/output_manager_service/storage/

| File | Description |
|------|-------------|
| `mod.rs` | Storage module declarations for output manager service. Organizes storage-related functionality including database backends, models, and SQLite implementation. Exports: database, models, output_source, output_status, sqlite_db modules. Used by: output manager service for UTXO persistence and storage operations. |
| `models.rs` | Data models for output manager storage operations. Defines database models and structures for UTXO storage, including output records, key material, and metadata. Dependencies: Diesel ORM, cryptographic types. Used by: output manager storage layer for database operations and UTXO serialization/deserialization. |
| `output_source.rs` | Output source enumeration and classification for UTXO origin tracking. Defines output sources like coinbase, standard transactions, one-sided payments. Dependencies: serde for serialization. Used by: output manager to track output origins for privacy, validation, and spending policy decisions. |
| `output_status.rs` | Output status enumeration for UTXO lifecycle tracking. Defines output states like unspent, spent, pending, invalid, abandoned. Dependencies: serde for serialization. Used by: output manager to track UTXO states throughout their lifecycle from creation to spending or invalidation. |

###### base_layer/wallet/src/output_manager_service/storage/database/

| File | Description |
|------|-------------|
| `backend.rs` | Database backend abstraction for output manager storage. Defines database interface and backend implementation for UTXO storage operations. Dependencies: database traits, output models. Used by: output manager service for database-agnostic storage operations, enabling different database backends while maintaining consistent interface. |
| `mod.rs` | Database module declarations for output manager storage. Organizes database-related functionality for UTXO storage and management. Exports: backend module (database abstraction). Used by: output manager service for database operations and storage management. |

###### base_layer/wallet/src/output_manager_service/storage/sqlite_db/

| File | Description |
|------|-------------|
| `mod.rs` | SQLite database implementation module for output manager storage. Organizes SQLite-specific storage functionality for UTXO persistence. Exports: new_output_sql, output_sql modules. Used by: output manager service for SQLite-based UTXO storage and retrieval operations. |
| `new_output_sql.rs` | SQLite SQL operations for new output creation in output manager. Implements database operations for inserting and managing newly created outputs. Dependencies: Diesel ORM, output models. Used by: output manager SQLite backend for creating new UTXO records during transaction processing and output generation. |
| `output_sql.rs` | SQLite SQL operations for output management in output manager. Implements database queries, updates, and management operations for existing outputs. Dependencies: Diesel ORM, output models. Used by: output manager SQLite backend for UTXO queries, status updates, and lifecycle management operations. |

###### base_layer/wallet/src/output_manager_service/tasks/

| File | Description |
|------|-------------|
| `mod.rs` | Task module declarations for output manager service background operations. Organizes asynchronous tasks for UTXO validation, monitoring, and maintenance. Exports: txo_validation_task module. Used by: output manager service for background processing and async operations management. |
| `txo_validation_task.rs` | Transaction output validation task for output manager service. Implements background validation of outputs against blockchain state, checking for spent status and validity. Dependencies: blockchain query services, output manager. Used by: output manager for continuous UTXO validation and state synchronization with blockchain. |

###### base_layer/wallet/src/storage/

| File | Description |
|------|-------------|
| `database.rs` | Database interface and operations for wallet storage layer. Defines database abstraction and common database operations for wallet data persistence. Dependencies: database backend implementations. Used by: wallet storage layer for database-agnostic operations and transaction management across different storage backends. |
| `mod.rs` | Storage module declarations for wallet data persistence. Organizes storage functionality including database abstraction, SQLite implementation, and utilities. Exports: database, sqlite_db, sqlite_utilities modules. Used by: wallet components for data persistence and storage operations. |

###### base_layer/wallet/src/storage/sqlite_db/

| File | Description |
|------|-------------|
| `mod.rs` | SQLite database implementation module for wallet storage. Organizes SQLite-specific functionality for wallet data persistence. Exports: scanned_blocks, wallet modules. Used by: wallet storage layer for SQLite-based operations and data management. |
| `scanned_blocks.rs` | SQLite operations for scanned blocks tracking in wallet. Manages database operations for blockchain scanning state and progress tracking. Dependencies: Diesel ORM, blockchain types. Used by: wallet scanning service to persist and query blockchain scanning progress and block processing state. |
| `wallet.rs` | SQLite operations for wallet core data storage. Implements database operations for wallet settings, metadata, and core wallet data persistence. Dependencies: Diesel ORM, wallet types. Used by: wallet core for storing and retrieving wallet configuration, state, and metadata in SQLite database. |

###### base_layer/wallet/src/storage/sqlite_utilities/

| File | Description |
|------|-------------|
| `mod.rs` | SQLite utilities module for wallet database operations. Organizes utility functions and helpers for SQLite database management. Exports: wallet_db_connection module. Used by: wallet storage components for SQLite-specific utilities and connection management. |
| `wallet_db_connection.rs` | SQLite database connection management for wallet operations. Handles connection pooling, transaction management, and connection lifecycle for wallet database access. Dependencies: Diesel connection pooling, SQLite. Used by: wallet storage layer for managing database connections and ensuring proper connection handling across wallet services. |

###### base_layer/wallet/src/transaction_service/

| File | Description |
|------|-------------|
| `config.rs` | Transaction Service configuration module defining timeout periods, routing mechanisms, and operational parameters. Exports: TransactionServiceConfig (main configuration struct), TransactionRoutingMechanism (enum for DirectOnly/StoreAndForwardOnly/DirectAndStoreAndForward). Key settings include broadcast monitoring timeout (30s), chain monitoring timeout (60s), transaction resend period (600s), pending transaction cancellation timeout (3 days), and confirmation requirements (3 blocks). Used by: TransactionService initialization, transaction protocols, and service configuration loading. Implements serde serialization and sensible defaults for all timeout values. |
| `error.rs` | Comprehensive error handling module for transaction service operations. Exports: TransactionServiceError (main error enum with 50+ variants), TransactionStorageError (database operation errors), TransactionKeyError (key-related errors), TransactionServiceProtocolError (protocol-specific errors with transaction ID context). Covers errors from invalid states, network mismatches, protocol failures, storage issues, validation problems, mempool rejections, connectivity issues, and cryptographic operations. Used throughout: transaction service, protocols, storage layer, and API handlers. Includes conversions from external error types and protocol-specific error handling utilities. |
| `handle.rs` | Transaction Service API handle providing high-level interface for wallet transaction operations. Exports: TransactionServiceHandle (main API interface), TransactionServiceRequest/Response enums (API messaging), TransactionEvent (event system), PaymentDetails (PayRef functionality). Key methods include send_transaction(), burn_tari(), register_validator_node(), cancel_transaction(), and various query operations for pending/completed transactions. Supports complex operations like aggregate UTXO encumbrance, one-sided transactions, stealth addresses, and payment reference lookups. Used by: wallet UI, console wallet, and other wallet components requiring transaction functionality. Implements async service communication via reply channels and event broadcasting. |
| `mod.rs` | Transaction Service module root and service initializer managing core transaction functionality within the Tari wallet. Exports: TransactionServiceInitializer (service setup), subscription streams for transaction protocols (send/receive/finalize/cancel/base node responses). Dependencies: subscription factory, transaction database backend, wallet database, output manager, connectivity service, base node service. Initializes message streams for transaction communication, creates service handle, and spawns the main TransactionService when dependencies are ready. Used by: wallet initialization, service framework. Coordinates between multiple wallet components to provide comprehensive transaction processing capabilities. |
| `payment_reference.rs` | Payment Reference (PayRef) system for enhanced transaction tracking and merchant/exchange integration. Exports: PayRefConfig (system configuration), PaymentDetails/PaymentRecord (payment data structures), PayRefDisplayFormat (UI formatting options), VerificationResult/VerificationStatus (payment verification), PaymentReceipt (verification receipts). Features include configurable confirmation requirements (default 5 blocks), multiple display formats (full/shortened/custom), payment direction tracking (sent/received/change), and comprehensive verification for merchant use cases. Used by: transaction service for PayRef generation, wallet UI for payment tracking, merchant APIs for payment verification. Implements serialization and utility functions for hex formatting and confirmation checking. |
| `service.rs` | Core TransactionService implementation orchestrating all wallet transaction operations. Main service class managing transaction lifecycle from creation to confirmation. Handles: transaction sending/receiving protocols, UTXO management integration, base node communication, transaction validation, broadcast monitoring, power mode management, and payment reference generation. Key methods include process transaction streams, handle API requests, manage protocol states, and coordinate with output manager, key manager, and connectivity services. Dependencies: transaction database, wallet database, output manager, base node service, key manager, outbound messaging, connectivity service. Used as: central transaction coordinator in wallet architecture. Implements complex state management for concurrent transaction processing and robust error handling for network operations. |
| `utc.rs` | UTC timestamp utilities for transaction service providing safe duration calculations. Exports: utc_duration_since() (duration calculation function), NegativeDurationError (error for negative durations). Key functionality includes computing time differences between UTC timestamps with error handling for negative results. Used by: transaction protocols for timeout calculations, retry logic, and timestamp validation. Simple utility module that handles edge cases in time calculations while avoiding leap second complications. Critical for ensuring robust timeout and retry mechanisms throughout transaction processing. |

###### base_layer/wallet/src/transaction_service/protocols/

| File | Description |
|------|-------------|
| `mod.rs` | Transaction protocol module root providing shared utilities for transaction communication protocols. Exports: check_transaction_size() (transaction size validation function), protocol submodules (transaction_broadcast_protocol, transaction_receive_protocol, transaction_send_protocol, transaction_validation_protocol). Key functionality includes verifying transactions don't exceed RPC frame size limits (4MB with safety margin), serialization validation, and protocol error handling. Used by: all transaction protocol implementations to ensure transactions can be broadcast over the network. Dependencies: bincode serialization, RPC constants, transaction service errors. Critical for preventing oversized transactions that would fail during network transmission. |
| `transaction_broadcast_protocol.rs` | Transaction broadcast protocol handling submission and monitoring of completed transactions to the blockchain network. Exports: TransactionBroadcastProtocol (main protocol implementation), TxBroadcastMode (submission/monitoring states). Key functionality includes submitting transactions to mempool via base node RPC, monitoring transaction status, handling mempool rejections (time-locked/orphan/double-spend), retry logic with exponential backoff, and final confirmation tracking. Dependencies: base node RPC client, transaction storage, connectivity service, key manager. Used by: transaction service for broadcasting completed transactions. Implements robust error handling for network issues, rejection scenarios, and timeout management with configurable retry intervals. |
| `transaction_receive_protocol.rs` | Transaction receive protocol managing the recipient side of interactive transaction building with senders. Exports: TransactionReceiveProtocol (protocol state machine), TransactionReceiveProtocolStage (Initial/WaitForFinalize). Handles: processing sender transaction messages, building recipient transaction responses, waiting for finalized transactions, output validation, and transaction completion. Dependencies: key manager, transaction storage, outbound messaging. Used by: transaction service for receiving funds from other wallets. Implements secure protocol execution with proper validation, reply generation, and state transitions while handling protocol cancellation and timeout scenarios. |
| `transaction_send_protocol.rs` | Transaction send protocol managing the sender side of interactive transaction building with recipients. Exports: TransactionSendProtocol (protocol state machine), TransactionSendProtocolStage (Initial/Queued/WaitForReply). Handles: UTXO selection via output manager, transaction building, encrypted communication with recipients, direct send attempts with store-and-forward fallback, reply processing, and transaction completion. Dependencies: output manager, key manager, outbound messaging, connectivity service. Used by: transaction service for sending funds to other wallets. Implements complex state management for multi-stage protocol execution, timeout handling, and routing mechanism support (direct/SAF/both) with comprehensive error recovery. |
| `transaction_validation_protocol.rs` | Transaction validation protocol for verifying completed transactions against blockchain state. Exports: TransactionValidationProtocol (validation coordinator). Key functionality includes querying base node for transaction status, batch validation of multiple transactions, signature verification, block height tracking, and confirmation counting. Dependencies: base node RPC client, transaction database, connectivity service, output manager. Used by: transaction service for periodic validation of completed transactions. Implements efficient batch processing, proper error handling for network issues, and comprehensive validation state management with event publishing for UI updates. |

###### base_layer/wallet/src/transaction_service/storage/

| File | Description |
|------|-------------|
| `database.rs` | Transaction storage backend trait and database abstraction layer defining storage interface for transaction persistence. Exports: TransactionBackend (main storage trait), TransactionDatabase (wrapper), DbKey/DbValue/DbValueKey (storage enums), WriteOperation (database modifications). Key methods include fetch/write operations, transaction completion logic, status updates, and queries for pending/completed/cancelled transactions. Supports: inbound/outbound transaction lifecycle management, completed transaction updates, cancellation handling, and broadcast status tracking. Used by: SQLite implementation, transaction service for data operations. Provides storage abstraction allowing different backend implementations while maintaining consistent API for transaction data management. |
| `mod.rs` | Transaction storage module root organizing database components for transaction persistence. Exports: database (storage traits and abstractions), models (transaction data structures), sqlite_db (SQLite implementation). Simple module that aggregates transaction storage functionality with clippy lint allowances for signed/unsigned integer conversions required for database operations. Used by: transaction service for data persistence, protocol implementations for state management. Provides clean separation between storage interface definitions, data models, and concrete database implementations. |
| `models.rs` | Transaction data models and structures for wallet transaction persistence. Exports: InboundTransaction (received transactions), OutboundTransaction (sent transactions), CompletedTransaction (finalized transactions), WalletTransaction (unified transaction type), TxCancellationReason (cancellation causes). Key features include transaction status tracking, protocol state persistence, timestamp management, payment ID support, direct send tracking, and output hash collections. Models support: serialization/deserialization, status transitions, payment reference generation, and conversion between transaction types. Used by: transaction storage layer, transaction service, protocol implementations. Provides comprehensive data structures for tracking complete transaction lifecycle from initiation through confirmation or cancellation. |
| `sqlite_db.rs` | SQLite database implementation for transaction service storage backend providing persistent transaction data management. Exports: TransactionServiceSqliteDatabase (main database interface), UnconfirmedTransactionInfo/InboundTransactionSenderInfo (query structures). Key features include encrypted storage, transaction lifecycle management (inbound/outbound/completed), cancellation tracking, payment reference storage, and comprehensive querying. Implements: TransactionBackend trait, database migrations, connection pooling, and data encryption. Dependencies: Diesel ORM, wallet database connection, encryption cipher. Used by: transaction service for all persistent operations. Supports complex queries for transaction history, status filtering, and wallet recovery scenarios with robust error handling. |

###### base_layer/wallet/src/transaction_service/tasks/

| File | Description |
|------|-------------|
| `check_faux_transaction_status.rs` | Transaction service task that monitors and updates the status of faux (detected/imported) transactions. Primary function: check_detected_transactions() - scans all detected transactions (imported, unconfirmed, unmined coinbases, confirmed) and validates their current blockchain status against output manager data. Updates transaction mining status, confirmation counts, and publishes TransactionEvent notifications. Handles reorg detection by comparing expected vs actual mined heights. Dependencies: OutputManagerHandle, TransactionDatabase, TransactionEventSender. Used by: transaction service validation workflows. Contains safety margin logic (3000 blocks) for reorg protection. |
| `mod.rs` | Transaction service task utilities module organizing helper functions for protocol operations. Exports: check_faux_transaction_status (transaction verification), send_finalized_transaction (completion messaging), send_transaction_cancelled (cancellation notifications), send_transaction_reply (recipient responses), wait_on_dial (connection utilities). Simple module aggregating task-specific utilities used across transaction protocols. Used by: transaction protocols for common messaging and verification operations. Provides modular organization of reusable protocol components for cleaner separation of concerns in complex transaction workflows. |
| `send_finalized_transaction.rs` | Transaction service task responsible for sending finalized transaction messages to recipients using configurable routing mechanisms. Exports: send_finalized_transaction_message(), send_finalized_transaction_message_direct(). Supports three routing modes: DirectOnly, StoreAndForwardOnly, DirectAndStoreAndForward. Handles peer discovery, direct messaging with timeout/retry logic, and store-and-forward messaging for offline peers. Dependencies: OutboundMessageRequester, TransactionRoutingMechanism, wait_on_dial task. Used by: transaction finalization workflow. Implements comprehensive error handling and fallback strategies for message delivery. |
| `send_transaction_cancelled.rs` | Transaction service task for sending transaction cancellation messages to peers. Exports: send_transaction_cancelled_message(). Sends courtesy cancellation notifications via both direct messaging and store-and-forward mechanisms. Creates TransactionCancelledMessage protobuf messages and broadcasts them using TariMessageType::TransactionCancelled. Dependencies: OutboundMessageRequester, CommsPublicKey. Used by: transaction cancellation workflows. Note: These are fire-and-forget courtesy messages with no progress monitoring or retry logic. |
| `send_transaction_reply.rs` | Transaction service task for sending transaction reply messages during the interactive transaction protocol. Exports: send_transaction_reply(), send_transaction_reply_direct(). Resends recipient's signed transaction data when repeated SendTransaction messages are received. Supports configurable routing mechanisms (DirectOnly, DirectAndStoreAndForward, StoreAndForwardOnly). Uses RecipientSignedMessage protobuf format and TariMessageType::ReceiverPartialTransactionReply. Dependencies: InboundTransaction, OutboundMessageRequester, wait_on_dial task. Used by: transaction negotiation protocol for reliability. Implements comprehensive retry and fallback logic. |
| `wait_on_dial.rs` | Transaction service utility task that waits for peer connection establishment and message transmission completion. Exports: wait_on_dial() function. Monitors MessageSendStates for successful direct message delivery with configurable timeout. Returns boolean indicating transmission success/failure. Used by: send_finalized_transaction, send_transaction_reply tasks. Provides detailed logging of connection attempts, timeouts, and transmission results. Essential component for reliable direct messaging in transaction protocols. |

###### base_layer/wallet/src/util/

| File | Description |
|------|-------------|
| `mod.rs` | Wallet utility functions module organizing common helper functionality. Exports: wallet_identity (identity management utilities), watch (filesystem watching utilities). Simple module aggregating utility functions used across wallet components. Used by: various wallet services for identity management and file system operations. Provides clean organization of reusable utility functions that don't belong to specific services. |
| `wallet_identity.rs` | Wallet identity management structure consolidating node identity and address information. Exports: WalletIdentity (identity container). Contains: node identity (comms public key), interactive Tari address, one-sided Tari address, wallet node key ID, and network detection. Key methods include network() extraction and formatted display output. Used by: wallet initialization, address management, and identity coordination across wallet components. Provides centralized identity information with proper formatting for user interfaces and logging. |
| `watch.rs` | Utility wrapper around Tokio's watch channel that ensures the receiver is always kept alive. Exports: Watch struct with new(), borrow(), changed(), send(), receiver(), get_receiver() methods. Prevents watch channel closure by maintaining an Arc reference to the sender and ownership of the receiver. Used throughout wallet for sharing state updates between components. Dependencies: tokio::sync::watch, Arc. Design pattern: infallible broadcasting where receiver is guaranteed to exist, preventing common watch channel failure scenarios. Essential for robust and reliable state propagation across wallet services. |

###### base_layer/wallet/src/utxo_scanner_service/

| File | Description |
|------|-------------|
| `error.rs` | Error type definitions for the UTXO scanner service. Exports: UtxoScannerError enum with variants for API responses, storage errors, connectivity issues, RPC errors, base node communication failures, conversion errors, and overflow conditions. Implements From traits for automatic error conversion from WalletStorageError, ConnectivityError, RpcError, OutputManagerError, etc. Used by: all UTXO scanner service components for comprehensive error handling. Dependencies: thiserror, tari error types. Provides detailed error context for debugging scanning and recovery operations. |
| `handle.rs` | Handle and event types for the UTXO scanner service. Exports: UtxoScannerHandle for service control and UtxoScannerEvent enum for progress notifications. Events include connection status, scanning progress, completion stats, and failure notifications. Handle provides methods for getting event receivers and setting user messages for one-sided payments and recovery operations. Dependencies: tokio broadcast channels, Watch utility, MicroMinotari. Used by: wallet components to monitor and control UTXO scanning/recovery operations. Enables real-time progress tracking and user notification during blockchain scanning. |
| `initializer.rs` | Service initializer for the UTXO scanner service using Tari's service framework. Exports: UtxoScannerServiceInitializer struct that implements ServiceInitializer trait. Sets up scanner with wallet database, crypto factories, network configuration, and birthday offset. Creates event channels and watch handles for progress monitoring. Dependencies: WalletDatabase, CryptoFactories, various service handles (TransactionService, OutputManager, BaseNodeService). Used by: wallet initialization to register and start UTXO scanning capability. Spawns scanner service with dual-address support for one-sided transactions. |
| `mod.rs` | UTXO scanner service module root providing blockchain scanning functionality for wallet recovery and balance updates. Exports: error (scanner errors), handle (service interface), initializer (service setup), service (core implementation), utxo_scanner_task (scanning logic), uxto_scanner_service_builder (service builder). Key constant RECOVERY_KEY for recovery data storage. Used by: wallet for recovering funds, scanning for missed transactions, and maintaining accurate balance information. Provides organized structure for blockchain scanning operations with proper service lifecycle management. |
| `service.rs` | UTXO scanner service core implementation for blockchain scanning and wallet recovery operations. Exports: UtxoScannerService (main service), UtxoScannerResources (service dependencies), SCANNED_BLOCK_CACHE_SIZE (720 blocks cache). Key functionality includes scanning blockchain for wallet UTXOs, recovery operations, one-sided transaction detection, progress monitoring, and event publishing. Dependencies: base node service, output manager, transaction service, connectivity service, wallet database. Used by: wallet for balance recovery, transaction discovery, and blockchain synchronization. Implements robust scanning logic with retry mechanisms, peer management, and comprehensive error handling for network disruptions. |
| `utxo_scanner_task.rs` | Core UTXO scanner task implementation for wallet recovery and scanning operations. Exports: UtxoScannerTask struct with run() method that performs full blockchain scanning. Supports both Recovery and Scanning modes with automatic reorg detection and progress tracking. Key features: birthday-based scanning start, bulletproof rewind profiling, incremental progress updates, dual scanning for standard and one-sided payments. Dependencies: BaseNodeWalletRpcClient, OutputManagerService, TransactionService. Used by: UTXO scanner service for comprehensive blockchain scanning and UTXO recovery. Implements sophisticated caching and retry logic for reliable operation. |
| `uxto_scanner_service_builder.rs` | Builder pattern implementation for UTXO Scanner Service configuration. Exports: UtxoScannerServiceBuilder (struct), UtxoScannerMode (enum with Recovery/Scanning variants). Dependencies: Tari comms, transaction key manager, crypto factories, wallet database, base node service handles. Provides fluent API for configuring retry limits, peer lists, scanning modes, and custom messages. Includes two build methods: build_with_wallet() for WalletSqlite integration and build_with_resources() for custom resource configuration. Used by wallet recovery and UTXO scanning operations. Critical for wallet synchronization with blockchain state. |

##### base_layer/wallet/tests/

| File | Description |
|------|-------------|
| `wallet_integration_tests.rs` | Top-level wallet integration tests for end-to-end functionality testing. Contains comprehensive tests validating complete wallet workflows including transaction creation, sending, receiving, recovery, and service integrations. Dependencies: All wallet services, test support modules, Tari core components. Tests wallet behavior in realistic scenarios combining multiple services. Critical for ensuring overall wallet system reliability and feature completeness. |

###### base_layer/wallet/tests/data/

| File | Description |
|------|-------------|
| `.gitkeep` | Git keep file for temporary LMDB database files directory. Ensures the empty data directory is tracked in version control for wallet test infrastructure. Used by: wallet integration tests to create temporary database storage. Essential for test environment setup and CI/CD pipelines. |

###### base_layer/wallet/tests/key_manager_service_tests/

| File | Description |
|------|-------------|
| `mod.rs` | Test module definition file for key manager service tests. Exports: service module. Dependencies: None directly. Simple module declaration that includes service.rs test implementations. Used by Rust test framework to organize key manager service test suite. Part of comprehensive wallet testing infrastructure. |
| `service.rs` | Comprehensive unit tests for TransactionKeyManagerWrapper service. Tests: key generation with encryption, branch management, key indexing, current index updates. Dependencies: ChaCha20Poly1305 encryption, CipherSeed, TransactionKeyManagerInterface, test utilities. Contains 5 async test functions testing encrypted key operations, multi-branch key derivation, key index finding, and index updating. Uses SQLite database backend with XChaCha20Poly1305 encryption. Critical for verifying key manager security and functionality. |

###### base_layer/wallet/tests/other/

| File | Description |
|------|-------------|
| `mod.rs` | Comprehensive integration tests for wallet functionality and edge cases. Tests: wallet creation, transaction sending/receiving, contacts service, encryption/decryption, database recovery, message signing, store-and-forward transactions, UTXO import, database file locking, birthday recovery, contacts liveness. Dependencies: Multiple Tari crates, tempfile, tokio. Contains 9 major test functions covering wallet lifecycle, P2P communication, security features, and data persistence. Uses LocalNet network with in-memory transport. Critical for validating complete wallet system behavior and data integrity. |

###### base_layer/wallet/tests/output_manager_service_tests/

| File | Description |
|------|-------------|
| `mod.rs` | Test module definition file for output manager service tests. Exports: service, storage modules. Dependencies: None directly. Module declaration that organizes output manager service test suite into service and storage test categories. Used by Rust test framework for wallet output management testing infrastructure. |
| `service.rs` | Comprehensive integration tests for OutputManagerService functionality. Tests: fee estimation, UTXO selection with/without chain metadata, transaction priority, insufficient funds handling, change calculation, transaction cancellation, coin splitting, invalid UTXO handling, recovery. Dependencies: Multiple Tari crates, SQLite backend, mock RPC services. Contains 20+ test functions covering the complete output manager service lifecycle including balance management, transaction preparation, and error scenarios. Uses TestOmsService helper struct for test setup. Critical for validating wallet output management and transaction building functionality. |
| `storage.rs` | Database backend tests for OutputManagerDatabase storage operations. Tests: output addition/retrieval, balance calculations, transaction encumbering/confirming, mining status updates, spent output tracking, duplicate output prevention, short-term encumberances, batch operations. Dependencies: SQLite database backend, test utilities. Contains test_db_backend() generic function for backend-agnostic testing plus SQLite-specific tests. Validates database integrity, balance accuracy, and proper state transitions. Critical for ensuring reliable wallet data persistence and consistency. |

###### base_layer/wallet/tests/support/

| File | Description |
|------|-------------|
| `base_node_service_mock.rs` | Mock implementation of BaseNodeService for wallet testing. Exports: MockBaseNodeService struct with configurable state and request handling. Dependencies: Base node service types, chain metadata, shutdown utilities. Provides set_base_node_state() for setting blockchain height simulation and set_default_base_node_state() for maximum height testing. Handles GetChainMetadata and GetBaseNodeLatency requests. Used extensively in wallet service tests to simulate base node interactions without requiring actual blockchain connectivity. |
| `comms_and_services.rs` | Communication setup utilities for wallet testing. Exports: setup_comms_services() for creating test comms infrastructure, create_dummy_message() for generating test domain messages. Dependencies: Tari comms, DHT, P2P initialization. Sets up memory transport-based communication nodes with peer discovery and message handling. Used by wallet integration tests to establish P2P communication between test wallet instances. Essential for testing wallet-to-wallet and wallet-to-base-node communication scenarios. |
| `comms_rpc.rs` | Mock RPC service implementation for BaseNodeWalletService testing. Exports: BaseNodeWalletRpcMockService and BaseNodeWalletRpcMockState for configurable mock responses, connect_rpc_client() helper, UtxosByBlock struct. Dependencies: Tari RPC protocols, base node wallet service, transaction types. Comprehensive mock supporting all wallet-base node RPC methods including transaction submission, querying, UTXO operations, sync operations. Includes configurable delays, error responses, and state tracking. Critical for testing wallet-base node communication without actual blockchain infrastructure. |
| `data.rs` | Database utilities for wallet testing. Exports: get_temp_sqlite_database_connection() for creating temporary test databases, get_path() for test data paths, init_sql_database()/clean_up_sql_database() for database lifecycle management. Dependencies: SQLite utilities, tempfile. Creates isolated test database instances with random names to prevent test interference. Used across all wallet tests requiring database persistence. Critical for ensuring clean test environments and proper database cleanup. |
| `mod.rs` | Test support module organization for wallet testing infrastructure. Exports: utils (with macros), base_node_service_mock, comms_and_services, comms_rpc, data, output_manager_service_mock, transaction_service_mock modules. Dependencies: Individual support modules. Central coordination point for all wallet testing utilities including service mocks, communication setup, database utilities, and test data generation. Used throughout wallet test suite for consistent test infrastructure. |
| `output_manager_service_mock.rs` | Mock implementation of OutputManagerService for wallet testing. Exports: OutputManagerServiceMock, OutputManagerMockState, make_output_manager_service_mock() factory. Dependencies: Output manager service types, service framework. Supports ScanForRecoverableOutputs and ScanOutputs requests with configurable recoverable outputs and one-sided payments. Includes state management for testing output recovery scenarios. Essential for testing wallet recovery and UTXO scanning without full output manager infrastructure. |
| `transaction_service_mock.rs` | Mock implementation of TransactionService for wallet testing. Exports: TransactionServiceMock, TransactionServiceMockState, make_transaction_service_mock() factory. Dependencies: Transaction service types, service framework. Supports ImportUtxoWithStatus and ValidateTransactions requests with request tracking. Includes state management for tracking service requests and responses. Essential for testing transaction service interactions without full transaction service infrastructure. |
| `utils.rs` | Utility functions and macros for wallet testing. Exports: make_input(), make_fake_input_from_copy(), create_wallet_output_from_sender_data(), make_input_with_features(), acquire_lock! macro. Dependencies: Tari core transactions, crypto utilities, key management. Provides test data generation for wallet outputs, transaction inputs, and receiver data. Includes acquire_lock! macro for safe mutex handling with poison recovery. Essential utilities used throughout wallet test suite for creating test transactions and outputs. |

###### base_layer/wallet/tests/transaction_service_tests/

| File | Description |
|------|-------------|
| `mod.rs` | Test module definition file for transaction service tests. Exports: service, storage, transaction_protocols modules. Dependencies: None directly. Module declaration organizing transaction service test suite into service functionality, storage operations, and transaction protocol tests. Used by Rust test framework for wallet transaction service testing infrastructure. |
| `service.rs` | Comprehensive integration tests for TransactionService functionality. Tests transaction lifecycle including creation, sending, receiving, cancellation, recovery, and service state management. Dependencies: Transaction service types, mock services, test utilities. Validates transaction protocols, fee calculation, mempool interaction, blockchain monitoring, and error handling. Contains numerous test functions covering complete transaction service behavior including edge cases and failure scenarios. Critical for ensuring reliable transaction processing in wallet applications. |
| `storage.rs` | Database backend tests for TransactionService storage operations. Tests transaction persistence, state transitions, completed transaction tracking, inbound/outbound transaction management, and database integrity. Dependencies: SQLite backend, transaction service storage types. Validates transaction database operations including complex queries, transaction status updates, and data consistency. Essential for ensuring reliable transaction data persistence and state management across wallet sessions. |
| `transaction_protocols.rs` | Tests for transaction protocol implementations and message handling. Tests sender/receiver transaction protocols, protocol state machines, message serialization/deserialization, and protocol error recovery. Dependencies: Transaction protocol types, crypto utilities, communication layers. Validates complete transaction protocol flows including negotiation, commitment exchange, and finalization. Critical for ensuring secure and reliable transaction protocol implementation between wallet participants. |

###### base_layer/wallet/tests/utxo_scanner/

| File | Description |
|------|-------------|
| `mod.rs` | Test module definition file for UTXO scanner tests. Module declaration for organizing UTXO scanner service test suite. Dependencies: None directly. Used by Rust test framework for wallet UTXO scanning and recovery testing infrastructure. Part of comprehensive wallet testing system covering blockchain scanning functionality. |

#### base_layer/wallet_ffi/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for minotari_wallet_ffi - C FFI bindings for Tari cryptocurrency wallet. Builds both staticlib and cdylib crate types for mobile and desktop integration. Key dependencies: minotari_wallet with c_integration feature, tari_core, tari_comms, crypto libraries, tokio async runtime. Platform-specific: OpenSSL vendored for Android targets. Build dependencies: cbindgen for C header generation. Used by: mobile applications (iOS/Android) and desktop integrations requiring C/C++ wallet access. Special features: async FFI bridging, comprehensive wallet functionality exposure. |
| `README.md` | Foreign Function Interface (FFI) documentation for Tari mobile wallet integration. Contains: build setup instructions for macOS, iOS/Android dependencies, Homebrew installation steps, XCode configuration, iOS/Android toolchain setup, and cross-compilation guidance. Covers: platform-specific build requirements, SDK configurations, troubleshooting common build issues, and mobile development environment preparation. Used by: mobile wallet developers for building Tari wallet FFI bindings. Provides comprehensive setup instructions for iOS and Android wallet development with detailed troubleshooting guidance and platform-specific considerations. |
| `build.rs` | Build script for wallet FFI that generates C header files using cbindgen. Creates wallet.h with C bindings for Rust wallet functions, configures parsing for tari dependencies, and generates version constants. Features: C++ compatibility, tag-style enums, native line endings. Dependencies: cbindgen, StaticApplicationInfo, tari_features. Used by: mobile/desktop applications requiring C/C++ wallet integration. Output: wallet.h in crate directory. |
| `build.sample.config` | Sample build configuration file for wallet FFI library compilation. Contains platform-specific build settings, compiler flags, and link options for cross-platform FFI library generation. Used as template for configuring wallet FFI builds for different target platforms (iOS, Android, desktop). Critical for mobile and external application integration setup. |
| `ios.config` | iOS-specific build configuration for wallet FFI library. Contains iOS platform settings, architectures, deployment targets, and linking configurations for building Tari wallet FFI for iOS applications. Used by build system for creating iOS-compatible wallet library. Essential for iOS mobile wallet development. |
| `mobile_build.sh` | Mobile platform build script for wallet FFI library. Automates cross-compilation for iOS and Android platforms including architecture-specific builds, dependency management, and library packaging. Exports: Build automation for mobile FFI libraries. Dependencies: Cross-compilation toolchains, platform SDKs. Configures build environments, handles code signing, and generates platform-specific libraries. Critical for mobile wallet application development and deployment. |
| `wallet.h` | [GENERATED] C header file with FFI bindings for Tari wallet functionality. Generated by: cbindgen from wallet_ffi build.rs. Exports: wallet structs, enums (TariTypeTag, TariUtxoSort), function signatures for wallet operations, transaction handling, balance management. Used by: C/C++ applications, mobile apps (iOS/Android), desktop integrations. Critical note: Auto-generated file - do not edit manually. Regenerated on each build. |

##### base_layer/wallet_ffi/src/

| File | Description |
|------|-------------|
| `callback_handler.rs` | FFI callback handler that bridges wallet service events to C client applications. Exports: CallbackHandler struct that monitors event streams from TransactionService, OutputManagerService, BaseNodeService, UtxoScannerService. Provides C callbacks for transaction lifecycle events (received, replied, finalized, broadcast, mined), balance updates, connectivity status, and progress notifications. Uses unsafe extern 'C' function pointers with void* context. Dependencies: all major wallet service handles and event streams. Used by: mobile/desktop applications via FFI to receive real-time wallet notifications. Critical for user experience in native applications. |
| `callback_handler_tests.rs` | Unit tests for FFI callback handler functionality. Tests callback registration, event delivery, memory management, and error handling in FFI callback system. Dependencies: FFI callback types, test utilities. Validates callback thread safety, event ordering, and proper cleanup of callback resources. Ensures reliable event delivery from Rust wallet core to external applications via FFI interface. |
| `enums.rs` | FFI-safe enumeration definitions for wallet functionality. Exports: C-compatible enums for wallet states, transaction types, errors, and operational modes. Dependencies: Wallet core types. Provides safe FFI boundary types with proper memory layout for external language bindings. Includes conversion implementations between Rust native types and FFI-safe representations. Essential for type safety in cross-language wallet integrations. |
| `error.rs` | Error handling and conversion for wallet FFI interface. Exports: FFI-safe error types, error code mappings, error conversion utilities. Dependencies: Wallet error types, FFI utilities. Provides safe error propagation across FFI boundary with proper error code mapping and memory management. Includes error message handling and logging integration. Critical for robust error handling in external wallet applications. |
| `ffi_basenode_state.rs` | FFI wrapper for base node state and connectivity information. Exports: FFI-safe base node state types, connectivity status, chain metadata access. Dependencies: Base node service types, FFI utilities. Provides external applications access to base node connection status, sync state, and blockchain metadata through safe FFI interface. Essential for wallet applications monitoring blockchain connectivity. |
| `lib.rs` | Foreign Function Interface (FFI) library exposing Tari wallet functionality to external systems (mobile apps, other languages). Provides C-compatible API for wallet operations including transaction sending/receiving, balance queries, contact management, and base node connectivity. Implements comprehensive wallet workflow documentation, callback system for async operations, and handles transaction states (Pending, Completed, Broadcast, Mined). Includes logging configuration, SQLite database integration, recovery mechanisms, and extensive error handling for cross-platform wallet integration. |
| `output_manager_service_mock.rs` | Mock output manager service implementation for FFI testing. Exports: Mock output manager with configurable behavior for FFI integration testing. Dependencies: Output manager types, FFI test utilities. Provides controllable mock behavior for testing FFI wallet functionality without full output manager infrastructure. Used in FFI integration tests and external application testing scenarios, enabling isolated testing of wallet operations. |
| `tasks.rs` | Background task management for wallet FFI operations. Exports: Task scheduling, async operation handling, background service coordination. Dependencies: Tokio runtime, wallet services, FFI utilities. Manages long-running wallet operations in background threads with proper FFI callback coordination. Handles task lifecycle, cancellation, and resource cleanup. Essential for responsive FFI wallet applications with async operations. |

### buildtools/

| File | Description |
|------|-------------|
| `build-notes.md` | Build configuration notes and documentation for cross-platform Tari development. Contains: Docker build setups for Linux x86_64/ARM64, Vagrant/VirtualBox configurations, Ubuntu dependency installation scripts, cross-compilation instructions, and development environment setup guides. Covers native, Docker, virtualized, and emulated build options with specific commands for testing on macOS targeting Linux builds. Used by: developers for setting up build environments across different platforms. Includes comprehensive dependency lists, network configuration, and platform-specific build considerations for consistent development environments. |
| `create_osx_install_zip.sh` | macOS package creation script that bundles Tari applications into distributable archives. Creates tarball with minotari_node, console_wallet, miner, merge_mining_proxy executables plus configuration files and launcher scripts. Uses greadlink for cross-platform compatibility. Includes: runtime scripts, config presets, XMRig integration, postinstall scripts. Used by: release automation to generate macOS installation packages. Dependencies: GNU coreutils (greadlink), target/release binaries. |
| `create_ubuntu_install_zip.sh` | Ubuntu installation archive creation script for Tari applications. Creates tarball containing all Tari executables and configuration files for Ubuntu deployment. Copies binaries (minotari_node, console_wallet, miner, merge_mining_proxy), runtime scripts, Tor setup utilities, XMRig installation scripts, and configuration presets from target/release. Exports: Archive creation functionality. Dependencies: Built Tari binaries, PowerShell scripts, configuration files. Used by build/release process to package complete Ubuntu installation. Critical for distributing Tari software suite to end users. |
| `get_xmrig_osx.ps1` | PowerShell script for downloading and installing XMRig on macOS. Handles XMRig binary download, verification, installation, and initial configuration for macOS systems. Exports: XMRig installation automation for macOS. Used by Tari installation process to set up merge mining capabilities on macOS platforms. |
| `get_xmrig_ubuntu.ps1` | PowerShell script for downloading and installing XMRig on Ubuntu Linux. Handles XMRig binary download, verification, installation, and configuration for Ubuntu systems. Exports: XMRig installation automation for Ubuntu. Used by Tari installation process to set up merge mining capabilities on Ubuntu/Debian-based Linux distributions. |
| `get_xmrig_win.ps1` | PowerShell script for downloading and installing XMRig on Windows. Handles XMRig binary download, verification, installation, and configuration for Windows systems. Exports: XMRig installation automation for Windows. Used by Tari installation process to set up merge mining capabilities on Windows platforms with proper Windows-specific configuration. |
| `install_powershell_ubuntu.sh` | Installation script for PowerShell on Ubuntu systems. Downloads and installs Microsoft PowerShell by adding the Microsoft repository GPG keys, registering the repository, and installing the powershell package via apt-get. Used by buildtools/install_xmrig.sh when PowerShell is not available on Linux systems. Dependencies: wget, apt-transport-https. No exports. |
| `install_tor_services.bat` | Windows batch script for downloading and installing Tor Services from archive.torproject.org. Downloads tor-win64-0.4.6.7.zip from version 11.0a5, extracts to ~/.tor_services, and sets TARI_TOR_SERVICES_DIR environment variable. Validates installation by checking for tor.exe. Used by Tari applications that require Tor network connectivity. Dependencies: PowerShell, curl/Invoke-WebRequest. Exports: TARI_TOR_SERVICES_DIR environment variable. |
| `install_vs2019_redist.bat` | Windows batch script for downloading and installing Microsoft Visual C++ Redistributable for Visual Studio 2019. Downloads vc_redist.x64.exe from Microsoft's official aka.ms link and runs silent installation. Required for Tari applications on Windows systems that need Visual C++ runtime libraries. Dependencies: PowerShell, internet connectivity. No exports. |
| `install_xmrig.bat` | Windows batch script for downloading and installing XMRig cryptocurrency miner. Downloads latest XMRig release from GitHub API, extracts to ~/.xmrig, flattens directory structure, and sets TARI_XMRIG_DIR environment variable. Uses PowerShell script get_xmrig_win.ps1 for GitHub API interaction. Validates installation by checking for xmrig.exe. Used by Tari merge mining functionality. Dependencies: PowerShell, get_xmrig_win.ps1. Exports: TARI_XMRIG_DIR environment variable. |
| `install_xmrig.sh` | Cross-platform shell script for downloading and installing XMRig cryptocurrency miner on Linux and macOS. Detects OS type, installs PowerShell if needed (using install_powershell_ubuntu.sh), downloads XMRig from GitHub releases, extracts and flattens directory structure. Uses platform-specific PowerShell scripts (get_xmrig_osx.ps1, get_xmrig_ubuntu.ps1). Validates installation by checking for xmrig executable. Used by Tari merge mining functionality. Dependencies: bash, curl/wget, PowerShell. Related files: get_xmrig_osx.ps1, get_xmrig_ubuntu.ps1, install_powershell_ubuntu.sh. |
| `multinet_envs.sh` | Build script that configures network environment variables based on git tag patterns. Maps version tags to appropriate Tari networks: pre-release tags to esme (testnet), release candidates to nextnet, DAN versions to igor (testnetdan), and stable releases to mainnet. Sets TARI_NETWORK, TARI_TARGET_NETWORK, and TARI_NETWORK_DIR environment variables. Used by: CI/CD pipelines and build processes to automatically configure network settings based on release type. Essential for multi-network deployment automation. |
| `osx_postinstall.sh` | macOS post-installation script for Tari applications. Creates ~/.tari directory if it doesn't exist, copies files from /tmp/tari/ to user's home directory, sets proper ownership (user:staff), and removes scripts directory. Logs all operations to /tmp/tari.log. Used during macOS installer package installation process. Dependencies: bash, standard Unix utilities (cp, chown, rm). No exports. |
| `windows-dev-environment-notes.md` | Comprehensive Windows development environment setup guide for Tari project. Covers installation of Visual Studio BuildTools 2022, Git, Chocolatey, Protobuf, vcpkg, SQLite3, OpenSSL, and Rust. Includes minimum system requirements (64-bit processor, 8GB RAM, 40GB free space), troubleshooting steps, and build instructions for Tari tools. Used by Windows developers setting up Tari development environment. Dependencies: Various Windows package managers and build tools. No exports. |
| `windows_inno_installer.iss` | [INSTALLER] Inno Setup script for creating Windows installer package for Tari applications. Defines installer configuration, files to include, registry settings, and installation procedures. Used to generate Windows .exe installer for distribution. Dependencies: Inno Setup compiler. Exports: Windows installer executable. |

#### buildtools/deps_only/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for dependency-only build configuration. Contains dependency specifications for building only dependencies without main Tari crate compilation. Used for optimizing Docker builds, CI cache layers, and development environments. Enables faster incremental builds by pre-building dependencies separately from main application code. |

##### buildtools/deps_only/src/

| File | Description |
|------|-------------|
| `main.rs` | Utility application for pre-building and caching all Tari dependencies. Does no functional work but includes all crate dependencies, making it useful for Docker image layering and dependency caching. When built with 'cargo build --bin deps_only', downloads and compiles all required dependencies, creating a cached compilation environment for faster subsequent builds of actual Tari applications. Optimizes CI/CD and development workflows by separating dependency compilation from application-specific builds. |

#### buildtools/docker_rig/

| File | Description |
|------|-------------|
| `3rdparty.json` | Third-party service configuration for Docker development environment. Contains service definitions, URLs, and configuration parameters for external dependencies like mining pools, blockchain explorers, and auxiliary services. Used by Docker Compose setups for development and testing environments requiring external service integration. |
| `monerod.Dockerfile` | Dockerfile for Monero daemon container in Tari development environment. Configures Monero node for merge mining development and testing. Includes network configuration, blockchain data mounting, and RPC interface setup. Used in Docker Compose environments for testing Tari merge mining functionality with Monero blockchain. |
| `start_tari_app.sh` | Container startup script for Tari applications in Docker environment. Handles environment variable configuration, service initialization, logging setup, and application startup coordination. Exports: Container orchestration for Tari services. Used by Docker containers to properly initialize and start Tari base node, wallet, or miner services with appropriate configuration. |
| `tarilabs.Dockerfile` | Main Dockerfile for Tari applications container image. Configures build environment, dependencies, compilation, and runtime setup for Tari suite. Includes multi-stage build optimization, security configuration, and service port exposure. Used for containerized deployment of Tari base node, wallet, and related services in production and development environments. |
| `tarisuite.json` | Docker configuration mapping file defining Tari application containers. Maps image names to application names and executables: minotari_node (node), minotari_console_wallet (wallet), minotari_merge_mining_proxy (merge_mining_proxy), minotari_sha3_miner (sha3_miner/minotari_miner). Used by: Docker build automation and container orchestration tools. Format: JSON array with image_name, app_name, app_exec fields for each component. |
| `tor.Dockerfile` | Dockerfile for Tor proxy container in Tari development environment. Configures Tor daemon for anonymous networking and hidden service support. Includes proper Tor configuration, security settings, and network isolation. Used in Docker environments for testing Tari network privacy features and hidden service functionality. |
| `xmrig.Dockerfile` | Dockerfile for XMRig miner container in Tari development environment. Configures XMRig for merge mining with Monero blockchain. Includes CPU optimization, mining pool configuration, and performance tuning. Used in Docker environments for testing Tari merge mining functionality and mining pool integration. |

#### buildtools/vagrant/

| File | Description |
|------|-------------|
| `.gitignore` | [CONFIGURATION] Git ignore file for Vagrant development environment. Specifies which files and directories should be ignored by git in the vagrant directory. Standard ignore patterns for Vagrant virtual machine artifacts, logs, and temporary files. Used by git version control. No dependencies or exports. |
| `Vagrantfile` | Vagrant configuration file for creating Ubuntu 18.04 LTS (bionic64) development virtual machine. Configures VirtualBox provider with 2 CPUs, 5GB RAM, disabled GUI and VirtualBox Guest Additions auto-update. Used for creating consistent development environments for Tari project. Dependencies: Vagrant, VirtualBox, optional vagrant-vbguest plugin. No exports. |

#### clients/ffi_client/

| File | Description |
|------|-------------|
| `.gitignore` | [CONFIGURATION] Git ignore file for FFI client directory. Specifies which files and directories should be ignored by git in the FFI client workspace. Standard ignore patterns for Node.js dependencies, build artifacts, logs, and temporary files. Used by git version control. No dependencies or exports. |
| `README.md` | NodeJS FFI client documentation for wallet FFI library integration. Provides setup instructions for building and using the minotari_wallet_ffi library with Node.js applications. Dependencies: npm, Cargo build system, platform-specific FFI library (.dylib/.so/.dll). Documents build process, library copying, and execution steps. Used by mobile/web developers integrating Tari wallet functionality via FFI. Work in progress implementation for cross-platform wallet integration. |
| `index.js` | Node.js demonstration client for Tari wallet FFI integration showing complete wallet functionality. Implements Tor transport configuration, communication setup, wallet creation with comprehensive callback handling, transaction validation, UTXO validation, base node peer configuration, and balance monitoring. Provides examples of seed word extraction, confirmation requirements, and graceful shutdown handling. Comprehensive reference implementation for integrating Tari wallet functionality into JavaScript applications using FFI bindings. |
| `package.json` | Node.js package configuration for Tari FFI (Foreign Function Interface) client library. Defines dependencies for native library integration including ffi-napi for C/C++ bindings, ref-array-napi for array handling, and ref-napi for memory management. Provides scripts for wallet operations (start, recovery) and testing. Enables JavaScript/Node.js applications to interact with Tari wallet functionality through native library bindings, supporting wallet creation, transaction handling, and balance management. |
| `recovery.js` | Node.js wallet recovery script using Tari FFI library. Creates wallet from 24-word seed phrase, sets up Tor transport and communication configuration, registers transaction callbacks, and performs UTXO scanning recovery. Uses environment variable SEED_WORDS for mnemonic input. Includes comprehensive transaction event handlers and balance monitoring. Dependencies: ffi-napi, ref-napi, ./lib. Used for wallet recovery operations. Exports: Recovery functionality via script execution. |

##### clients/ffi_client/lib/

| File | Description |
|------|-------------|
| `index.js` | Node.js FFI client library providing JavaScript bindings to the Tari wallet C library. Exports: libWallet object with wallet functions (create, destroy, balance operations, transaction validation, recovery). Uses ffi-napi for native library interop with libminotari_wallet_ffi.dylib. Functions include: wallet management, key operations, seed word handling, base node peer setup, transaction/TXO validation. Dependencies: ffi-napi, custom type definitions. Used by: Node.js applications requiring wallet functionality. Platform-specific: hardcoded dylib path for macOS. |
| `types.js` | Type definitions for Tari FFI client using ref-napi and ref-array-napi. Defines C-compatible data types for interfacing with Tari native library including string pointers, error codes, wallet references, and various integer types. Exports type definitions for use across FFI client modules. Dependencies: ref-napi, ref-array-napi. Used by: clients/ffi_client/recovery.js and other FFI client modules. Exports: Complete set of C-FFI type mappings. |

##### clients/nodejs/base_node_grpc_client/

| File | Description |
|------|-------------|
| `README.md` | Documentation for Node.js gRPC client library for Tari Base Node. Provides usage instructions, API documentation, and examples for interacting with Tari base node via gRPC protocol. Documents available methods and connection procedures. Used by developers integrating with Tari base node services. Dependencies: None (documentation only). Related files: package.json, src/index.js. |
| `package.json` | NPM package configuration for Tari Base Node gRPC client. Defines package metadata, dependencies (@grpc/grpc-js, @grpc/proto-loader, grpc-promise), and test scripts using Jest. Main entry point is src/index.js. Version 0.0.1 indicates early development. Dependencies: gRPC libraries, filesystem utilities. Used by: Node.js applications connecting to Tari base node. Related files: src/index.js, src/index.test.js. |

###### clients/nodejs/base_node_grpc_client/src/

| File | Description |
|------|-------------|
| `index.js` | Main entry point for Tari Base Node gRPC client library. Loads protobuf definitions, creates gRPC client connection with promisified methods, and exports Client class with methods like getVersion, listHeaders, getBlocks, getMempoolTransactions, getTipInfo, searchUtxos, etc. Default connection to 127.0.0.1:18142. Dependencies: @grpc/grpc-js, @grpc/proto-loader, grpc-promise, path. Used by: Node.js applications. Exports: Client class and gRPC types. Related test file: src/index.test.js. |
| `index.test.js` | Jest test suite for Tari Base Node gRPC client. Tests client connection, method availability, and basic functionality of the gRPC client library. Validates that exported methods work correctly and protobuf definitions are loaded properly. Uses Jest testing framework. Dependencies: Jest, ../index.js. Used by: npm test script. Tests: Client connection and method validation. |

##### clients/nodejs/wallet_grpc_client/

| File | Description |
|------|-------------|
| `.prettierrc` | [CONFIGURATION] Prettier code formatting configuration for wallet gRPC client. Defines code style rules for automatic formatting of JavaScript/TypeScript files in the wallet client project. Used by Prettier formatter and IDE integrations. Dependencies: Prettier. No exports. |
| `README.md` | Documentation for Node.js gRPC client library for Tari Wallet. Provides usage instructions, API documentation, and examples for interacting with Tari wallet via gRPC protocol. Documents available wallet methods and connection procedures. Used by developers integrating with Tari wallet services. Dependencies: None (documentation only). Related files: package.json, index.js. |
| `index.js` | Main entry point for Tari Wallet gRPC client library. Loads wallet protobuf definitions, creates gRPC client connection with promisified methods, supports basic authentication, and exports Client class with wallet methods like getBalance, transfer, getCompletedTransactions, coinSplit, mintTokens, etc. Includes createAuth function for authentication handling. Dependencies: @grpc/grpc-js, @grpc/proto-loader, grpc-promise. Used by: Node.js wallet applications. Exports: Client class and gRPC types. |
| `package.json` | NPM package manifest for @tari/wallet-grpc-client - Node.js gRPC client for Tari wallet communication. Dependencies: @grpc/grpc-js for gRPC protocol support, @grpc/proto-loader for protobuf handling, grpc-promise for promisified gRPC calls. Version 0.0.1 indicates early development stage. Author: Tari development community. Used by: Node.js applications requiring programmatic wallet interaction via gRPC API. Main entry: index.js. No test framework configured yet. |

##### clients/rust/base_node_grpc_client/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for minotari_node_grpc_client - Rust gRPC client for base node communication. Dependencies: minotari_app_grpc for protocol definitions. Commented dependencies suggest previous tonic/prost gRPC stack. Dev dependencies: tokio for async testing. Used by: Rust applications requiring programmatic base node interaction via gRPC. Version 0.1.0 indicates early development. License: BSD-3-Clause, repository: tari-project/tari. |

###### clients/rust/base_node_grpc_client/src/

| File | Description |
|------|-------------|
| `lib.rs` | gRPC client library for connecting to Tari base node services. Provides BaseNodeGrpcClient type alias for base_node_client::BaseNodeClient from minotari_app_grpc. Simple wrapper around the generated gRPC client to access base node functionality like blockchain queries, peer management, and mining operations. Re-exports tari_rpc module for protocol definitions and client usage. |

###### clients/rust/base_node_grpc_client/tests/

| File | Description |
|------|-------------|
| `client.rs` | Integration test for Rust Base Node gRPC client library. Tests basic connectivity to base node at 127.0.0.1:18142 and get_tip_info method. Uses tokio async runtime for testing. Handles connection errors gracefully. Used by: cargo test. Dependencies: minotari_node_grpc_client, tokio. Tests: Base node connection and tip info retrieval. |

##### clients/rust/base_node_wallet_client/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for minotari_node_wallet_client library. Defines Rust HTTP client for interacting with base node wallet services. Dependencies include tari_core (transactions feature), url, reqwest for HTTP requests, thiserror for error handling, and async-trait. Used for wallet-base node communication over HTTP. Related files: src/client/http.rs, src/lib.rs. |

###### clients/rust/base_node_wallet_client/src/

| File | Description |
|------|-------------|
| `error.rs` | Error types and handling for base node wallet client. Defines custom error enums and implementations for HTTP client communication errors, network failures, and protocol-specific errors. Uses thiserror for error derivation. Dependencies: thiserror. Used by: HTTP client and lib modules. Exports: Client error types and conversion implementations. |
| `lib.rs` | Main library entry point for minotari_node_wallet_client. Exports HTTP client implementations, error types, and public API for wallet-base node communication. Provides unified interface for different client protocols. Dependencies: client modules, error module. Used by: wallet applications and services. Exports: Complete client library API. |

###### clients/rust/base_node_wallet_client/src/client/

| File | Description |
|------|-------------|
| `http.rs` | HTTP client implementation for wallet-base node communication. Provides HTTP-based methods for querying base node services including UTXO searches, transaction submission, and blockchain data retrieval. Implements async traits for wallet service interaction over HTTP protocol. Dependencies: reqwest, tari_core, async-trait, url. Used by: wallet services requiring base node communication. Exports: HTTP client implementation. |
| `mod.rs` | Module declaration for base node wallet client implementations. Exports HTTP client module and potentially other client implementation types. Used for organizing different client communication protocols (HTTP, gRPC, etc.). Dependencies: http module. Used by: src/lib.rs and wallet applications. Exports: Client implementations. |

##### clients/rust/wallet_grpc_client/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for Rust wallet gRPC client library. Defines dependencies and metadata for gRPC-based wallet client implementation. Used for wallet service communication over gRPC protocol. Dependencies likely include gRPC libraries and tari_core. Used by: Rust applications requiring wallet gRPC connectivity. Related files: tests/client.rs. |

###### clients/rust/wallet_grpc_client/src/

| File | Description |
|------|-------------|
| `lib.rs` | gRPC client library for connecting to Tari wallet services with authentication support. Provides WalletGrpcClient wrapper around generated gRPC client with ClientAuthenticationInterceptor for basic auth and custom authentication. Supports connection with/without authentication, automatic message size limits (8 MiB), and comprehensive error handling. Re-exports authentication utilities, GrpcAuthentication, and tari_rpc protocol definitions. Includes transport-generic design with specific implementations for tonic::transport::Channel. |

###### clients/rust/wallet_grpc_client/tests/

| File | Description |
|------|-------------|
| `client.rs` | Integration test for Rust wallet gRPC client library. Tests basic connectivity to wallet gRPC service and validates wallet API functionality. Uses tokio async runtime for testing. Handles connection errors gracefully. Used by: cargo test. Dependencies: wallet gRPC client, tokio. Tests: Wallet gRPC connection and basic operations. |

### common/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for tari_common - shared utilities for Base and Digital Asset layers. Features: build support (toml, prost-build), static-application-info (git2). Key dependencies: config parsing (toml, serde), logging (log4rs), multiaddr for network addresses, tempfile, thiserror. Optional: git2 for version info, prost-build for protobuf. Build dependencies: tari_features for feature resolution. Used by: all Tari components for common functionality like configuration, logging, serialization. Critical foundation library. |
| `README.md` | Documentation for Tari Common crate providing shared domain-level functionality. Explains purpose as collection of commonly-used features shared across multiple Tari domain layers. Distinguished from infrastructure folder and tari-utilities by containing domain-specific concepts. Used across multiple Tari applications for shared types, utilities, and domain logic. Central coordination point for cross-cutting concerns in Tari architecture. |
| `build.rs` | Build script for Tari common utilities library handling feature flag resolution and build configuration. Executes tari_features::resolver::build_features() to process and validate feature flags at compile time. Simple build script ensuring proper feature flag compilation across all common utilities used by Tari applications. Essential for maintaining consistent feature availability across the Tari ecosystem. |

#### common/config/

| File | Description |
|------|-------------|
| `README.md` | Documentation for Tari configuration system and files. Explains tari.config.json as canonical configuration definition with metadata, conditions, defaults, and OS parameters. Used by Tari Configuration Generator web tool. Warns about default value synchronization between JSON and code. Documents presets folder containing preconfigured files for common use cases. Links to config.tari.com generator tool. Critical for understanding Tari configuration architecture and tooling. |
| `tari.config.json` | JSON schema and metadata for Tari configuration system. Defines configuration structure, validation rules, UI metadata, and default values for all Tari applications. Includes sections for common settings, wallet configuration, base node options, and network-specific parameters. Used by configuration management tools and UI generators. Dependencies: None (schema definition). Used by: Configuration parsers and UI tools. Exports: Configuration schema and metadata. |

##### common/config/presets/

| File | Description |
|------|-------------|
| `a_common.toml` | Common configuration preset for Tari applications defining shared settings across all components. Sections: CommonConfig (base_path, override network), AutoUpdateConfig (DNS-based update system with configurable URIs and intervals), MetricsConfig (monitoring endpoints). Network-specific update URIs for stagenet. Features: DNS TXT record updates, DNSSEC validation options, customizable check intervals (300s default). Used by: all Tari applications to establish baseline configuration. Part of multi-file config system that gets merged during application startup. |
| `b_peer_seeds.toml` | Peer seeds configuration preset defining bootstrap nodes for all Tari networks. Contains DNS seeds and hardcoded peer lists for mainnet, nextnet, stagenet, esmeralda, and igor networks. Includes IPv4, IPv6, and Onion v3 addresses with public keys and ports. Features: DNS seed name servers with DNSSEC support, network-specific seed configurations. Used by: P2P layer for initial peer discovery and network bootstrapping. Critical for new nodes joining the network. Format: peer_seeds entries with public_key::/transport/address/port. |
| `c_base_node_a.toml` | Base node configuration preset file A. Defines identity file locations for different Tari networks (igor, esmeralda, stagenet, nextnet). Sets network-specific base node identity file paths for each test network environment. Used by: base node applications. Dependencies: None. Related files: Other preset configuration files. |
| `c_base_node_b_mining_allow_methods.toml` | Base node configuration preset for mining operations with restricted gRPC methods. Enables gRPC server with specific allowed methods for mining including get_new_block_template, submit_block, search_utxos, and mining-related APIs. Restricts access to sensitive operations while allowing mining functionality. Used by: mining base nodes. Dependencies: Base node gRPC server. Related files: Other mining preset configurations. |
| `c_base_node_b_non_mining_allow_methods.toml` | Base node configuration preset for non-mining operations with restricted gRPC methods. Enables gRPC server with allowed methods for non-mining use cases, excluding mining-specific APIs like get_new_block_template and submit_block. Focuses on blockchain query and transaction services. Used by: non-mining base nodes. Dependencies: Base node gRPC server. Related files: Mining preset configurations. |
| `c_base_node_c.toml` | Base node configuration preset file C. Additional base node configuration options and settings for specific deployment scenarios. Provides alternative configuration parameters for specialized base node setups. Used by: base node applications in specific environments. Dependencies: None. Related files: Other base node preset configurations (a, b variants). |
| `d_console_wallet.toml` | Configuration preset for Tari console wallet application. Defines console wallet-specific settings, network parameters, and operational configurations. Used for console wallet application initialization and runtime configuration. Dependencies: Common configuration modules. Used by: minotari_console_wallet application. Related files: Wallet configuration modules. |
| `e_validator_node.toml` | Configuration preset for Tari validator node in Digital Assets Network (DAN). Defines validator-specific settings, consensus parameters, and DAN layer configuration. Used for validator node deployment and operations in the second layer network. Dependencies: Common configuration modules. Used by: validator node applications. Related files: DAN consensus modules. |
| `f_merge_mining_proxy.toml` | Configuration preset for Tari merge mining proxy. Defines proxy settings for merge mining operations, Monero integration parameters, and mining pool connectivity. Used for setting up merge mining between Tari and Monero networks. Dependencies: Common configuration modules. Used by: merge mining proxy application. Related files: Mining configuration modules. |
| `g_miner.toml` | Configuration preset for Tari miner application. Defines mining-specific settings, pool connections, and mining algorithm parameters. Used for standalone mining operations and mining pool connectivity. Dependencies: Common configuration modules. Used by: minotari_miner application. Related files: Mining and merge mining configurations. |
| `h_collectibles.toml` | Configuration preset for Tari Collectibles application. Defines collectibles-specific settings, NFT parameters, and digital asset configuration. Used for collectibles marketplace and NFT functionality setup. Dependencies: Common configuration modules. Used by: Tari collectibles application. Related files: DAN and validator node configurations. |
| `i_indexer.toml` | Configuration preset for Tari blockchain indexer. Defines indexing parameters, database settings, and blockchain scanning configuration. Used for blockchain data indexing and search functionality. Dependencies: Common configuration modules. Used by: indexer applications and services. Related files: Database and blockchain modules. |
| `j_dan_wallet_daemon.toml` | Configuration preset for DAN (Digital Assets Network) wallet daemon. Defines DAN wallet-specific settings, layer 2 parameters, and daemon operation configuration. Used for DAN wallet daemon services. Dependencies: Common configuration modules. Used by: DAN wallet daemon applications. Related files: DAN and validator configurations. |

#### common/logging/

| File | Description |
|------|-------------|
| `README.md` | Documentation for Tari logging system using log4rs. Explains logging setup options including no logging, stdout logging for tests, and file-based logging for applications. Describes sample configuration files and recommended setup patterns. Documents precedence for log configuration path (CLI parameter, environment variable, default ~/.tari/log4rs.yml). Dependencies: log crate, log4rs, simple-logger. Used by: All Tari applications and tests. Related files: log4rs*.yml configuration files. Essential for managing application output, debugging, and operational monitoring across the Tari ecosystem. |
| `log4rs_collectibles.yml` | Log4rs configuration for Tari Collectibles application. Defines logging appenders for console (WARN+), network logs (comms, p2p, yamux), base layer logs (core application), and other third-party crates. Uses rolling file appenders with 10MB size limit and 5 file rotation. Routes different loggers to appropriate appenders with INFO level for application logs and ERROR for external crates. Dependencies: log4rs. Used by: Tari Collectibles application. |
| `log4rs_debug_sample.yml` | Debug-oriented log4rs configuration sample with enhanced logging for debugging. Includes source code line numbers, thread information, and more verbose output suitable for development and debugging. Provides detailed logging patterns and appender configurations for troubleshooting Tari applications. Dependencies: log4rs. Used by: Development and debugging environments. Related files: Other log4rs sample configurations. |
| `log4rs_sample_seed_node.yml` | Log4rs configuration sample for Tari seed node operations. Defines logging setup specifically optimized for seed node requirements including network connectivity logging, peer management, and DHT operations. Configures appropriate log levels and file rotation for seed node deployment. Dependencies: log4rs. Used by: Seed node deployments. Related files: Other application-specific logging configurations. |
| `log4rs_sample_transcoder.yml` | Log4rs configuration sample for Tari stratum transcoder. Defines logging setup for mining pool stratum protocol transcoding operations. Configures appropriate log levels for stratum message handling, mining operations, and pool connectivity. Dependencies: log4rs. Used by: Stratum transcoder deployments. Related files: Mining and stratum-related modules. |
| `log4rs_sample_validator_node.yml` | Log4rs configuration sample for Tari validator node in Digital Assets Network (DAN). Defines logging setup for DAN validator operations including consensus, template processing, and layer 2 interactions. Configures appropriate log levels and file rotation for validator node deployment. Dependencies: log4rs. Used by: DAN validator node deployments. Related files: Validator and DAN-related modules. |

#### common/src/

| File | Description |
|------|-------------|
| `dir_utils.rs` | Directory utilities for Tari applications. Provides cross-platform directory operations including creation, validation, and path management for Tari data directories. Handles platform-specific directory structures and permissions. Dependencies: std::fs, platform-specific libraries. Used by: All Tari applications for data directory management. Exports: Directory utility functions. |
| `exit_codes.rs` | Standard exit codes for Tari applications. Defines consistent exit code constants for different error conditions and successful termination across all Tari applications. Provides standardized error reporting for system integration and monitoring. Dependencies: None. Used by: All Tari applications for process exit codes. Exports: Exit code constants and utilities. |
| `lib.rs` | Common utilities library for Tari applications providing configuration management, logging initialization, and shared constants. Implements hierarchical configuration loading with precedence: CLI args > environment variables > config.toml > defaults. Supports custom application sections in configuration files using config crate. Provides ConfigBootstrap for CLI integration, DNS name server configuration, directory utilities, and standardized logging setup. Defines default file paths for configuration and logging, maximum gRPC message size (8 MiB), and exit code definitions for error handling across Tari applications. |
| `logging.rs` | Logging initialization and utilities for Tari applications. Provides logging setup functions, log4rs configuration loading, and logging utility functions including get_log4rs_configuration_path(). Handles logging initialization with environment variable and CLI parameter support. Dependencies: log, log4rs. Used by: All Tari applications during startup. Exports: Logging initialization and utility functions. |
| `network_check.rs` | Network connectivity and validation utilities for Tari applications. Provides functions to check internet connectivity, validate network endpoints, and perform network health checks. Used for ensuring proper network connectivity before starting Tari services. Dependencies: network libraries. Used by: Tari applications for network validation. Exports: Network checking utilities. |

##### common/src/configuration/

| File | Description |
|------|-------------|
| `bootstrap.rs` | Configuration bootstrap utilities for Tari applications. Defines ApplicationType enum (BaseNode, ConsoleWallet, MergeMiningProxy, Miner, etc.), user prompt functionality, and gRPC port defaults per network. Provides configuration installation helpers and application type string conversions. Dependencies: std, ConfigError, Network. Used by: All Tari applications during startup. Exports: ApplicationType, prompt, install_configuration, grpc_default_port functions. |
| `common_config.rs` | Common configuration structure for all Tari applications. Defines CommonConfig struct with base_path for data storage (defaults to ~/.tari/) and override_from for configuration inheritance. Implements Default trait with platform-specific home directory detection and SubConfigPath trait for configuration management. Dependencies: serde, dirs_next, SubConfigPath. Used by: All Tari applications. Exports: CommonConfig struct and trait implementations. |
| `config_list.rs` | Configuration list utilities for handling collections of configuration items. Provides generic list handling, validation, and serialization for configuration arrays and collections. Supports various list types used across Tari configuration system. Dependencies: serde. Used by: Configuration management modules. Exports: List handling utilities and traits. |
| `dns_name_server_list.rs` | DNS name server list configuration for Tari network discovery. Manages DNS servers used for peer discovery and network bootstrap operations. Provides validation and management of DNS server configurations including fallback options. Dependencies: serde, network utilities. Used by: Network discovery and bootstrap modules. Exports: DNS server list management. |
| `error.rs` | Error types and handling for Tari configuration system. Defines ConfigError enum for configuration parsing, validation, and loading errors. Provides error conversion traits and detailed error messages for configuration issues. Dependencies: thiserror. Used by: All configuration modules. Exports: ConfigError and error handling utilities. |
| `loader.rs` | Configuration loader for Tari applications. Handles loading, parsing, and merging of configuration files from multiple sources including default values, config files, environment variables, and command line arguments. Provides configuration precedence and validation. Dependencies: serde, config crate. Used by: All Tari applications during startup. Exports: Configuration loading utilities and traits. |
| `mod.rs` | Configuration module entry point for Tari common configuration system. Exports all configuration-related modules including bootstrap, common_config, loaders, error handling, and network utilities. Provides unified interface for configuration management across all Tari applications. Dependencies: All configuration submodules. Used by: Tari applications and libraries. Exports: Complete configuration system API. |
| `multiaddr_list.rs` | Multi-address list configuration for Tari network addressing. Manages lists of network multiaddresses for peer connections, bootstrap nodes, and service endpoints. Provides validation and serialization for libp2p multiaddr format used in Tari networking. Dependencies: serde, multiaddr. Used by: Network configuration modules. Exports: Multiaddr list management utilities. |
| `name_server.rs` | Name server configuration for Tari DNS-based peer discovery. Defines DNS server configuration structures and validation for network bootstrap and peer discovery operations. Manages DNS resolver settings and fallback configurations. Dependencies: serde, DNS resolution libraries. Used by: Network discovery modules. Exports: DNS name server configuration. |
| `network.rs` | Network configuration definitions for Tari networks. Defines Network enum (MainNet, StageNet, NextNet, Esmeralda, Igor, LocalNet) and network-specific parameters including genesis blocks, consensus rules, and network identifiers. Provides network selection and validation. Dependencies: serde. Used by: All Tari applications for network selection. Exports: Network enum and network utilities. |
| `serializers.rs` | Custom serializers for Tari configuration system. Provides specialized serde serialization/deserialization for complex configuration types including multiaddresses, duration values, and custom data structures. Handles configuration format conversions and validation during serialization. Dependencies: serde. Used by: Configuration modules requiring custom serialization. Exports: Custom serializer functions and traits. |
| `string_list.rs` | String list configuration utilities for Tari applications. Provides parsing, validation, and management of comma-separated string lists in configuration files. Handles string list serialization and conversion for configuration arrays. Dependencies: serde. Used by: Configuration modules with list-based settings. Exports: String list parsing and validation utilities. |
| `utils.rs` | Configuration utility functions and helpers for Tari applications. Provides common configuration operations including path resolution, environment variable handling, default value generation, and configuration validation helpers. Contains shared utilities used across the configuration system. Dependencies: std, path utilities. Used by: All configuration modules. Exports: Configuration utility functions. |

#### common/tari_features/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for tari_features crate - compilable features for Tari applications. Minimal dependency crate used for feature flag management across Tari ecosystem. Warning in comments about potential cyclic dependencies since this crate is used by most other Tari crates. Dependencies: None (intentionally minimal). Used by: Most Tari crates for feature management. Related files: src/feature.rs, src/resolver.rs, src/status.rs. |
| `README.md` | Documentation for tari_features crate explaining compile-time feature management for Tari applications. Documents feature flag system, usage patterns, and integration with cargo features. Provides guidelines for feature flag management across the Tari ecosystem. Dependencies: None (documentation only). Used by: Developers working with Tari features. Related files: Feature implementation modules. |

##### common/tari_features/src/

| File | Description |
|------|-------------|
| `feature.rs` | Core feature flag definitions and management for Tari applications. Defines feature structures, validation, and runtime feature checking capabilities. Provides compile-time and runtime feature flag resolution. Dependencies: Minimal (following tari_features design). Used by: Feature resolver and status modules. Exports: Feature definitions and management utilities. |
| `lib.rs` | Feature flag management system for Tari applications providing compile-time and runtime feature control. Implements Feature and Status types for feature state management, feature resolver for conditional functionality activation, and FEATURE_LIST for centralized feature catalog. Enables controlled rollout of new functionality, A/B testing capabilities, and graceful feature deprecation across Tari ecosystem. Currently defines empty feature list but provides infrastructure for future feature flag implementations. |
| `resolver.rs` | Feature flag resolver for determining active features at runtime. Handles feature flag resolution logic, dependency checking, and conflict resolution for Tari feature system. Provides runtime feature flag evaluation and validation. Dependencies: feature.rs. Used by: Applications requiring dynamic feature resolution. Exports: Feature resolver functionality. |
| `status.rs` | Feature status tracking and reporting for Tari feature system. Provides feature status enumeration, status checking utilities, and feature state management. Tracks enabled/disabled/conflict states for feature flags. Dependencies: feature.rs. Used by: Feature management and debugging tools. Exports: Feature status utilities and enums. |

#### common/xmrig_config/

| File | Description |
|------|-------------|
| `config_example_mainnet.json` | XMRig configuration example for Tari mainnet merge mining. Provides sample XMRig miner configuration for connecting to Tari mainnet merge mining operations. Includes pool settings, algorithm parameters, and network-specific configurations for mainnet deployment. Dependencies: XMRig miner. Used by: Mainnet merge mining setups. Related files: Other network-specific XMRig configurations. |
| `config_example_mainnet_self_select.json` | XMRig configuration example for Tari mainnet merge mining with self-selection. Provides sample XMRig configuration for self-selecting mining pools and custom merge mining setups on mainnet. Includes advanced pool configurations and custom selection parameters. Dependencies: XMRig miner. Used by: Advanced mainnet merge mining setups. Related files: Standard mainnet and other network configurations. |
| `config_example_stagenet.json` | XMRig configuration example for Tari stagenet merge mining. Provides sample XMRig miner configuration for connecting to Tari stagenet test network merge mining operations. Includes test network pool settings and stagenet-specific parameters. Dependencies: XMRig miner. Used by: Stagenet testing and development. Related files: Mainnet and other network XMRig configurations. |

### common_sqlite/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for tari_common_sqlite crate - a SQLite database wrapper library. Exports comprehensive SQLite functionality using Diesel ORM with r2d2 connection pooling. Key dependencies: diesel (SQLite, r2d2, JSON, chrono support), diesel_migrations, tokio (async runtime). Used across Tari project for database abstraction and connection management. |
| `README.md` | Documentation for tari_common_sqlite crate explaining its role as Tari's SQLite wrapper implementation. Part of the Tari Cryptocurrency project's shared database infrastructure. |

#### common_sqlite/src/

| File | Description |
|------|-------------|
| `connection.rs` | Core SQLite database connection implementation with WAL mode and connection pooling. Exports: DbConnectionUrl (enum for connection types), DbConnection (main connection wrapper). Handles connection pooling, migrations, temporary databases, and SQLite concurrency patterns. Implements PooledDbConnection trait. Includes extensive documentation on SQLite's concurrency limitations, WAL mode, and write transaction best practices. Used by all database-dependent components in Tari. |
| `connection_options.rs` | SQLite connection configuration options for database customization. Exports: ConnectionOptions struct for configuring WAL mode, foreign keys, and busy timeout. Implements diesel::r2d2::CustomizeConnection trait to apply PRAGMA settings on connection acquisition. Used by SqliteConnectionPool for connection initialization. |
| `error.rs` | Error types for SQLite storage operations. Exports: SqliteStorageError (pool/connection errors), StorageError (comprehensive database error types). Handles Diesel ORM errors, connection failures, migration errors, JSON serialization errors, and IO errors. Used throughout common_sqlite crate for error handling and propagation. |
| `lib.rs` | SQLite database utilities and connection management library for Tari applications. Provides connection pooling (sqlite_connection_pool), connection configuration options, database error handling, and utility functions for SQLite operations. Includes connection management for concurrent access, configuration options for database tuning, comprehensive error types for database operations, and utilities for database maintenance and optimization. Shared across all Tari components requiring SQLite storage. |
| `sqlite_connection_pool.rs` | SQLite connection pool implementation using r2d2 for managed database connections. Exports: SqliteConnectionPool (pool manager), PooledDbConnection trait. Provides connection pooling with configurable size, timeout handling, WAL mode, and foreign key support. Includes pool state monitoring, cleanup methods, and various connection acquisition strategies (blocking, timeout, non-blocking). Used by DbConnection for efficient connection management. |

##### common_sqlite/src/util/

| File | Description |
|------|-------------|
| `diesel_ext.rs` | Diesel ORM extension utilities for enhanced query result handling. Exports: ExpectedRowsExtension trait with num_rows_affected_or_not_found() method. Provides validation for expected row counts in database operations, converting mismatched results to NotFound errors. Used for ensuring database operations affect the expected number of rows. |
| `mod.rs` | Utility module for common_sqlite crate. Re-exports diesel_ext module containing Diesel ORM extensions and helper functions for database operations. |

###### common_sqlite/test/migrations/2023-03-07-135137_initial/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback file that removes the test table created by the initial migration. Drops `test_table` if it exists. Part of the common SQLite testing infrastructure for database migration rollback testing. Used by: diesel migration system, SQLite test suite. |
| `up.sql` | Database migration file that creates the initial test table structure. Creates `test_table` with auto-incrementing primary key column `id`. Part of the common SQLite testing infrastructure for database migration testing. Used by: diesel migration system, SQLite test suite. |

#### comms/core/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo manifest for tari_comms crate - Tari's peer-to-peer messaging system. Comprehensive networking library with dependencies: tari_crypto (cryptography), noise protocol (snow), yamux (multiplexing), multiaddr (network addressing), diesel (peer storage), tokio (async runtime). Features: c_integration, metrics, rpc. Core component for all P2P communication in Tari Base Layer and Digital Asset Network. |
| `README.md` | Documentation for Tari Common Comms crate explaining its role as shared communication infrastructure. Provides networking features used by both Tari Base Layer and Digital Asset Network components. Part of the Tari Cryptocurrency project's P2P communication stack. |
| `build.rs` | Build script for tari_comms crate. Compiles Protocol Buffer definitions from src/proto directory using tari_common::build::ProtobufCompiler. Generates Rust code from .proto files for network protocol definitions used in P2P communication. |

##### comms/core/examples/

| File | Description |
|------|-------------|
| `stress_test.rs` | Main executable for P2P communications stress testing tool. Supports command-line arguments: --tcp, --public-ip, --tor-identity, --identity, --peer, --port. Creates temporary directories, initializes nodes with TCP or Tor transport, handles user prompts for protocol selection, and manages stress test execution with graceful shutdown. Used for testing network performance, latency, and reliability under various conditions. |
| `tor.rs` | Tor network example demonstrating P2P communication over Tor hidden services. Exports: create_test_peer(), setup_node_with_tor(), start_ping_ponger(). Creates two CommsNodes with Tor transport, establishes peer connections, and implements ping-pong messaging with latency measurement. Requires running Tor proxy with ControlPort. Demonstrates Tor integration, hidden service setup, and encrypted P2P messaging over Tor network. |
| `vanity_id.rs` | Vanity NodeId generator for creating node identities with specific hex prefixes. Spawns multiple worker threads to generate cryptographic key pairs until finding NodeIds that start with desired hex patterns. Exports generated identities to JSON files in temporary directory. Features parallel mining with progress reporting and graceful termination. Used for generating memorable or branded node identities for testing and development purposes. |

###### comms/core/examples/stress/

| File | Description |
|------|-------------|
| `error.rs` | Error types for stress testing tools. Exports comprehensive Error enum covering: Tor controller errors, CommsBuilder errors, peer management errors, connectivity errors, message format errors, async task errors, I/O errors, protocol frame validation errors. Includes UserQuit for graceful termination and ReplyCanceled for async communication failures. Used throughout stress testing examples for robust error handling and reporting. |
| `mod.rs` | Stress testing module for comms P2P networking. Defines constants: MAX_FRAME_SIZE (8MB), TOR_CONTROL_PORT_ADDR, TOR_SOCKS_ADDR, STRESS_PROTOCOL_NAME. Exports modules: error, node, prompt, service. Used for network load testing and performance evaluation of Tari P2P communications under stress conditions. |
| `node.rs` | CommsNode creation for stress testing with TCP and Tor transport options. Exports: create_test_peer(), create() async function. Sets up peer database, protocol handlers, messaging pipeline, and transport layers (TCP or Tor hidden service). Handles node identity management, public address configuration, and protocol extensions for stress test communications. Used by stress test service for network node initialization. |
| `prompt.rs` | Interactive command-line prompt utility for stress testing the Tari communications layer. Exports: user_prompt(), to_short_str(), parse_from_short_str(). Provides user interface for selecting stress test types (continuous send, alternating send, messaging flood), configuring peer connections, and setting test parameters. Dependencies: tari_comms peer management, multiaddr networking. Used by: stress testing examples and benchmarks. |
| `service.rs` | Stress testing service implementation for P2P communication testing. Exports: StressTestService, StressTestServiceRequest, StressProtocol (with ContinuousSend, AlternatingSend, MessagingFlood variants). Implements initiator/responder protocols for performance testing with configurable message counts and sizes. Features protocol negotiation, substream management, and comprehensive test metrics. Generates random test data and measures throughput, latency, and message delivery rates for network stress testing. |

##### comms/core/src/

| File | Description |
|------|-------------|
| `backoff.rs` | Backoff strategies for connection retry logic. Exports: Backoff trait, BoxedBackoff type alias, ExponentialBackoff (exponential growth with overflow protection), ConstantBackoff (fixed duration). Used by connection dialer for retry attempts with configurable delays. ExponentialBackoff defaults to 1.5x factor with upper bounds to prevent overflow. Essential for resilient P2P connection establishment with progressive retry delays. |
| `bans.rs` | Peer banning duration constants for protocol violations and misbehavior. Exports: BAN_DURATION_LONG (2 hours), BAN_DURATION_SHORT (2 minutes). Used by peer manager and connection validation logic to temporarily ban peers for various offenses. TODO note indicates these durations need consolidation across the codebase. |
| `bounded_executor.rs` | Semaphore-bounded task executor for limiting concurrent operations. Exports: BoundedExecutor, TrySpawnError. Provides async spawn() and try_spawn() methods with configurable concurrency limits. Used by connection listener to prevent overwhelming the system with simultaneous inbound connections. Includes theoretical maximum task calculation and availability tracking. Critical for connection backpressure and resource management. |
| `framing.rs` | Length-delimited framing utilities for P2P message transmission. Exports: CanonicalFraming type alias, canonical() function. Provides standard frame format using tokio-util's LengthDelimitedCodec with configurable maximum frame lengths. Implements StreamId trait for stream identification. Used throughout comms for consistent message framing over TCP and other transports, ensuring reliable message boundaries in P2P communications. |
| `lib.rs` | Tari network messaging library providing peer-to-peer communication infrastructure. Exports CommsBuilder for network setup, connection management for peer connections, peer discovery and management, noise protocol for encryption, message framing and multiplexing, transport abstractions (including Tor support), and protocol definitions. Includes utilities for backoff strategies, bounded execution, memory sockets, SOCKS proxy support, peer validation, and ban management. Re-exports multiaddr for network addressing and async-trait for async programming patterns. |
| `macros.rs` | Utility macros for builder patterns, lock management, and error handling. Exports: setter!, setter_mut!, acquire_lock!, log_if_error!, wrap_in_envelope_body!, outdir_include!. Provides builder pattern setters, poison-resistant lock acquisition, optional error logging with automatic conversion to Option, and envelope body construction. Used extensively throughout: comms core for reducing boilerplate code and ensuring consistent error handling patterns. |
| `stream_id.rs` | Stream identifier types for multiplexed connection management. Exports: StreamId types, stream identification utilities. Provides unique identifiers for multiplexed streams within connections enabling stream tracking and management. Supports stream lifecycle and identification across connection multiplexing layers. Used by: multiplexing system, connection management for stream identification and tracking. |
| `traits.rs` | Common trait definitions for the communications system. Exports: shared traits, interface definitions, common behavior contracts. Defines traits used across the comms system for consistent interfaces and behavior contracts. Provides abstraction layer and polymorphism support. Used throughout: comms system for defining consistent interfaces and behavior contracts. |
| `types.rs` | Core type definitions and aliases for the communications system. Exports: type aliases, shared data structures, common enums. Defines fundamental types used throughout the comms system including public keys, signatures, database types, and protocol identifiers. Provides type consistency and shared definitions. Used throughout: comms system for type consistency and shared data structures. |

###### comms/core/src/builder/

| File | Description |
|------|-------------|
| `comms_node.rs` | Core communications node builder and runtime management. Exports: UnspawnedCommsNode, CommsNode. Provides the main API for building and spawning Tari communication nodes with protocol extensions, RPC servers, connectivity management, and peer management. Dependencies: connection manager, connectivity manager, peer manager, protocol extensions. Key types: CommsNode handles node lifecycle, UnspawnedCommsNode is the builder pattern. Implements self-liveness checking and graceful shutdown coordination. |
| `consts.rs` | Constants defining buffer sizes for communications system channels and queues. Exports: CONNECTIVITY_MANAGER_REQUEST_BUFFER_SIZE (10), CONNECTIVITY_MANAGER_EVENTS_BUFFER_SIZE (500), CONNECTION_MANAGER_REQUEST_BUFFER_SIZE (10), CONNECTION_MANAGER_EVENTS_BUFFER_SIZE (30). Used by: connectivity manager, connection manager for configuring async channel buffer capacities and preventing backpressure issues. |
| `error.rs` | Error types for communications builder system. Exports: CommsBuilderError enum. Defines all possible errors during comms node construction including peer manager errors, connection manager errors, missing node identity/shutdown signal, missing peer storage, protocol extension failures, and Tor hidden service errors. Dependencies: thiserror, connection_manager, peer_manager, protocol, tor modules. Used by: CommsBuilder for error handling during node setup and initialization. |
| `mod.rs` | CommsBuilder for configuring and constructing Tari P2P communication nodes. Exports: CommsBuilder, CommsNode, UnspawnedCommsNode, CommsShutdown, CommsBuilderError. Provides fluent API for setting node identity, peer storage, network configuration, backoff strategies, connection limits, and protocol extensions. Creates connection manager and connectivity components with comprehensive configuration options. Central entry point for initializing Tari P2P networking stack. |
| `placeholder.rs` | Placeholder service implementation that panics when used. Exports: PlaceholderService struct. Used as a type placeholder in builder patterns before actual services are configured. Implements Tower Service trait but panics on poll_ready() and call(). Dependencies: tower, futures. Used by: builder system for type-safe service composition before real implementations are provided. |
| `shutdown.rs` | Future wrapper for coordinated shutdown of communications services. Exports: CommsShutdown struct implementing Future trait. Aggregates multiple shutdown signals and resolves when all services have cleanly shut down. Uses futures::join_all for concurrent waiting. Dependencies: tari_shutdown, futures. Used by: CommsNode for graceful shutdown coordination across connection manager, connectivity manager, and protocol services. |
| `tests.rs` | Unit tests for communications builder functionality. Tests CommsBuilder configuration, node spawning, protocol extension registration, and builder pattern validation. Verifies error handling for missing components, shutdown coordination, and proper initialization sequences. Dependencies: test utilities, node identity helpers. Used by: CI/CD for ensuring builder system reliability. |

###### comms/core/src/connection_manager/

| File | Description |
|------|-------------|
| `common.rs` | Common utilities for peer identity validation and connection management. Exports: ValidatedPeerIdentityExchange, PeerConnectionInfo, PeerIdentityMetadata, perform_identity_exchange(), validate_peer_identity_message(), create_or_update_peer_from_validated_peer_identity(), find_unbanned_peer(), ban_on_offence(). Handles peer identity protocol exchange, validation of addresses/protocols/features, and automatic peer banning for protocol violations. Core component for secure peer validation and identity management in P2P connections. |
| `dial_state.rs` | State management for outbound peer connection attempts. Exports: DialState struct. Tracks dial attempt count, target peer information, cancellation signals, and result channels for connection attempts. Provides methods for incrementing attempts, sending replies, and accessing peer data. Dependencies: tari_shutdown, tokio channels, peer_manager. Used by: connection manager for managing outbound connection state and retry logic. |
| `dialer.rs` | Peer dialing implementation with retry logic and connection establishment. Exports: DialerRequest enum, Dialer struct. Handles outbound connections with backoff strategies, address filtering, noise protocol upgrades, peer identity exchange, and multiplexing setup. Supports dial cancellation, pending request management, and inbound connection notifications. Implements connection validation, public key verification, and comprehensive error handling with retry mechanisms. Critical component for establishing secure outbound P2P connections in Tari network. |
| `direction.rs` | Connection direction enumeration for P2P connections. Exports: ConnectionDirection enum with Inbound (listening for incoming) and Outbound (establishing outgoing) variants. Provides utility methods: is_inbound(), is_outbound(), as_str(). Used throughout connection management to distinguish connection types for metrics, routing, and protocol handling. Critical for understanding connection flow and implementing direction-specific logic in P2P networking. |
| `error.rs` | Error types for connection management operations. Exports: ConnectionManagerError (comprehensive connection errors including transport, noise, yamux, peer management, validation failures), PeerConnectionError (peer-specific connection errors). Covers dial failures, handshake errors, transport issues, protocol violations, peer banning, listener failures, and timeout conditions. Essential for robust error handling throughout the P2P connection lifecycle with detailed error context for debugging. |
| `listener.rs` | Inbound peer connection listener with transport abstraction and connection processing. Exports: PeerListener struct. Binds to configured addresses, accepts inbound connections, reads wire format bytes, performs noise upgrades, validates peer identities, and creates peer connections. Supports liveness checks, bounded connection processing, protocol negotiation, and connection validation. Handles multiple wire modes (comms/liveness) with CIDR allowlists and session limits. Essential component for accepting and processing inbound P2P connections. |
| `manager.rs` | Core ConnectionManager actor implementation for P2P connection orchestration. Exports: ConnectionManagerEvent (connection state events), ConnectionManagerConfig (configuration), ListenerInfo (bind addresses), ConnectionManager struct. Manages listeners (main + auxiliary TCP), dialer, protocol notifications, and event publishing. Handles dial requests, cancel operations, and listening notifications. Coordinates between dialer and listener components with comprehensive connection state management, metrics tracking, and shutdown handling. Central hub for all P2P connection management in Tari. |
| `metrics.rs` | Prometheus metrics collection for connection manager operations. Exports: pending_connections(), successful_connections(), failed_connections(), inbound_substream_counter(). Tracks connection counts by direction (inbound/outbound), success/failure rates, and protocol-specific substream requests. Dependencies: tari_metrics, once_cell. Used by: connection manager for monitoring and observability of network connections. |
| `mod.rs` | Connection manager module for orchestrating P2P peer connections. Exports: ConnectionDirection, ConnectionManagerRequest/Requester, ConnectionManager, ConnectionManagerConfig/Event, ListenerInfo, ConnectionManagerError, PeerConnectionError, ConnectionId, NegotiatedSubstream, PeerConnection, PeerConnectionRequest, SelfLivenessCheck/Status, WireMode. Responsible for dialing peers, listening for connections, performing connection upgrades (noise protocol, identity, multiplexing), and notifying connectivity manager of connection state changes. Core networking component handling all P2P connection lifecycle management. |
| `peer_connection.rs` | Active peer connection management and lifecycle handling. Exports: PeerConnection struct, PeerConnectionActor. Manages bidirectional connections to peers including substream multiplexing, RPC client pools, liveness tracking, and graceful disconnection. Tracks connection statistics, handles protocol negotiations, and provides async interface for substream requests. Dependencies: yamux multiplexing, tokio async runtime, connection metrics. Used by: connection manager for active connection state management. |
| `requester.rs` | Async request interface for connection manager operations. Exports: ConnectionManagerRequester struct. Provides async methods for connection requests, disconnections, peer banning, listener management, and event subscriptions. Acts as async facade over mpsc channels to connection manager actor. Dependencies: tokio channels, connection manager events. Used by: connectivity manager, applications for requesting connection operations. |
| `self_liveness.rs` | Self-liveness checking system for verifying node's external connectivity. Exports: SelfLivenessCheck, SelfLivenessStatus enum. Periodically connects to own public addresses to verify reachability from external perspective. Useful for detecting NAT/firewall issues and confirming public address validity. Dependencies: transport layer, public address configuration. Used by: CommsNode for connectivity health monitoring. |
| `wire_mode.rs` | Wire protocol mode definitions for connection handshaking and frame encoding. Exports: WireMode enum and related types. Defines different framing and encoding modes used during connection establishment and communication. Handles protocol negotiation and wire format selection. Used by: connection manager for protocol negotiation and frame processing. |

###### comms/core/src/connection_manager/tests/

| File | Description |
|------|-------------|
| `listener_dialer.rs` | Integration tests for connection manager listener and dialer functionality. Tests connection establishment, concurrent connections, error handling, and connection lifecycle management. Verifies proper behavior of listener and dialer components under various scenarios. Used by: CI/CD for ensuring connection manager reliability. |
| `manager.rs` | Unit tests for connection manager core functionality. Tests connection management, peer connection handling, request processing, and manager state transitions. Verifies connection manager behavior and error conditions. Used by: CI/CD for ensuring connection manager correctness. |
| `mod.rs` | Test module for connection manager functionality. Exports test utilities and integration tests for connection management. Contains tests for connection establishment, peer connection lifecycle, error handling, and connection pooling. Dependencies: test utilities, mock components. Used by: CI/CD for ensuring connection manager reliability and correctness. |

###### comms/core/src/connectivity/

| File | Description |
|------|-------------|
| `config.rs` | Configuration structure for connectivity management behavior. Exports: ConnectivityConfig struct with default implementation. Defines minimum connectivity thresholds, connection pool refresh intervals, connection reaping settings, failure thresholds, tie-breaking delays, peer expiration times, and connection count limits. Default values include 1 min connectivity, 60s refresh interval, 20min inactivity threshold. Used by: connectivity manager for policy configuration. |
| `connection_pool.rs` | Connection pool state management for tracking peer connectivity status. Exports: ConnectionPool struct, ConnectionStatus enum. Maintains HashMap of NodeId to connection status (NotConnected, Connecting, Connected, Retrying, Failed, Disconnected). Provides methods for updating status, filtering by state, and querying connection statistics. Dependencies: node manager. Used by: connectivity manager for maintaining pool state and making connection decisions. |
| `connection_stats.rs` | Connection statistics tracking for connectivity analysis. Exports: PeerConnectionStats struct. Tracks per-peer connection metrics including attempt counts, success rates, failure reasons, last connection times, and connection quality indicators. Provides historical data for connection decision making. Used by: connectivity manager for peer ranking and connection retry logic. |
| `error.rs` | Error types for connectivity management operations. Exports: ConnectivityError enum. Defines errors for connection pool operations, peer selection failures, configuration issues, and connectivity manager state problems. Implements error conversion from underlying connection manager and peer manager errors. Dependencies: thiserror, connection_manager, peer_manager. Used by: connectivity manager for error handling and propagation. |
| `manager.rs` | Core connectivity manager implementation for automated peer connection management. Exports: ConnectivityManager struct. Orchestrates connection pool maintenance, peer selection algorithms, connection reaping, retry logic, and connectivity state monitoring. Implements actor pattern with message handling for connection requests, peer management, and status reporting. Used by: CommsNode as central connection orchestration service. |
| `metrics.rs` | Prometheus metrics collection for connectivity manager operations. Exports metric collection functions for connection pool statistics, connectivity events, peer selection performance, and connection success/failure rates. Tracks connectivity manager health and performance indicators. Dependencies: tari_metrics. Used by: connectivity manager for observability and monitoring. |
| `mod.rs` | Connectivity management module for maintaining peer connection pools. Exports: ConnectivityManager, ConnectivityRequester, ConnectivityConfig, ConnectionPool. Orchestrates automatic connection management, connection reaping, peer selection, and connectivity monitoring. Maintains desired number of connections and handles automatic reconnection logic. Used by: comms node builder for peer connectivity automation. |
| `requester.rs` | Async request interface for connectivity manager operations. Exports: ConnectivityRequester struct, ConnectivityRequest enum, ConnectivityEvent types. Provides async API for connection management requests, peer addition/removal, connectivity status queries, and event subscriptions. Acts as async facade over mpsc channels to connectivity manager actor. Used by: applications, protocol extensions for connection management operations. |
| `selection.rs` | Peer selection algorithms for connectivity management. Exports: ConnectivitySelection struct and selection strategies. Implements algorithms for choosing which peers to connect to based on connection pool state, peer priority, network distance, and connectivity goals. Handles peer ranking and selection optimization. Used by: connectivity manager for intelligent peer connection decisions. |
| `test.rs` | Unit tests for connectivity management functionality. Tests connection pool operations, peer selection algorithms, connectivity state transitions, and manager request handling. Verifies proper behavior under various network conditions and failure scenarios. Dependencies: test utilities, mock connections. Used by: CI/CD for ensuring connectivity system reliability. |

###### comms/core/src/memsocket/

| File | Description |
|------|-------------|
| `mod.rs` | In-memory socket implementation for testing and local communication. Exports: MemorySocket struct. Provides bidirectional in-memory transport that mimics TCP sockets without network overhead. Useful for unit testing, local node communication, and development scenarios. Implements AsyncRead/AsyncWrite traits. Used by: test suites, local development for simulating network connections. |

###### comms/core/src/message/

| File | Description |
|------|-------------|
| `envelope.rs` | Message envelope container for multiple protobuf message parts. Exports: EnvelopeBody struct, wrap_in_envelope_body! macro. Provides multi-part message packaging with methods for adding/removing parts, size calculation, and protobuf decoding. Each envelope can contain multiple binary message parts. Dependencies: prost for protobuf handling. Used by: messaging protocol for batching and organizing multiple messages into single envelopes. |
| `error.rs` | Error types for message handling and envelope operations. Exports: MessageError enum. Defines errors for message serialization/deserialization, envelope construction, invalid message formats, and protobuf processing failures. Implements error conversion from prost and I/O errors. Dependencies: thiserror, prost. Used by: messaging system for error handling and propagation. |
| `inbound.rs` | Inbound message handling and envelope processing. Exports: InboundMessage struct. Represents received messages with source peer information, envelope body, and routing context. Provides message decoding, part extraction, and reply capabilities. Includes authenticated source verification and message validation. Used by: protocol handlers, messaging pipeline for processing received communications. |
| `mod.rs` | Message envelope and routing system for peer-to-peer communication. Exports: InboundMessage, OutboundMessage, EnvelopeBody, MessageTag, MessageError. Provides message envelope containers with multi-part support, routing information, and serialization/deserialization. Implements message tagging for protocol identification and routing. Used by: messaging protocol, protocol extensions for structured communication. |
| `outbound.rs` | Outbound message construction and envelope building. Exports: OutboundMessage struct, OutboundMessageBuilder. Constructs messages for transmission with destination routing, envelope packaging, and send options. Supports broadcast, direct messaging, and protocol-specific routing. Handles message prioritization and delivery guarantees. Used by: applications, protocol extensions for sending structured messages to peers. |
| `tag.rs` | Message tagging system for protocol identification and routing. Exports: MessageTag struct. Provides unique identifiers for message types and protocols enabling proper message routing and handler selection. Supports tag creation, comparison, and serialization. Used by: messaging protocol for message type identification and protocol demultiplexing. |

###### comms/core/src/multiplexing/

| File | Description |
|------|-------------|
| `error.rs` | Error types for stream multiplexing operations. Exports: MultiplexingError enum. Defines errors for yamux stream operations, substream creation failures, multiplexer initialization problems, and stream state management issues. Implements error conversion from yamux and I/O errors. Dependencies: thiserror, yamux. Used by: multiplexing layer for error handling and propagation. |
| `metrics.rs` | Prometheus metrics collection for stream multiplexing operations. Exports metric collection functions for substream counts, yamux connection statistics, stream creation/destruction rates, and multiplexer performance indicators. Tracks multiplexing layer health and throughput metrics. Dependencies: tari_metrics. Used by: multiplexing layer for observability and performance monitoring. |
| `mod.rs` | Stream multiplexing module for multiple concurrent protocols over single connections. Exports: Yamux multiplexing implementation, Substream type. Enables multiple bidirectional streams over single TCP connection using yamux protocol. Provides substream creation, management, and metrics collection. Dependencies: yamux crate, tokio async runtime. Used by: connection manager for protocol separation and concurrent communication channels. |
| `yamux.rs` | Yamux multiplexing implementation for stream management over single connections. Exports: Yamux multiplexer wrapper and configuration. Provides bidirectional stream multiplexing using yamux protocol with configurable window sizes, timeouts, and stream limits. Enables concurrent protocol communication over single TCP connection. Dependencies: yamux crate, tokio async runtime. Used by: connection manager for creating multiple communication channels per peer connection. |

###### comms/core/src/net_address/

| File | Description |
|------|-------------|
| `mod.rs` | Network address management module for peer addressing and connectivity. Exports: MultiAddr utilities, address statistics, address ranges, and address validation. Provides comprehensive network address handling with connection tracking, address quality metrics, and selection algorithms. Used by: peer manager, connectivity manager for network address operations and peer reachability. |
| `multiaddr_range.rs` | Multiaddress range operations for network address management. Exports: MultiAddr range types and operations. Provides functionality for handling ranges of network addresses, address filtering, and subnet operations. Useful for address pool management and network configuration. Dependencies: multiaddr crate. Used by: peer manager, address validation for network address range operations. |
| `multiaddr_with_stats.rs` | Multiaddress wrapper with connection statistics and metadata. Exports: MultiAddrWithStats struct. Extends multiaddr with connection attempt tracking, success/failure rates, last connection times, and address quality metrics. Provides historical connection data for peer ranking and address selection. Used by: peer manager for intelligent address selection and connection retry logic. |
| `mutliaddresses_with_stats.rs` | Collection of multiaddresses with aggregated statistics and address management. Exports: MultiAddressesWithStats struct. Manages multiple addresses per peer with connection statistics, address prioritization, and selection algorithms. Provides best address selection, address rotation, and connection quality tracking. Used by: peer manager for managing peer address lists and connection strategy optimization. |

###### comms/core/src/noise/

| File | Description |
|------|-------------|
| `config.rs` | Noise protocol configuration for encrypted communication channels. Exports: NoiseConfig struct. Implements Noise_XX_25519_ChaChaPoly_BLAKE2b protocol for secure peer-to-peer communication. Provides socket upgrade functionality with handshake timeout configuration. Creates authenticated and encrypted channels using node identity keys. Dependencies: snow noise library, node identity, crypto resolver. Used by: transport layer for establishing secure connections between peers. |
| `crypto_resolver.rs` | Cryptographic resolver for Noise protocol implementation. Exports: TariCryptoResolver struct. Provides cryptographic primitives integration between Tari's crypto library and Noise protocol requirements. Implements DH key generation, hashing, and cipher operations for Noise handshakes. Dependencies: snow noise library, tari crypto primitives. Used by: noise configuration for cryptographic operations during secure channel establishment. |
| `error.rs` | Error types for Noise protocol operations. Exports: NoiseError enum. Defines errors for handshake failures, crypto operations, socket upgrades, and protocol violations. Implements error conversion from snow noise library and I/O errors. Dependencies: thiserror, snow. Used by: noise protocol implementation for error handling and propagation during secure channel establishment. |
| `mod.rs` | Noise protocol module for secure communication channel establishment. Exports: NoiseConfig, NoiseSocket, NoiseError, crypto resolver. Implements Noise_XX protocol for authenticated and encrypted peer-to-peer communication. Provides socket upgrade functionality and handshake management. Used by: transport layer for establishing secure connections with forward secrecy and mutual authentication. |
| `socket.rs` | Noise protocol socket implementation with encrypted I/O operations. Exports: NoiseSocket struct, Handshake. Provides AsyncRead/AsyncWrite implementation over Noise-encrypted channels with frame-based communication. Handles handshake completion, encryption/decryption, and authenticated data transmission. Dependencies: snow noise library, tokio async I/O. Used by: connection layer for secure, authenticated communication channels. |

###### comms/core/src/peer_manager/

| File | Description |
|------|-------------|
| `error.rs` | Error types for peer management operations. Exports: PeerManagerError enum. Defines errors for peer storage, database operations, peer validation, address resolution, and identity verification failures. Implements error conversion from storage layer and validation errors. Dependencies: thiserror, peer storage. Used by: peer manager for error handling and propagation during peer operations. |
| `hashing.rs` | Hashing utilities for peer manager operations and DHT functionality. Exports: hashing functions for node IDs, peer identification, and DHT distance calculations. Provides consistent hashing algorithms for peer addressing and network topology operations. Dependencies: blake2, hashing primitives. Used by: peer manager, DHT routing for node identification and distance-based operations. |
| `identity_signature.rs` | Digital signature verification for peer identity claims and authentication. Exports: IdentitySignature struct, signature verification functions. Provides cryptographic verification of peer identity claims, signature creation/validation, and authentication data structures. Ensures peer identity integrity and prevents impersonation. Dependencies: tari crypto, signature schemes. Used by: peer validation, identity verification during connection establishment. |
| `manager.rs` | Core peer manager implementation for peer storage and management operations. Exports: PeerManager struct with comprehensive peer management functionality. Implements async interface to peer database with CRUD operations, peer queries, address management, and peer relationship tracking. Central component for peer data management with SQLite backend. Used throughout: comms system for peer information storage and retrieval. |
| `metrics.rs` | Prometheus metrics collection for peer management operations. Exports metric collection functions for peer counts, storage operations, identity verification performance, and peer database statistics. Tracks peer manager health and operational metrics. Dependencies: tari_metrics. Used by: peer manager for observability and performance monitoring. |
| `mod.rs` | Peer management module for storing and managing network peer information. Exports: PeerManager, Peer, NodeId, NodeIdentity, PeerFeatures, and related types. Provides persistent peer storage, identity management, peer discovery, and address management. Implements SQLite-backed peer database with async interface. Used by: connectivity manager, connection manager for peer information and network topology management. |
| `node_distance.rs` | Node distance calculations for DHT routing and peer selection. Exports: NodeDistance struct and distance calculation functions. Implements XOR distance metric between node IDs for DHT operations, peer ranking, and network topology calculations. Provides distance-based peer selection and routing algorithms. Used by: DHT implementation, peer selection algorithms for network routing and connectivity optimization. |
| `node_id.rs` | Unique node identifier implementation for peer addressing and DHT operations. Exports: NodeId struct with serialization, hashing, and comparison traits. Derived from public key via Blake2b hash, provides 256-bit fixed-size identifier for nodes. Implements XOR distance calculation for DHT routing, hex encoding/decoding, and validation. Dependencies: blake2, tari_utilities, serde. Used extensively by: peer manager, DHT routing, connection management for node identification and distance calculations. |
| `node_identity.rs` | Node identity management for cryptographic identity and addressing. Exports: NodeIdentity struct. Manages node's cryptographic keypair, public addresses, node ID derivation, and identity proof generation. Provides identity validation, signature operations, and public key management. Core component for node authentication and identification. Used by: comms builder, peer validation, connection authentication for node identity operations. |
| `or_not_found.rs` | Utility type for optional peer lookup results with error handling. Exports: OrNotFound enum and helper functions. Provides ergonomic handling of peer lookup operations that may return None vs actual errors. Distinguishes between 'peer not found' and other error conditions in peer storage operations. Used by: peer manager for improved error semantics in peer queries. |
| `peer.rs` | Core peer data structure and operations. Exports: Peer struct with comprehensive peer information. Contains public key, node ID, network addresses, features, connection statistics, and metadata. Provides peer serialization, validation, address management, and peer comparison operations. Central data structure for representing network peers. Used throughout: peer manager, connectivity, connection management for peer representation. |
| `peer_features.rs` | Peer feature flags and capability declarations. Exports: PeerFeatures bitflags. Defines peer capabilities including communication node, base node, validator, and service-specific features. Enables peer capability discovery and protocol compatibility checking. Supports feature-based peer filtering and service discovery. Used by: peer management, protocol negotiation for capability-based peer selection and compatibility. |
| `peer_id.rs` | Peer identifier types and conversion utilities. Exports: PeerId enum supporting multiple identifier formats. Enables peer identification by NodeId, PublicKey, or short ID variants. Provides conversion between identifier types and peer lookup optimization. Supports flexible peer addressing schemes. Used by: peer manager, applications for peer identification and lookup operations. |
| `peer_identity_claim.rs` | Peer identity claim verification and authentication. Exports: PeerIdentityClaim struct. Handles cryptographic proof of peer identity ownership including signature verification, timestamp validation, and identity claim construction. Prevents identity spoofing and ensures authentic peer representation. Dependencies: signature verification, timestamp validation. Used by: peer validation, identity verification during peer discovery and connection establishment. |
| `peer_storage_sql.rs` | SQLite-based persistent storage implementation for peer data. Exports: PeerStorageSql struct. Provides async interface to SQLite database for peer CRUD operations, queries, and database maintenance. Handles peer serialization, indexing, migrations, and concurrent access. Dependencies: diesel ORM, SQLite database. Used by: PeerManager for persistent peer storage and retrieval operations. |

###### comms/core/src/peer_manager/storage/

| File | Description |
|------|-------------|
| `database.rs` | Database layer implementation for peer storage operations. Exports: database connection management, transaction handling, and query interfaces. Provides low-level database operations for peer storage including connection pooling, query optimization, and error handling. Dependencies: diesel, SQLite. Used by: peer storage SQL for database access and transaction management. |
| `mod.rs` | Peer storage module providing database abstraction layer. Exports: storage traits, database implementation, migration support. Provides interface between peer manager and persistent storage backend with support for different storage implementations. Handles data serialization, query optimization, and storage lifecycle. Used by: peer manager for persistent peer data storage operations. |
| `schema.rs` | Database schema definitions for peer storage tables. Exports: table definitions, column specifications, and schema constants. Generated by diesel to provide type-safe database access and query building. Defines peer table structure and relationships. Dependencies: diesel codegen. Used by: peer storage SQL for type-safe database operations and queries. |

###### comms/core/src/peer_manager/storage/migrations/

| File | Description |
|------|-------------|
| `.gitkeep` | Git keep file to maintain empty migrations directory structure. Ensures migrations directory exists in version control even when no migration files are present. Used by: build system, deployment scripts to maintain directory structure for peer storage database migrations. |

###### comms/core/src/peer_manager/storage/migrations/2025-04-14-072200_initial/

| File | Description |
|------|-------------|
| `down.sql` | Rollback migration for peer storage schema removal. Drops peer storage tables and indexes created by the initial migration. Provides clean rollback path for database schema changes. Used by: diesel migration system for peer database rollback operations. |
| `up.sql` | Initial database migration for peer storage schema creation. Creates peer storage tables including peers table with public key, node ID, addresses, features, and metadata columns. Sets up indexes for efficient peer queries and constraints for data integrity. Used by: diesel migration system for peer database initialization. |

###### comms/core/src/peer_manager/storage/migrations/2025-05-28-094300_remove_unique_constraint/

| File | Description |
|------|-------------|
| `down.sql` | Rollback migration to restore unique constraint in peer storage tables. Reverts constraint removal changes and restores original table constraints. Provides rollback path for constraint modification migration. Used by: diesel migration system for peer database rollback operations. |
| `up.sql` | Database migration to remove unique constraint from peer storage tables. Modifies peer table constraints to allow more flexible peer data management. Part of peer storage schema evolution for improved data handling. Used by: diesel migration system for peer database schema updates. |

###### comms/core/src/peer_validator/

| File | Description |
|------|-------------|
| `config.rs` | Configuration for peer validation behavior and policies. Exports: PeerValidatorConfig struct with validation parameters. Defines validation rules, timing parameters, signature verification settings, and identity checking policies. Configures peer acceptance criteria and validation strictness. Used by: peer validator for configuring validation behavior and security policies. |
| `error.rs` | Error types for peer validation operations. Exports: PeerValidatorError enum. Defines errors for signature verification failures, invalid identity claims, timestamp validation, and peer authentication issues. Implements error conversion from crypto and validation subsystems. Dependencies: thiserror, crypto errors. Used by: peer validator for error handling during peer verification processes. |
| `helpers.rs` | Utility functions for peer validation operations. Exports: validation helper functions for common validation tasks. Provides signature verification utilities, identity claim validation, timestamp checking, and peer authentication helpers. Reduces code duplication in validation logic. Used by: peer validator implementation for common validation operations. |
| `mod.rs` | Peer validation module for verifying peer identity claims and authentication. Exports: PeerValidator, validation functions, configuration types. Implements cryptographic verification of peer identities, signature validation, and authentication policies. Prevents identity spoofing and ensures network security. Used by: connection manager, peer manager for validating peer authenticity during connection establishment. |

###### comms/core/src/pipeline/

| File | Description |
|------|-------------|
| `builder.rs` | Builder pattern implementation for message processing pipelines. Exports: PipelineBuilder struct. Provides fluent API for constructing message processing pipelines with filters, transformers, sinks, and routing logic. Enables composable message processing workflows. Dependencies: pipeline components. Used by: protocol implementations for building custom message processing chains. |
| `inbound.rs` | Inbound message processing pipeline for handling received messages. Exports: inbound pipeline components and processors. Implements message filtering, validation, routing, and handler dispatch for incoming messages. Provides protocol-agnostic message processing framework. Dependencies: pipeline framework, message types. Used by: messaging protocol for processing received messages from peers. |
| `mod.rs` | Message processing pipeline module for composable message handling. Exports: pipeline builder, inbound/outbound processors, sinks, and pipeline utilities. Provides framework for building custom message processing workflows with filtering, transformation, and routing capabilities. Used by: messaging protocol, protocol extensions for structured message processing pipelines. |
| `outbound.rs` | Outbound message processing pipeline for preparing messages for transmission. Exports: outbound pipeline components and processors. Implements message encoding, routing, destination selection, and transmission preparation. Provides protocol-agnostic message sending framework. Dependencies: pipeline framework, message types. Used by: messaging protocol for processing outgoing messages to peers. |
| `sink.rs` | Pipeline sink components for message processing termination. Exports: sink types and implementations. Provides final processing stages for pipelines including message delivery, logging, metrics collection, and error handling. Implements various sink patterns for different processing outcomes. Used by: pipeline builder for defining message processing termination points. |
| `translate_sink.rs` | Translation sink for message format conversion in pipelines. Exports: TranslateSink struct. Provides message transformation and format conversion capabilities within processing pipelines. Enables protocol adaptation and message type conversion. Dependencies: pipeline framework, message transformation. Used by: pipeline implementations for message format adaptation and protocol bridging. |

###### comms/core/src/proto/

| File | Description |
|------|-------------|
| `envelope.proto` | Protocol buffer definition for message envelope structure. Defines EnvelopeBody message format with repeated bytes fields for multi-part message containers. Specifies wire format for message packaging and transmission. Used by: message envelope implementation for serialization and network transmission protocol. |
| `identity.proto` | Protocol buffer definition for peer identity and authentication structures. Defines message formats for identity claims, public keys, signatures, and authentication data. Specifies wire format for identity verification protocols. Used by: peer validation, identity management for network authentication and peer verification. |
| `mod.rs` | Protocol buffer module with generated message types and utilities. Exports: generated protobuf message types from .proto files, serialization utilities, and protobuf helper functions. Provides Rust bindings for protocol buffer messages used in network communication. Dependencies: prost, generated protobuf code. Used throughout: communications system for structured message serialization. |
| `rpc.proto` | Protocol buffer definition for RPC (Remote Procedure Call) message structures. Defines request/response message formats, method identification, error handling, and RPC metadata. Specifies wire format for RPC communication protocol. Used by: RPC system for structured remote procedure calls between peers. |

###### comms/core/src/protocol/

| File | Description |
|------|-------------|
| `error.rs` | Error types for protocol handling and extension operations. Exports: ProtocolError, ProtocolExtensionError enums. Defines errors for protocol registration, negotiation failures, extension installation issues, and protocol lifecycle management. Implements error conversion from subsystem errors. Dependencies: thiserror. Used by: protocol system for error handling during protocol operations. |
| `extensions.rs` | Protocol extension system for registering custom communication protocols. Exports: ProtocolExtension trait, ProtocolExtensions collection. Provides framework for implementing and registering custom protocols with lifecycle management, initialization, and cleanup. Enables extensible protocol ecosystem. Used by: applications, RPC system for implementing custom communication protocols. |
| `identity.rs` | Protocol for identity exchange and peer authentication during connection establishment. Exports: identity protocol implementation, identity exchange messages. Handles cryptographic identity verification, peer authentication, and secure identity establishment. Implements identity challenge-response protocols. Used by: connection manager for peer authentication during connection handshake. |
| `mod.rs` | Protocol system module for extensible communication protocols. Exports: ProtocolExtension trait, protocol registration, messaging protocol, RPC system, and protocol utilities. Provides framework for implementing and registering custom protocols with lifecycle management and capability negotiation. Core of Tari's extensible protocol architecture. |
| `negotiation.rs` | Protocol negotiation and capability exchange during connection establishment. Exports: protocol negotiation functions, capability exchange messages. Handles protocol version negotiation, feature discovery, and capability matching between peers. Ensures general protocol compatibility. Used by: connection establishment for determining supported protocols and communication capabilities. |
| `network_info.rs` | Network information and topology data structures. Exports: NetworkInfo struct, network statistics, topology metrics. Provides network topology information, connection statistics, and network health indicators. Used by: connectivity management, monitoring systems for network analysis and health assessment. |
| `protocols.rs` | Protocol registry and management system. Exports: Protocols collection, protocol registration, protocol identification. Manages registered protocols with support for protocol lookup, capability discovery, and protocol negotiation. Provides protocol registry for the extensible protocol system. Used by: protocol system for managing registered protocols and capabilities. |

###### comms/core/src/protocol/messaging/

| File | Description |
|------|-------------|
| `error.rs` | Error types for messaging protocol operations. Exports: MessagingProtocolError enum. Defines errors for message transmission, routing failures, protocol violations, and messaging subsystem issues. Implements error conversion from transport and pipeline errors. Dependencies: thiserror. Used by: messaging protocol for error handling during message operations. |
| `extension.rs` | Messaging protocol extension for peer-to-peer message communication. Exports: MessagingProtocolExtension struct. Implements protocol extension for general-purpose messaging between peers with routing, delivery guarantees, and message processing pipelines. Integrates with protocol extension system. Used by: applications requiring peer-to-peer messaging capabilities. |
| `forward.rs` | Message forwarding and routing logic for messaging protocol. Exports: message forwarding functions and routing algorithms. Implements message relay functionality, DHT-based routing, and multi-hop message delivery. Handles routing table management and forwarding decisions. Used by: messaging protocol for implementing message routing and network-wide message delivery. |
| `inbound.rs` | Inbound message handling for messaging protocol. Exports: InboundMessaging struct and message processors. Handles received message processing, validation, routing decisions, and delivery to application handlers. Implements message filtering and protocol demultiplexing. Dependencies: messaging pipeline, message validation. Used by: messaging protocol for processing incoming messages from peers. |
| `metrics.rs` | Prometheus metrics collection for messaging protocol operations. Exports metric collection functions for message throughput, routing performance, delivery success rates, and protocol-specific statistics. Tracks messaging system health and performance indicators. Dependencies: tari_metrics. Used by: messaging protocol for observability and performance monitoring. |
| `mod.rs` | Messaging protocol module for peer-to-peer communication. Exports: MessagingProtocol, inbound/outbound handlers, message routing, and messaging extension. Implements complete messaging system with routing, delivery guarantees, forwarding, and integration with protocol extension framework. Central messaging infrastructure for peer communication. |
| `outbound.rs` | Outbound message handling for messaging protocol. Exports: OutboundMessaging struct and message processors. Handles message transmission preparation, routing decisions, destination selection, and delivery tracking. Implements message queuing and send strategies. Dependencies: messaging pipeline, routing. Used by: messaging protocol for processing outgoing messages to peers. |
| `protocol.rs` | Core messaging protocol implementation for peer-to-peer communication. Exports: MessagingProtocol struct, protocol configuration, message handling logic. Implements full messaging protocol with inbound/outbound processing, routing, delivery guarantees, and protocol lifecycle management. Central component of messaging system. Used by: protocol extensions, applications for peer-to-peer messaging functionality. |
| `test.rs` | Unit tests for messaging protocol functionality. Tests message routing, delivery mechanisms, protocol lifecycle, error handling, and integration with connection management. Verifies proper behavior under various network conditions and failure scenarios. Dependencies: test utilities, mock connections. Used by: CI/CD for ensuring messaging protocol reliability. |

###### comms/core/src/protocol/rpc/

| File | Description |
|------|-------------|
| `body.rs` | RPC message body handling and serialization. Exports: RPC body types, message serialization utilities. Handles RPC message payload encoding/decoding, body streaming, and content management. Provides efficient message body handling for RPC communication. Used by: RPC client/server for message payload processing and transmission. |
| `context.rs` | RPC context and execution environment for request processing. Exports: RpcContext struct, request metadata, peer information. Provides execution context for RPC handlers including peer identity, request metadata, timeout information, and connection details. Enables context-aware RPC processing. Used by: RPC server handlers for accessing request context and peer information. |
| `either.rs` | Either type utility for RPC response handling. Exports: Either enum for handling dual response types. Provides utility type for RPC responses that can be one of two different types, enabling flexible response handling and type-safe response processing. Used by: RPC system for handling responses with multiple possible types. |
| `error.rs` | Error types for RPC system operations. Exports: RpcError enum, RpcStatus codes. Defines errors for RPC calls, server issues, client failures, protocol violations, and service errors. Implements error conversion and status code mapping. Dependencies: thiserror, RPC status codes. Used by: RPC client/server for error handling and propagation during RPC operations. |
| `event.rs` | RPC event system for monitoring RPC operations and lifecycle. Exports: RPC event types, event handling, event subscription. Provides event-driven monitoring of RPC operations including call events, connection events, and service events. Enables observability and debugging. Used by: RPC system for event monitoring and debugging capabilities. |
| `handshake.rs` | RPC handshake protocol for establishing RPC sessions. Exports: handshake negotiation functions, version negotiation, capability exchange. Implements RPC session establishment with protocol version negotiation, service discovery, and capability agreement. Ensures RPC compatibility between peers. Used by: RPC client/server for session establishment and capability negotiation. |
| `message.rs` | RPC message types and serialization for remote procedure calls. Exports: RPC request/response message structures, message encoding/decoding utilities. Defines wire format for RPC communication including method identification, parameter encoding, and response serialization. Dependencies: protobuf serialization. Used by: RPC client/server for message serialization and network transmission. |
| `mod.rs` | RPC (Remote Procedure Call) system module for structured peer communication. Exports: RPC client/server, message types, routing, error handling, and RPC protocol extension. Implements complete RPC framework with request/response handling, streaming, connection pooling, and service registration. Core infrastructure for structured peer-to-peer API calls. |
| `not_found.rs` | RPC service not found handling and error responses. Exports: NotFound response types, service discovery helpers. Handles cases where requested RPC services or methods are not available, providing appropriate error responses and service discovery guidance. Used by: RPC server for handling unknown service requests and providing helpful error responses. |
| `status.rs` | RPC status codes and error classification system. Exports: RpcStatus enum, status code definitions, error categorization. Defines standardized status codes for RPC operations including success, client errors, server errors, and network issues. Provides error classification and status mapping. Used by: RPC system for consistent error reporting and status communication. |

###### comms/core/src/protocol/rpc/client/

| File | Description |
|------|-------------|
| `metrics.rs` | Prometheus metrics collection for RPC client operations. Exports metric collection functions for RPC call counts, latency, success/failure rates, and client performance indicators. Tracks RPC client health and performance metrics. Dependencies: tari_metrics. Used by: RPC client for observability and performance monitoring. |
| `mod.rs` | RPC client module for making remote procedure calls to peers. Exports: RpcClient, connection pooling, request handling, and client utilities. Implements RPC client with connection management, request routing, timeout handling, and response processing. Supports both unary and streaming RPC calls. Used by: applications, services for making RPC calls to remote peers. |
| `pool.rs` | RPC client connection pooling for efficient resource management. Exports: RpcClientPool, connection management, pooling strategies. Implements connection pooling for RPC clients with connection reuse, load balancing, and connection lifecycle management. Optimizes resource usage and connection overhead. Used by: RPC client for managing connections to multiple peers and services. |
| `tests.rs` | Unit tests for RPC client functionality. Tests RPC call handling, connection management, error scenarios, and client lifecycle. Verifies proper RPC client behavior under various conditions. Dependencies: test utilities, mock services. Used by: CI/CD for ensuring RPC client reliability. |

###### comms/core/src/protocol/rpc/server/

| File | Description |
|------|-------------|
| `early_close.rs` | RPC server early connection close handling and cleanup. Exports: early close detection, connection cleanup utilities. Handles cases where RPC connections are closed prematurely, ensuring proper resource cleanup and error handling. Prevents resource leaks and provides graceful degradation. Used by: RPC server for connection lifecycle management and cleanup. |
| `error.rs` | Error types for RPC server operations. Exports: RpcServerError enum, server-specific error handling. Defines errors for service registration, request handling, server lifecycle, and server configuration issues. Implements error conversion and propagation. Dependencies: thiserror. Used by: RPC server for error handling during server operations. |
| `handle.rs` | RPC server request handling and processing framework. Exports: request handlers, service dispatch, method routing. Implements request processing pipeline with service routing, method dispatch, and response generation. Provides framework for implementing RPC service handlers. Used by: RPC server for processing incoming RPC requests and routing to appropriate services. |
| `metrics.rs` | Prometheus metrics collection for RPC server operations. Exports metric collection functions for RPC request counts, processing latency, error rates, and server performance indicators. Tracks RPC server health and performance metrics. Dependencies: tari_metrics. Used by: RPC server for observability and performance monitoring. |
| `mock.rs` | Mock RPC server implementation for testing and development. Exports: MockRpcServer, test service implementations. Provides mock RPC server for unit testing, integration testing, and development scenarios. Includes configurable behavior and response simulation. Used by: test suites, development environments for RPC testing and mocking. |
| `mod.rs` | RPC server module for handling incoming remote procedure calls. Exports: RpcServer, service registration, request handling, and server utilities. Implements RPC server with service routing, request processing, response generation, and connection management. Supports service registration and method dispatch. Used by: applications, services for exposing RPC endpoints to remote peers. |
| `router.rs` | RPC server routing and service dispatch system. Exports: RPC router, service registration, method routing. Implements service routing with method dispatch, path-based routing, and service discovery. Provides central routing infrastructure for RPC requests. Used by: RPC server for routing requests to appropriate service handlers and methods. |

###### comms/core/src/protocol/rpc/test/

| File | Description |
|------|-------------|
| `client_pool.rs` | Unit tests for RPC client connection pooling functionality. Tests the LazyPool implementation which provides lazy connection establishment, least-used connection reuse, connection pruning for disconnected sessions, and graceful handling of server-side session limits. Key test functions: it_connects_lazily(), it_reuses_unused_connections(), it_reuses_least_used_connections(), it_gracefully_handles_insufficient_server_sessions(), it_prunes_disconnected_sessions(), it_fails_when_peer_connected_disconnects(). Dependencies: GreetingClient/GreetingServer test services, RpcServer, PeerConnection mocks, tari_test_utils. Used by: RPC client pool implementation validation. Tests connection pooling strategies and edge cases for RPC client management. |
| `comms_integration.rs` | Integration test for RPC services using full communication stack. Tests complete RPC interaction flow including service registration, peer connection establishment, request-response patterns, and error handling. Key test function: run_service() which sets up two comms nodes, establishes peer connection, and validates successful RPC calls and error responses. Dependencies: CommsBuilder, MockRpcService/MockRpcClient, PeerDatabaseSql, MemoryTransport, node identity utilities. Used by: RPC integration testing. Validates end-to-end RPC functionality including success responses, error propagation (RpcStatus), and status codes (BadRequest, NotImplemented). |
| `greeting_service.rs` | Test RPC service implementation with comprehensive protocol examples. Defines GreetingRpc trait with 8 methods showcasing different RPC patterns: request-response (say_hello), error handling (return_error), server streaming (get_greetings), streaming errors, public key retrieval, large message handling, and slow streaming. Includes protobuf message definitions (SayHelloRequest/Response, SlowStreamRequest), both GreetingService and SlowGreetingService implementations, and manually generated server/client code (GreetingServer, GreetingClient) that would typically be auto-generated by macros. Dependencies: RPC framework, prost for protobuf, tokio async runtime. Used by: RPC test suites, protocol validation, performance testing. Serves as reference implementation for RPC service patterns in Tari communications. |
| `handshake.rs` | Unit tests for RPC handshake protocol between client and server. Tests successful handshake completion with version negotiation and handshake rejection scenarios. Key test functions: it_performs_the_handshake() validates client-server handshake with supported RPC versions, it_rejects_the_handshake() tests rejection with specific reasons (NoServerSessionsAvailable). Dependencies: Handshake protocol implementation, MemorySocket for in-memory connections, canonical framing, HandshakeRejectReason types. Used by: RPC handshake validation. Tests critical connection establishment phase including version compatibility and server capacity management. |
| `mock.rs` | Mock RPC service and client implementations for testing. Provides MockRpcService with configurable responses (success/error), call counting, and shared state management. Includes MockRpcClient for request-response and server streaming patterns. Key exports: MockRpcService (implements NamedProtocolService, Service traits), MockRpcServiceState (manages response configuration and call tracking), MockRpcClient (test client), create_mocked_rpc_context() (creates test RPC backend with connectivity mocks). Dependencies: Tower service framework, RPC framework, connectivity manager mocks, peer manager. Used by: RPC test suites requiring controlled service behavior, integration tests, protocol validation. Enables deterministic RPC testing with configurable responses and behavior tracking. |
| `mod.rs` | RPC test module with integration tests and test utilities. Exports: RPC test harnesses, integration tests, test services. Provides comprehensive testing infrastructure for RPC system including client/server integration tests, performance tests, and reliability tests. Used by: CI/CD for ensuring RPC system reliability and correctness. |
| `smoke.rs` | Comprehensive smoke tests for RPC functionality covering real-world usage scenarios. Tests request-response patterns, streaming responses, error handling, concurrent requests, response size limits, ping latency, timeouts, server shutdown handling, connection session limits, and stream interruption. Key test functions: request_response_errors_and_streaming() (main functionality), concurrent_requests() (parallel request handling), response_too_big() (message size limits), timeout() (deadline handling), max_global_sessions() (server capacity), max_per_client_sessions() (per-peer limits), stream_still_works_after_cancel() (resilience). Dependencies: GreetingService test implementation, Yamux multiplexing, canonical framing, node identity utilities. Used by: RPC integration validation, performance testing, edge case verification. Tests real networking scenarios with multiplexed connections and protocol-level interactions. |

###### comms/core/src/socks/

| File | Description |
|------|-------------|
| `client.rs` | SOCKS proxy client implementation for proxy connections. Exports: SocksClient struct, proxy negotiation, connection establishment. Implements SOCKS protocol client with authentication support, connection tunneling, and error handling. Provides low-level SOCKS proxy connectivity. Used by: SOCKS transport, proxy-based networking for establishing connections through SOCKS proxies. |
| `error.rs` | Error types for SOCKS proxy operations. Exports: SocksError enum, proxy-specific error handling. Defines errors for SOCKS negotiation failures, authentication issues, connection problems, and protocol violations. Implements error conversion from network errors. Dependencies: thiserror. Used by: SOCKS client for error handling during proxy operations. |
| `mod.rs` | SOCKS proxy client module for proxy-based networking. Exports: SOCKS client implementation, proxy authentication, connection handling. Provides SOCKS4/SOCKS5 client functionality for routing connections through proxy servers with authentication support. Used by: transport layer, Tor integration for proxy-based connectivity. |

###### comms/core/src/test_utils/

| File | Description |
|------|-------------|
| `mod.rs` | Test utilities module providing testing infrastructure and helpers. Exports: test factories, mock components, test node builders, transport helpers. Provides comprehensive testing utilities for unit tests, integration tests, and test automation. Includes peer factories, connection mocks, and test harnesses. Used by: test suites across the codebase for creating test environments and mock components. |
| `node_id.rs` | Utility function for generating random NodeId instances in tests. Provides random() function that creates NodeId from randomly generated cryptographic key pairs using OsRng for secure randomness. Dependencies: tari_crypto for key generation, OsRng for cryptographic randomness. Used by: Test suites requiring unique node identifiers, peer testing, network simulation, identity generation for test scenarios. Simple utility ensuring each test gets unique, cryptographically valid node identifiers without manual key pair management. |
| `node_identity.rs` | Test utilities for node identity creation and management. Exports: node identity builders, test identity creation, identity helpers. Provides utilities for creating test node identities with configurable parameters for testing scenarios. Includes identity generation and test identity management. Used by: test suites for creating test node identities and identity-related test scenarios. |
| `peer_manager.rs` | Test utilities for peer manager testing and mock peer management. Exports: mock peer manager, test peer operations, peer manager helpers. Provides mock implementations and utilities for testing peer manager functionality without database dependencies. Used by: test suites for testing components that depend on peer manager functionality. |
| `test_node.rs` | Test node implementation for integration testing and development. Exports: TestNode struct, test node builders, node coordination utilities. Provides complete test node implementation with networking, protocols, and services for integration testing scenarios. Enables end-to-end testing of comms functionality. Used by: integration tests for creating realistic test network environments. |
| `transport.rs` | Test transport utilities for mocking and testing network communication. Exports: test transport implementations, transport helpers, connection simulation. Provides mock transport implementations for testing network functionality without real network dependencies. Includes transport mocking and simulation capabilities. Used by: test suites for testing transport-dependent functionality. |

###### comms/core/src/test_utils/factories/

| File | Description |
|------|-------------|
| `macros.rs` | Utility macros for test object factory pattern implementation. Defines factory_setter! macro that generates builder-pattern setter methods for factory structs, supporting both optional and non-optional field types. Used by: All factory implementations in test_utils/factories/ module. Enables fluent API for test object construction with pattern: factory.with_field(value).build(). Supports Type and Option&lt;Type&gt; field patterns for flexible test object configuration. |
| `mod.rs` | Test factory module for creating test data and mock objects. Exports: factory functions, test data builders, mock object creation. Provides factories for creating peers, node identities, network addresses, and other test objects with realistic data. Reduces test setup complexity and ensures consistent test data. Used by: test suites for creating test fixtures and mock data. |
| `net_address.rs` | Test factories for network address generation in communications testing. Provides NetAddressFactory for single Multiaddr creation and NetAddressesFactory for multiple address generation. Key exports: create() (single address factory), create_many(n) (multiple address factory). Features configurable ports, OS port allocation, and MemoryTransport integration for in-memory testing. Dependencies: multiaddr library, MemoryTransport for port management, factory_setter! macro. Used by: Network communication tests requiring test addresses, peer setup, node identity creation. Generates memory transport addresses like '/memory/12345' for isolated testing environments. |
| `node_identity.rs` | Test factory for NodeIdentity creation in communications testing. Generates test node identities with configurable control service addresses, secret keys, and peer features. Key export: create() (NodeIdentityFactory). Features automatic secret key generation via OsRng, network address integration via net_address factory, and PeerFeatures configuration. Dependencies: tari_crypto for key generation, multiaddr for addresses, factory_setter! macro, NodeIdentity types. Used by: Communication tests requiring node identities, peer setup, RPC testing, integration tests. Creates complete node identities suitable for test network simulation and peer-to-peer communication testing. |
| `peer.rs` | Test factories for Peer object creation in communications testing. Provides PeerFactory for single peer creation and PeersFactory for bulk peer generation. Key exports: create() (single peer factory), create_many(n) (multiple peer factory). Features configurable node IDs, public keys, network addresses, peer flags, and peer features. Includes automatic key pair generation via OsRng and address integration with NetAddressesFactory. Dependencies: tari_crypto for cryptography, multiaddr for addresses, PeerAddressSource for address metadata, factory_setter! macro. Used by: Peer manager tests, network simulation, DHT testing, communication protocol validation. Creates realistic peer objects with proper cryptographic identities and network addresses for test networks. |
| `peer_manager.rs` | Test factory for PeerManager creation in communications testing. Generates PeerManager instances pre-populated with test peers for testing peer management functionality. Key export: create() (PeerManagerFactory). Features integration with PeersFactory for bulk peer creation, database configuration, and automatic peer population. Dependencies: PeerManager implementation, CommsDatabase for storage, PeersFactory for peer generation, factory_setter! macro. Used by: Peer management tests, communication tests requiring peer databases, integration tests needing populated peer managers. Creates fully configured PeerManager instances with test peers for network simulation and peer discovery testing. |

###### comms/core/src/test_utils/mocks/

| File | Description |
|------|-------------|
| `connection_manager.rs` | Mock implementation of ConnectionManager for testing peer connection scenarios. Provides ConnectionManagerMock with configurable behavior and ConnectionManagerMockState for test verification. Key exports: create_connection_manager_mock() (factory function), ConnectionManagerMock (handles dial requests), ConnectionManagerMockState (tracks calls, manages active connections, publishes events). Features call counting, request logging, active connection management, and event publication. Dependencies: ConnectionManager types, mpsc channels, broadcast for events. Used by: Connection manager tests, integration tests requiring controlled connection behavior, peer connectivity testing. Enables deterministic testing of connection establishment, dial failures, and connection lifecycle management. |
| `connectivity_manager.rs` | Comprehensive mock implementation of ConnectivityManager for testing network connectivity scenarios. Provides ConnectivityManagerMock with full request handling and ConnectivityManagerMockState for detailed test verification and control. Key exports: create_connectivity_mock() (factory), ConnectivityManagerMock (request processor), ConnectivityManagerMockState (test state management). Features call tracking, peer dialing history, active connection management, pending connection queuing, connectivity status control, peer banning, connection selection, and event publishing. Dependencies: Connectivity types, futures locks, tokio channels. Used by: Connectivity tests, network simulation, peer management testing, DHT testing. Provides complete control over connectivity behavior for deterministic testing of network scenarios, peer discovery, and connection management strategies. |
| `mod.rs` | Mock implementations module for testing infrastructure. Exports: mock connection manager, mock connectivity manager, mock peer connections. Provides mock implementations of core comms components for unit testing and integration testing. Enables isolated testing without real network dependencies. Used by: test suites for testing component interactions and behavior. |
| `peer_connection.rs` | Mock implementation of PeerConnection for testing peer-to-peer communication. Provides realistic peer connection mocks with multiplexing support via Yamux. Key exports: create_dummy_peer_connection() (simple mock), create_peer_connection_mock_pair() (paired connections), new_peer_connection_mock_pair() (with generated identities), PeerConnectionMock (handles substream operations), PeerConnectionMockState (tracks connection state). Features substream management, connection lifecycle, call counting, incoming/outgoing stream handling, and disconnect behavior. Dependencies: Yamux multiplexing, transport utilities, node identity generation, atomic ref counting. Used by: RPC tests, protocol tests, multiplexing tests, peer communication validation. Enables testing of substream protocols, connection management, and stream-based communication patterns without real network connections. |

###### comms/core/src/tor/

| File | Description |
|------|-------------|
| `mod.rs` | Tor integration module for anonymous networking and hidden services. Exports: Tor control client, hidden service controller, Tor transport integration. Provides comprehensive Tor support including hidden service creation, control port communication, and anonymous transport layer. Enables privacy-preserving peer-to-peer communication. Used by: transport layer, comms builder for Tor-based networking. |

###### comms/core/src/tor/control_client/

| File | Description |
|------|-------------|
| `client.rs` | Tor control client implementation for communicating with Tor daemon. Exports: TorControlClient struct, control protocol operations. Implements Tor control protocol client with command execution, response parsing, and event monitoring. Provides async interface to Tor control port for daemon management. Used by: hidden service controller for Tor daemon communication and control. |
| `error.rs` | Error types for Tor control client operations. Exports: TorControlError enum, Tor-specific error handling. Defines errors for Tor control protocol communication, command failures, authentication issues, and connection problems. Implements error conversion from Tor protocol errors. Dependencies: thiserror. Used by: Tor control client for error handling during Tor daemon communication. |
| `event.rs` | Tor control client event handling and monitoring system. Exports: Tor event types, event parsing, event subscription. Implements Tor daemon event monitoring with event parsing, subscription management, and event notification. Enables reactive monitoring of Tor daemon state changes. Used by: Tor control client for monitoring Tor daemon events and state changes. |
| `mod.rs` | Tor control client module for communication with Tor daemon. Exports: TorControlClient, control commands, event monitoring. Implements Tor control protocol for managing hidden services, monitoring events, and controlling Tor daemon behavior. Provides async interface to Tor control port. Used by: hidden service controller for Tor daemon management and configuration. |
| `monitor.rs` | Tor control client monitoring and event processing system. Exports: Tor monitor, event processing, daemon health monitoring. Provides continuous monitoring of Tor daemon state with event processing, health checking, and daemon lifecycle monitoring. Handles daemon disconnection and reconnection. Used by: Tor control client for maintaining daemon connectivity and health monitoring. |
| `parsers.rs` | Tor control protocol message parsers and response processing. Exports: response parsers, message parsing utilities, protocol parsing. Implements parsing for Tor control protocol responses including command responses, status messages, and event notifications. Handles protocol message structure and data extraction. Used by: Tor control client for parsing Tor daemon responses and messages. |
| `response.rs` | Tor control client response handling and data structures. Exports: response types, response processing, status handling. Defines response data structures for Tor control protocol with response parsing, status code handling, and response data extraction. Provides typed interface to Tor responses. Used by: Tor control client for handling Tor daemon command responses. |
| `test_server.rs` | Test server mock for Tor control port protocol testing. Provides TorControlPortTestServer that simulates Tor control port responses for testing Tor integration without real Tor daemon. Key exports: spawn() (creates server and socket), State (manages requests/responses), TorControlPortTestServer (mock server implementation). Features request capture, configurable canned responses, line-based protocol handling with LinesCodec. Includes comprehensive canned_responses module with realistic Tor control protocol responses for GETCONF, GETINFO, ADD_ONION, PROTOCOLINFO commands and error scenarios. Dependencies: MemorySocket for testing, tokio-util for framing, futures for stream handling. Used by: Tor control client tests, hidden service tests, Tor integration validation. Enables deterministic testing of Tor control protocol interactions without requiring actual Tor daemon. |
| `types.rs` | Type definitions and data structures for Tor control client. Exports: Tor control types, data structures, common definitions. Defines types used in Tor control protocol communication including keys, addresses, service descriptors, and protocol constants. Provides type safety for Tor operations. Used by: Tor control client components for type-safe Tor protocol operations. |

###### comms/core/src/tor/control_client/commands/

| File | Description |
|------|-------------|
| `add_onion.rs` | Tor ADD_ONION command implementation for creating hidden services. Exports: ADD_ONION command builder, onion service creation. Implements Tor control protocol ADD_ONION command for creating ephemeral hidden services with key management and service configuration. Handles onion address generation and service parameters. Used by: hidden service controller for creating Tor hidden services. |
| `del_onion.rs` | Tor DEL_ONION command implementation for removing hidden services. Exports: DEL_ONION command builder, onion service removal. Implements Tor control protocol DEL_ONION command for removing ephemeral hidden services and cleaning up service resources. Handles service shutdown and cleanup. Used by: hidden service controller for removing Tor hidden services. |
| `key_value.rs` | Tor control protocol commands for key-value operations. Implements KeyValueCommand for GETCONF, GETINFO, and SETEVENTS Tor control commands with response parsing. Key exports: get_conf() (query configuration), get_info() (retrieve keys), set_events() (configure event types), KeyValueCommand (command processor). Features command string generation, response parsing with key-value extraction, error handling for command failures, and proper handling of Tor control protocol responses. Dependencies: Tor control client types, response parsers, TorCommand trait. Used by: Tor integration, hidden service management, Tor configuration queries, event monitoring. Enables programmatic interaction with Tor daemon for configuration retrieval, information queries, and event subscription in Tari's Tor integration layer. |
| `mod.rs` | Tor control client commands module for Tor daemon operations. Exports: Tor control commands, command builders, command execution utilities. Implements various Tor control commands including ADD_ONION, DEL_ONION, PROTOCOLINFO, and other daemon control operations. Provides structured command interface. Used by: Tor control client for executing specific Tor daemon commands. |
| `protocol_info.rs` | Tor PROTOCOLINFO command implementation for protocol information discovery. Exports: PROTOCOLINFO command builder, protocol capabilities. Implements Tor control protocol PROTOCOLINFO command for discovering Tor daemon capabilities, authentication methods, and protocol versions. Enables capability negotiation. Used by: Tor control client for protocol capability discovery and authentication setup. |

###### comms/core/src/tor/hidden_service/

| File | Description |
|------|-------------|
| `builder.rs` | Hidden service builder for configuring and creating Tor onion services. Exports: HiddenServiceBuilder struct, service configuration. Provides builder pattern for configuring hidden service parameters including ports, keys, authentication, and service options. Enables flexible hidden service creation. Used by: hidden service controller for configuring and creating Tor hidden services with custom parameters. |
| `controller.rs` | Hidden service controller for managing Tor onion service lifecycle. Exports: HiddenServiceController struct, service management operations. Implements hidden service creation, management, and cleanup with Tor daemon integration. Handles service registration, address management, and service lifecycle. Core component for Tor hidden service operations. Used by: comms builder for creating and managing Tor hidden services. |
| `mod.rs` | Tor hidden service module for creating and managing onion services. Exports: HiddenServiceController, hidden service builder, service management. Provides hidden service creation, configuration, and lifecycle management for anonymous peer connectivity. Handles onion address generation and service registration. Used by: comms builder for creating Tor hidden services and anonymous networking capabilities. |
| `proxy_opts.rs` | Configuration for Tor proxy bypass options in hidden service operations. Defines TorProxyOpts for controlling when to bypass Tor SOCKS proxy and use direct TCP connections. Key exports: TorProxyOpts (configuration struct), to_bypass_predicate() (creates address filter). Features bypass_addresses list for specific address exclusions, bypass_for_tcpip flag for automatic TCP/IP bypass, predicate creation for transport layer decisions. Includes address type detection with is_tcp_address() supporting IPv4/IPv6/DNS addresses. Dependencies: multiaddr for address handling, transport predicates. Used by: Tor transport configuration, connection routing decisions, hidden service connectivity. Enables selective bypass of Tor proxy for performance or connectivity requirements while maintaining privacy for onion addresses. |

###### comms/core/src/transports/

| File | Description |
|------|-------------|
| `hidden_service_transport.rs` | Tor hidden service transport implementation for anonymous peer connections. Exports: HiddenServiceTransport struct, onion service connectivity. Provides transport layer for connecting to and from Tor hidden services with anonymity preservation and onion routing. Implements Transport trait for Tor integration. Used by: Tor-enabled networking for anonymous peer-to-peer communication. |
| `memory.rs` | In-memory transport implementation for testing and local communication. Exports: MemoryTransport struct, in-memory connection handling. Provides memory-based transport for unit testing, benchmarking, and local node communication without network overhead. Implements Transport trait for compatibility. Used by: test suites, development environments for simulating network communication in memory. |
| `mod.rs` | Transport layer module for network connectivity and protocol support. Exports: Transport trait, TCP transport, Tor transport, DNS resolution, SOCKS proxy support. Provides abstraction layer for different network transports with support for TCP, Tor hidden services, SOCKS proxies, and various addressing schemes. Core network connectivity infrastructure. |
| `predicate.rs` | Transport predicate system for conditional transport selection. Exports: transport predicates, address filtering, transport selection logic. Provides conditional logic for selecting appropriate transports based on address types, network conditions, and connectivity requirements. Enables intelligent transport selection. Used by: transport layer for dynamic transport selection based on address characteristics. |
| `socks.rs` | SOCKS proxy transport for routing connections through proxy servers. Exports: SocksTransport struct, SOCKS connection handling. Provides SOCKS4/SOCKS5 proxy support for peer connections with authentication and proxy negotiation. Enables connections through proxy infrastructure. Dependencies: tokio SOCKS client. Used by: Tor transport, proxy-based networking for routing connections through SOCKS proxies. |
| `tcp.rs` | TCP transport implementation for direct peer connections. Exports: TcpTransport struct, TCP connection handling. Provides standard TCP transport with IPv4/IPv6 support, connection establishment, and error handling. Implements base network connectivity for peer-to-peer communication. Dependencies: tokio TCP utilities. Used by: comms builder for direct TCP connections between peers. |
| `tcp_with_tor.rs` | Combined TCP and Tor transport for hybrid connectivity. Exports: TcpWithTorTransport struct. Provides transport that supports both direct TCP connections and Tor hidden service connections with automatic selection based on address type. Enables flexible connectivity options. Used by: comms builder for supporting both clearnet and Tor connections simultaneously. |

###### comms/core/src/transports/dns/

| File | Description |
|------|-------------|
| `common.rs` | Common utilities for DNS address handling and multiaddr conversion. Provides helper functions for DNS address type detection and protocol extraction from multiaddr formats. Key exports: is_dns4_addr() (DNS address detection), convert_tcpip_multiaddr_to_socketaddr() (multiaddr to SocketAddr conversion), extract_protocols() (protocol parsing). Features support for DNS4/DNS6/IP4/IP6 protocols with TCP, address validation, and error handling for malformed addresses. Dependencies: multiaddr for address types, DnsResolverError for error handling. Used by: DNS resolvers, transport layer address conversion, network address validation. Enables conversion between Tari's multiaddr format and standard Rust networking types for DNS resolution and TCP connections. |
| `error.rs` | Error types for DNS resolution operations in transport layer. Defines DnsResolverError enum covering all failure modes in DNS resolution including address validation, name resolution, proxy connections, and SOCKS errors. Key error variants: EmptyAddress, InvalidAddress, UnsupportedAddress, ExpectedTcpIpAddress, ProxyConnectFailed, SocksError, NameResolutionFailed, DnsAddressNotFound, BlockingJoinError. Features detailed error messages with address context, chained error sources, and integration with SOCKS error types. Dependencies: thiserror for error derivation, tokio JoinError, SocksError types. Used by: DNS resolvers, transport implementations, network error handling. Provides comprehensive error reporting for DNS-related failures in Tari's networking stack. |
| `mod.rs` | DNS resolution module for network address resolution. Exports: DNS resolver, address resolution utilities, DNS-based discovery. Provides DNS resolution services for converting hostnames to IP addresses with support for various DNS backends and resolution strategies. Used by: transport layer for address resolution and hostname-based connectivity. |
| `system.rs` | System DNS resolver implementation using OS-level DNS configuration. Provides SystemDnsResolver that performs DNS lookups using standard system DNS settings and ToSocketAddrs trait. Key exports: SystemDnsResolver (implements DnsResolver trait), dns_lookup() (async DNS resolution function). Features support for DNS/DNS4/IP4/IP6 protocols with TCP, non-blocking DNS resolution via spawn_blocking, comprehensive error handling for lookup failures. Dependencies: tokio for async operations, multiaddr for address types, ToSocketAddrs for resolution. Used by: DNS transport layer, network address resolution, system DNS integration. Enables Tari to resolve DNS addresses using the host system's DNS configuration, supporting both IPv4 and IPv6 resolution with proper async handling. |
| `tor.rs` | Tor-based DNS resolver implementation using SOCKS5 proxy for secure DNS resolution. Provides TorDnsResolver that performs DNS lookups through Tor network via SOCKS5 connection, supporting anonymous DNS resolution. Key exports: TorDnsResolver (implements DnsResolver trait), connect() (establishes SOCKS5 client connection). Features DNS4 address detection, Tor SOCKS5 proxy connection, tor_resolve() for DNS queries through Tor, authentication support, and fallback to direct resolution for non-DNS addresses. Dependencies: Socks5Client for Tor communication, SocksTransport for proxy connection, SocksConfig for authentication. Used by: Tor integration, anonymous DNS resolution, privacy-preserving network communication. Enables DNS resolution through Tor network while maintaining anonymity and preventing DNS leaks in Tari's privacy-focused networking stack. |

###### comms/core/src/utils/

| File | Description |
|------|-------------|
| `atomic_ref_counter.rs` | Atomic reference counter utility for thread-safe counting operations. Exports: AtomicRefCounter struct, atomic counting operations. Provides thread-safe reference counting with atomic operations for concurrent access. Used for resource tracking and lifecycle management in multi-threaded environments. Used by: connection management, resource tracking for concurrent reference counting. |
| `cidr.rs` | CIDR (Classless Inter-Domain Routing) utilities for network address operations. Exports: CIDR parsing, subnet operations, IP range utilities. Provides CIDR notation handling for network address management, subnet calculations, and IP range operations. Used by: network address validation, address filtering for network topology and address range operations. |
| `datetime.rs` | Date and time utility functions for timestamp handling and time operations. Exports: timestamp utilities, time conversion functions, time formatting. Provides consistent datetime handling across the comms system with timezone handling and time calculations. Used throughout: comms system for timestamp management and time-based operations. |
| `mod.rs` | Utility module providing helper functions and common utilities. Exports: atomic reference counting, CIDR utilities, datetime helpers, multiaddr utilities, MPSC channel helpers. Provides shared utility functions for common operations across the communications system. Reduces code duplication and provides consistent utility implementations. Used throughout: comms system for common utility operations. |
| `mpsc.rs` | MPSC (Multi-Producer Single-Consumer) channel utilities for async communication. Exports: channel helpers, bounded/unbounded channel utilities, channel monitoring. Provides enhanced MPSC channel functionality with monitoring, backpressure handling, and channel health tracking. Used throughout: comms system for actor communication and async message passing. |
| `multiaddr.rs` | Multiaddress utility functions for network address handling and manipulation. Exports: multiaddr parsing, address validation, address conversion utilities. Provides helper functions for working with multiaddress format including parsing, validation, and conversion operations. Used by: network address management, address validation for multiaddress operations across the system. |

##### comms/core/tests/

| File | Description |
|------|-------------|
| `comms_integration_tests.rs` | Root module file for communications integration tests. Simple module declaration importing tests from tests/ subdirectory. Used by: Cargo test infrastructure to organize integration tests. Enables running comprehensive communication integration tests covering RPC functionality, stress testing, and real-world communication scenarios. Part of the integration test suite validating end-to-end communication behavior in Tari's networking stack. |

###### comms/core/tests/tests/

| File | Description |
|------|-------------|
| `greeting_service.rs` | Advanced RPC service implementation for integration testing with macro-generated code. Defines GreetingRpc trait using tari_rpc macro for automatic server/client generation, testing complex RPC patterns including large message handling, streaming, and performance scenarios. Key exports: GreetingRpc trait (5 methods), GreetingService implementation, protobuf message definitions (SayHelloRequest/Response, StreamLargeItemsRequest). Features request-response patterns, server streaming with large items, configurable delays, message size testing, slow response simulation, and comprehensive logging for performance analysis. Dependencies: tari_comms_rpc_macros for code generation, prost for protobuf. Used by: Integration tests, RPC stress testing, performance validation. Provides realistic RPC service implementation for testing production-like scenarios in Tari communications. |
| `helpers.rs` | Helper utilities for communications integration tests. Provides functions for creating test infrastructure including peer storage and comms nodes for integration testing. Key exports: create_peer_storage() (creates temporary SQLite peer database), create_comms() (builds UnspawnedCommsNode with test configuration). Features temporary database creation with migrations, random node identity generation, localhost binding with OS-assigned ports, test address allowance, and shutdown signal integration. Dependencies: SQLite for peer storage, OsRng for cryptography, CommsBuilder for node creation. Used by: Integration tests requiring realistic comms infrastructure, multi-node test scenarios, database-backed peer management testing. Simplifies test setup by providing pre-configured communication components for integration test scenarios. |
| `mod.rs` | Test module organization and utilities for communications integration tests. Declares test modules (greeting_service, helpers, rpc, rpc_stress, substream_stress) and provides create_test_peer() utility function. Key exports: create_test_peer() (generates test peer with random identity and localhost address). Features random cryptographic key generation, standard test peer configuration with Communication Node features, and localhost address assignment. Dependencies: multiaddr for addresses, CommsPublicKey for cryptography, Peer types. Used by: Integration test infrastructure, peer creation for multi-node tests, test utilities requiring valid peer objects. Organizes integration tests by functionality and provides common utilities for peer-based testing scenarios. |
| `rpc.rs` | Integration test for RPC functionality in the Tari communications core. Tests RPC server/client interactions including greeting service, streaming responses, and shutdown behavior. Exports: test functions for RPC capabilities. Dependencies: tari_comms RPC modules, tari_shutdown, test utilities. Used by: integration test suite to verify RPC message handling and connection management. |
| `rpc_stress.rs` | Stress test for RPC performance and reliability under load. Tests high-throughput message handling, concurrent connections, and resource usage patterns. Dependencies: tari_comms RPC framework, test utilities. Used by: performance testing to validate RPC system stability under stress conditions. |
| `substream_stress.rs` | Stress test for substream handling within the communications framework. Tests concurrent substream creation, message multiplexing, and resource cleanup under load. Dependencies: tari_comms substream modules. Used by: performance validation to ensure stable substream management at scale. |

#### comms/dht/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo package configuration for Tari DHT (Distributed Hash Table) communications module. Defines dependencies for DHT functionality including Tari core libraries (tari_comms, tari_crypto, tari_utilities), database support (diesel with SQLite), cryptography (chacha20, blake2), networking (tower), and async runtime (tokio). Key dependencies: tari_comms with RPC features, diesel for peer/message storage, cryptographic primitives for message encryption/signing, tower for service abstractions, prost for protobuf serialization. Dev dependencies include testing utilities, petgraph for network analysis examples, and clap for CLI examples. Build dependencies use tari_common for protobuf compilation. Features: test-mocks for testing support. Used by: DHT service implementations, peer discovery, message routing, network topology management. |
| `README.md` | README documentation for Tari communications DHT module. Brief description identifying this as the Tari network messaging library with reference to CommsBuilder for usage information. Used by: Developers implementing DHT functionality, documentation reference for Tari networking components. Points to CommsBuilder as the main entry point for understanding DHT integration and configuration. |
| `build.rs` | Build script for DHT module protobuf compilation. Uses tari_common::build::ProtobufCompiler to compile protocol buffer definitions from src/proto directory, enabling protobuf message generation for DHT protocols. Configures rerun-if-changed directives for proper incremental builds. Dependencies: tari_common build utilities. Used by: Cargo build process for generating protobuf message types. Compiles DHT protocol definitions into Rust message structures for network communication, message serialization, and peer discovery protocols. |
| `diesel.toml` | Diesel ORM configuration for DHT database schema management. Configures print_schema to generate schema.rs file containing database table definitions for DHT storage. Used by: diesel CLI for database migrations and schema generation. Defines schema output location for DHT database structures including peer storage, message caching, deduplication cache, and DHT metadata tables. Part of DHT persistence layer for peer information and message routing data. |

##### comms/dht/examples/

| File | Description |
|------|-------------|
| `memorynet.rs` | Example application demonstrating basic DHT functionality using in-memory networking. Shows DHT node creation, peer discovery, and message routing in a simulated environment. Dependencies: DHT core, memory transport. Used by: developers to understand DHT usage patterns and test DHT functionality locally. |
| `memorynet_graph_network_join_multiple_seeds.rs` | Example demonstrating DHT network bootstrapping with multiple seed nodes and graph visualization. Shows how nodes join the network through multiple seed peers and tracks topology changes. Dependencies: memory network simulation, graph utilities. Used by: research and debugging to analyze DHT bootstrap patterns. |
| `memorynet_graph_network_track_join.rs` | Example tracking and visualizing DHT network join operations. Monitors how nodes connect to the network and updates the network graph in real-time. Dependencies: memory network, graph tracking utilities. Used by: analysis of DHT join behavior and network topology evolution. |
| `memorynet_graph_network_track_propagation.rs` | Example tracking DHT message propagation through the network with graph visualization. Shows how messages spread between nodes and visualizes propagation paths. Dependencies: memory network, propagation tracking. Used by: analyzing DHT message routing efficiency and identifying propagation bottlenecks. |
| `propagation_stress.rs` | Stress test for DHT message propagation under high load. Tests propagation performance with many concurrent messages and network congestion scenarios. Dependencies: DHT propagation, stress testing utilities. Used by: performance validation to ensure reliable message propagation at scale. |

###### comms/dht/examples/graphing_utilities/

| File | Description |
|------|-------------|
| `mod.rs` | Module declaration for DHT network graphing utilities. Exports utility functions for visualizing DHT network topology and message propagation. Dependencies: graph rendering modules. Used by: DHT examples to create visual representations of network structure and message flow patterns. |
| `render_graph_sequence.py` | Python script for rendering DHT network graph sequences. Generates visualizations showing how DHT network topology evolves over time. Dependencies: Python graphing libraries (matplotlib, networkx). Used by: DHT analysis and debugging to visualize network changes and peer connections. |
| `render_graph_sequence_propagation.py` | Python script for visualizing DHT message propagation sequences. Creates animated visualizations showing how messages spread through the DHT network. Dependencies: Python visualization libraries. Used by: DHT research and debugging to understand message propagation patterns and network efficiency. |
| `utilities.rs` | Utility functions for DHT graph generation and analysis. Exports functions for collecting network topology data, formatting graph data structures, and interfacing with visualization tools. Dependencies: DHT core modules, data serialization. Used by: graphing examples to extract and process DHT network state for visualization. |

###### comms/dht/examples/memory_net/

| File | Description |
|------|-------------|
| `drain_burst.rs` | Example demonstrating burst message draining in memory-based DHT networks. Shows how to handle sudden spikes in message volume and network congestion. Dependencies: memory network simulation, DHT core. Used by: testing scenarios to validate DHT behavior under high-load burst conditions. |
| `mod.rs` | Module for memory-based DHT network simulation utilities. Exports functions and types for creating in-memory DHT networks for testing and development. Dependencies: DHT core modules. Used by: examples and tests to simulate DHT networks without real network I/O. |
| `utilities.rs` | Helper utilities for memory network DHT simulations. Exports functions for network setup, peer management, and simulation control. Dependencies: memory transport, DHT configuration. Used by: memory network examples to create and manage simulated DHT environments. |

###### comms/dht/examples/propagation/

| File | Description |
|------|-------------|
| `mod.rs` | Module for DHT message propagation examples and utilities. Exports types and functions for testing and demonstrating message propagation strategies. Dependencies: DHT propagation modules. Used by: propagation examples to showcase different message dissemination patterns. |
| `node.rs` | DHT node implementation for propagation examples. Exports node wrapper with propagation-specific functionality and metrics collection. Dependencies: DHT core, propagation utilities. Used by: propagation examples to create nodes with enhanced propagation tracking capabilities. |
| `prompt.rs` | Interactive prompt utilities for propagation examples. Exports command-line interface functions for controlling propagation tests and viewing results. Dependencies: CLI libraries, propagation control. Used by: interactive propagation examples to provide user control over test scenarios. |

##### comms/dht/migrations/

| File | Description |
|------|-------------|
| `.gitkeep` | [GENERATED] Git keep file to preserve empty migrations directory structure. Ensures the migrations folder is tracked in version control even when empty. Dependencies: none. Used by: Git to maintain directory structure for database migration files. |

###### comms/dht/migrations/2020-04-01-095825_initial/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback script for initial DHT schema. Removes stored_messages and dht_settings tables and their indexes. Dependencies: SQLite/SQL database. Used by: migration system to rollback the initial DHT database schema when downgrading. |
| `up.sql` | Database migration script creating initial DHT schema. Creates stored_messages table for message storage with indexes for performance, and dht_settings table for metadata. Includes proper indexes for destination lookups, timestamps, and priority. Dependencies: SQLite/SQL database. Used by: migration system to initialize DHT database schema. |

###### comms/dht/migrations/2020-04-07-161148_remove_origin_signature/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback script to restore origin_signature column. Reverses removal of origin signature field from stored messages schema. Dependencies: previous migration state. Used by: migration system to rollback origin signature removal when downgrading database. |
| `up.sql` | Database migration script removing origin_signature column from stored_messages table. Part of schema evolution to simplify message storage structure. Dependencies: initial schema migration. Used by: migration system to remove deprecated origin signature tracking from DHT storage. |

###### comms/dht/migrations/2020-04-16-165626_clear_stored_messages/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback script for stored messages clearing operation. Reverses any data cleanup performed by the corresponding up migration. Dependencies: stored messages schema. Used by: migration system to restore previous state when rolling back message clearing migration. |
| `up.sql` | Database migration script to clear stored messages data. Removes old or invalid stored messages from the DHT database as part of cleanup or schema updates. Dependencies: stored_messages table. Used by: migration system to clean up stored message data during version upgrades. |

###### comms/dht/migrations/2020-04-20-082924_rename_settings_to_metadata/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback script to revert dht_settings table rename. Changes dht_metadata table back to dht_settings naming. Dependencies: metadata table migration. Used by: migration system to restore original table naming when rolling back metadata rename. |
| `up.sql` | Database migration script renaming dht_settings table to dht_metadata. Improves naming clarity for metadata storage functionality. Dependencies: existing dht_settings table. Used by: migration system to update table naming convention from settings to metadata terminology. |

###### comms/dht/migrations/2020-05-14-103121_add_body_hash/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback script to remove body_hash column. Reverses addition of message body hash tracking from stored messages. Dependencies: body hash migration. Used by: migration system to remove body hash functionality when downgrading schema. |
| `up.sql` | Database migration script adding body_hash column to stored_messages table. Enables message deduplication and integrity verification by storing message body hashes. Dependencies: stored_messages table. Used by: migration system to add message body hash tracking for deduplication features. |

###### comms/dht/migrations/2021-07-23-162902_add_dedup_cache/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback script to remove deduplication cache tables. Reverses creation of message dedup cache schema and associated indexes. Dependencies: dedup cache migration. Used by: migration system to remove dedup cache functionality when rolling back to older schema. |
| `up.sql` | Database migration script creating deduplication cache tables. Adds message_dedup_cache table with indexes for efficient duplicate message detection and cleanup. Dependencies: existing DHT schema. Used by: migration system to add message deduplication caching infrastructure for improved performance. |

###### comms/dht/migrations/2025-04-09-120000_remove_saf/

| File | Description |
|------|-------------|
| `down.sql` | Database migration rollback script to restore store-and-forward (SAF) functionality. Reverses removal of SAF-related tables and indexes. Dependencies: SAF removal migration. Used by: migration system to restore store-and-forward message storage when rolling back deprecation. |
| `up.sql` | Database migration script removing store-and-forward (SAF) functionality. Drops SAF-related tables and cleans up deprecated message storage features. Dependencies: existing SAF schema. Used by: migration system to remove deprecated store-and-forward features from DHT database. |

##### comms/dht/src/

| File | Description |
|------|-------------|
| `actor.rs` | Core DHT actor implementation managing DHT operations and request handling. Exports DhtActor, DhtRequester for async DHT operations including join messages, peer selection, metadata management, and message deduplication. Dependencies: tari_comms, peer manager, connectivity, outbound messaging. Used by: DHT service to handle network operations, peer discovery, and message routing in distributed hash table network. |
| `broadcast_strategy.rs` | DHT message broadcast strategy definitions and implementations. Exports BroadcastStrategy enum with variants for different peer selection approaches: direct routing, closest nodes, flooding, propagation, and random selection. Dependencies: peer management, node identification. Used by: DHT message routing to determine which peers should receive messages based on network topology and routing requirements. |
| `builder.rs` | Builder pattern implementation for configuring and constructing DHT instances. Exports DhtBuilder with methods for setting configuration options, network type (mainnet/testnet/local), protocol version, and database settings. Dependencies: DHT configuration, database connections. Used by: applications to create customized DHT instances with specific configuration parameters for different network environments. |
| `config.rs` | DHT configuration structures and default values. Exports DhtConfig with settings for network parameters, connectivity timeouts, message handling, peer validation, and ban policies. Includes network-specific presets for mainnet, testnet, and local testing. Dependencies: serde for serialization, connectivity configuration. Used by: DHT initialization to configure network behavior, peer management policies, and operational parameters. |
| `crypt.rs` | DHT message encryption and decryption utilities. Exports functions for secure message handling, key derivation, and cryptographic operations for DHT communications. Dependencies: cryptographic libraries, key management. Used by: DHT message processing to encrypt/decrypt messages, ensure confidentiality, and maintain secure peer-to-peer communication. |
| `dht.rs` | Main DHT service implementation and middleware stack builder. Exports Dht struct managing actor lifecycle, service coordination, and message pipeline construction for inbound/outbound processing. Dependencies: DHT components (actor, discovery, connectivity, outbound). Used by: applications to initialize and operate the complete DHT system with all networking, routing, and message processing capabilities. |
| `domain_message.rs` | DHT domain message types and handling for application-layer messages. Exports types and utilities for processing non-DHT protocol messages that use the DHT for routing. Dependencies: message serialization, DHT envelopes. Used by: applications to send domain-specific messages through the DHT network while maintaining proper routing and delivery semantics. |
| `envelope.rs` | DHT message envelope and header structures for network protocol. Exports DhtMessageHeader, NodeDestination, DhtMessageFlags, and related types for message wrapping and addressing. Dependencies: protobuf definitions, cryptographic types, message tags. Used by: DHT message processing to handle message headers, routing information, encryption flags, and destination addressing throughout the protocol stack. |
| `error.rs` | DHT error types and error handling infrastructure. Exports comprehensive error enums covering network failures, protocol violations, database errors, and configuration issues. Dependencies: error handling traits, specific error types. Used by: DHT components to provide structured error reporting and enable proper error handling throughout the DHT system. |
| `event.rs` | DHT event system for network state notifications and monitoring. Exports event types and publisher/subscriber mechanisms for DHT state changes, peer events, and network status updates. Dependencies: async broadcasting, event types. Used by: DHT components and applications to monitor network events, track peer lifecycle, and respond to network state changes. |
| `lib.rs` | Distributed Hash Table (DHT) implementation for Tari peer-to-peer network discovery and routing. Provides middleware layers for inbound/outbound message processing, peer discovery protocols, message encryption/decryption, deduplication, network discovery state machine, and broadcast strategies. Includes DhtBuilder for setup, actor-based message handling (DhtRequester), connectivity monitoring, storage abstraction, and RPC capabilities. Features domain-separated hashing for security, message signatures, peer validation, and comprehensive metrics collection for network performance monitoring. |
| `logging_middleware.rs` | Logging middleware for DHT message pipeline debugging and monitoring. Exports MessageLoggingLayer providing structured logging for message flow, processing stages, and debugging information. Dependencies: logging infrastructure, message types. Used by: DHT pipeline to provide visibility into message processing, debug network issues, and monitor system behavior. |
| `macros.rs` | Utility macros for DHT development and testing. Exports convenience macros for common DHT operations, test utilities, and code generation patterns. Dependencies: Rust macro system. Used by: DHT codebase to reduce boilerplate, provide consistent patterns, and simplify common operations across the DHT implementation. |
| `message_signature.rs` | DHT message signature verification and generation utilities. Exports functions for creating and validating message signatures to ensure message integrity and authenticity. Dependencies: cryptographic signatures, message hashing. Used by: DHT message processing to verify message authenticity, prevent tampering, and ensure secure message propagation. |
| `peer_validator.rs` | DHT peer validation logic for ensuring peer authenticity and trustworthiness. Exports validation functions for peer identity verification, certificate checking, and trust establishment. Dependencies: cryptographic verification, peer identity. Used by: DHT system to validate peer identities, prevent malicious peers, and maintain network security. |
| `schema.rs` | Database schema definitions and migrations for DHT persistence layer. Exports schema constants, table definitions, and migration utilities for DHT database management. Dependencies: database migration framework. Used by: DHT storage layer to define database structure, manage schema evolution, and ensure consistent data storage format. |
| `version.rs` | DHT protocol version definitions and compatibility management. Exports DhtProtocolVersion enum and version handling utilities for maintaining protocol compatibility across network upgrades. Dependencies: version serialization. Used by: DHT protocol stack to manage protocol versions, ensure compatibility, and coordinate protocol upgrades across the network. |

###### comms/dht/src/connectivity/

| File | Description |
|------|-------------|
| `metrics.rs` | DHT connectivity metrics collection and monitoring. Exports MetricsCollector and related types for tracking connection statistics, message rates, and network health indicators. Dependencies: tokio for async operations, metrics infrastructure. Used by: DHT connectivity service to monitor network performance, detect anomalies, and inform peer management decisions. |
| `mod.rs` | DHT connectivity module coordinating network connections and peer management. Exports DhtConnectivity service managing peer pools, connection maintenance, and network health monitoring. Dependencies: connectivity metrics, peer management, DHT configuration. Used by: DHT service to maintain optimal network connectivity, manage peer relationships, and ensure network resilience. |
| `test.rs` | Unit tests for DHT connectivity functionality. Tests peer pool management, connection strategies, metrics collection, and network resilience scenarios. Dependencies: test utilities, mock connectivity services. Used by: test suite to validate connectivity service behavior, peer selection algorithms, and network maintenance operations. |

###### comms/dht/src/dedup/

| File | Description |
|------|-------------|
| `dedup_cache.rs` | DHT message deduplication cache implementation. Exports DedupCacheDatabase for tracking and preventing duplicate message processing, with SQLite backend for persistence. Dependencies: database connections, message hashing. Used by: DHT message pipeline to detect and filter duplicate messages, improving network efficiency and reducing redundant processing. |
| `mod.rs` | DHT message deduplication module. Exports deduplication cache types and middleware for preventing duplicate message processing. Dependencies: dedup cache implementation, DHT configuration. Used by: DHT message pipeline to coordinate duplicate detection across the message processing stack. |

###### comms/dht/src/discovery/

| File | Description |
|------|-------------|
| `error.rs` | DHT peer discovery error types and error handling. Exports DhtDiscoveryError enum covering discovery timeouts, network failures, and peer validation errors. Dependencies: error handling traits, DHT types. Used by: DHT discovery service to provide structured error reporting for peer discovery operations and network bootstrap failures. |
| `mod.rs` | DHT peer discovery module coordinating network bootstrap and peer finding. Exports DhtDiscoveryService and DhtDiscoveryRequester for async peer discovery operations. Dependencies: discovery service implementation, error types. Used by: DHT system to discover new peers, bootstrap network connections, and maintain peer connectivity. |
| `requester.rs` | DHT discovery request handler and client interface. Exports DhtDiscoveryRequester for making peer discovery requests with timeout handling and request management. Dependencies: async messaging, discovery service. Used by: DHT components to initiate peer discovery operations, request peer information, and coordinate network exploration. |
| `service.rs` | DHT peer discovery service implementation. Exports DhtDiscoveryService managing peer discovery protocols, network exploration, and peer information gathering. Dependencies: DHT networking, peer management, outbound messaging. Used by: DHT system to execute peer discovery algorithms, handle discovery requests, and maintain network topology awareness. |

###### comms/dht/src/filter/

| File | Description |
|------|-------------|
| `future.rs` | Future-based filtering utilities for DHT message processing pipeline. Exports async filter implementations that can be composed into message processing chains. Dependencies: futures, async traits. Used by: DHT message pipeline to implement async filtering logic for message validation, routing decisions, and content inspection. |
| `layer.rs` | Tower layer implementation for DHT message filtering middleware. Exports FilterLayer for integrating message filters into the DHT processing pipeline using the tower service framework. Dependencies: tower framework, filter predicates. Used by: DHT middleware stack to apply filtering logic at various stages of message processing. |
| `mod.rs` | DHT message filtering module coordinating message validation and routing decisions. Exports filter layer and predicate types for message pipeline integration. Dependencies: filter implementations, tower middleware. Used by: DHT message processing to apply filtering rules, validate messages, and control message flow through the system. |
| `predicate.rs` | Predicate traits and implementations for DHT message filtering. Exports Predicate trait and common filter functions for message validation, content inspection, and routing logic. Dependencies: message types, validation logic. Used by: DHT filters to implement filtering rules, message validation criteria, and conditional message processing. |

###### comms/dht/src/inbound/

| File | Description |
|------|-------------|
| `decryption.rs` | DHT inbound message decryption middleware layer. Exports DecryptionLayer for decrypting incoming DHT messages using appropriate cryptographic keys. Dependencies: cryptographic functions, DHT envelope processing. Used by: DHT inbound pipeline to decrypt encrypted messages, verify message integrity, and prepare messages for further processing. |
| `deserialize.rs` | DHT inbound message deserialization middleware layer. Exports DeserializeLayer for converting raw message bytes into structured DHT message types. Dependencies: message serialization, DHT types. Used by: DHT inbound pipeline to deserialize incoming messages, validate message format, and prepare structured data for processing. |
| `error.rs` | Error types specific to DHT inbound message processing. Exports error enums covering decryption failures, deserialization errors, and inbound pipeline issues. Dependencies: core error types, processing errors. Used by: DHT inbound pipeline to report specific errors in message processing, decryption, and validation stages. |
| `forward.rs` | DHT message forwarding logic for inbound message routing. Exports ForwardLayer implementing message forwarding decisions and routing logic for the DHT network. Dependencies: routing algorithms, outbound messaging. Used by: DHT inbound pipeline to forward messages to appropriate peers, implement routing protocols, and maintain network connectivity. |
| `message.rs` | DHT inbound message types and structures for the processing pipeline. Exports DhtInboundMessage and DecryptedDhtMessage types representing messages at different stages of inbound processing. Dependencies: DHT envelopes, message headers. Used by: DHT inbound pipeline to pass messages between processing stages, maintain message state, and coordinate pipeline operations. |
| `metrics.rs` | Metrics collection for DHT inbound message processing. Exports MetricsLayer and metrics collection infrastructure for monitoring inbound message throughput, processing times, and error rates. Dependencies: metrics infrastructure, async operations. Used by: DHT inbound pipeline to collect performance metrics, monitor system health, and identify processing bottlenecks. |
| `mod.rs` | DHT inbound message processing module coordinating the complete inbound pipeline. Exports all inbound processing layers including decryption, deserialization, forwarding, and metrics collection. Dependencies: all inbound components, tower middleware. Used by: DHT service to construct the inbound message processing stack and handle incoming DHT messages. |

###### comms/dht/src/inbound/dht_handler/

| File | Description |
|------|-------------|
| `layer.rs` | Tower layer for DHT protocol message handling in the inbound pipeline. Exports DhtHandlerLayer integrating DHT protocol handlers into the message processing stack. Dependencies: tower framework, DHT handlers. Used by: DHT inbound middleware to apply DHT-specific message handling logic including join processing, discovery responses, and protocol validation. |
| `middleware.rs` | DHT protocol message handling middleware for processing DHT-specific messages. Exports middleware components for handling join messages, discovery requests, and DHT protocol operations. Dependencies: DHT protocol handlers, message types. Used by: DHT handler layer to process DHT protocol messages, coordinate peer interactions, and maintain network state. |
| `mod.rs` | DHT protocol handler module coordinating inbound DHT message processing. Exports DhtHandlerLayer and related components for processing DHT protocol messages in the inbound pipeline. Dependencies: handler implementations, middleware components. Used by: DHT inbound processing to handle join requests, discovery messages, and other DHT protocol operations. |
| `task.rs` | Async task implementations for DHT protocol message processing. Exports task types and execution logic for handling DHT protocol operations in the background. Dependencies: async runtime, DHT handlers. Used by: DHT handler to execute long-running protocol operations, coordinate async message processing, and manage protocol state. |

###### comms/dht/src/network_discovery/

| File | Description |
|------|-------------|
| `config.rs` | Configuration structures for DHT network discovery service. Exports NetworkDiscoveryConfig with settings for peer probing, sync delays, and discovery behavior. Dependencies: configuration serialization. Used by: network discovery service to configure peer discovery parameters, timing settings, and network exploration behavior. |
| `discovering.rs` | Network discovery state machine discovering state implementation. Exports state handling for active peer discovery phase, managing discovery requests and responses. Dependencies: state machine framework, discovery logic. Used by: network discovery service to coordinate active peer discovery operations and network exploration phases. |
| `error.rs` | Error types for DHT network discovery operations. Exports NetworkDiscoveryError enum covering discovery timeouts, state machine errors, and network connectivity issues. Dependencies: error handling infrastructure. Used by: network discovery service to report discovery failures, state transition errors, and network bootstrap problems. |
| `initializing.rs` | Network discovery state machine initialization state implementation. Exports state handling for discovery service startup, initial configuration, and transition to discovery phase. Dependencies: state machine, initialization logic. Used by: network discovery service to manage startup sequence, configure discovery parameters, and begin network exploration. |
| `mod.rs` | DHT network discovery module coordinating peer discovery and network bootstrap. Exports DhtNetworkDiscovery service managing the discovery state machine and peer exploration. Dependencies: state machine, discovery components. Used by: DHT service to discover peers, bootstrap network connections, and maintain network topology awareness. |
| `on_connect.rs` | Network discovery connection event handlers for peer connectivity changes. Exports handlers for processing new peer connections and updating discovery state accordingly. Dependencies: connectivity events, peer management. Used by: network discovery service to respond to peer connections, update network topology, and coordinate discovery activities. |
| `ready.rs` | Network discovery ready state implementation for operational discovery service. Exports state handling for when discovery is active and network exploration is ongoing. Dependencies: state machine, operational logic. Used by: network discovery service to manage active discovery operations, coordinate peer exploration, and maintain network awareness. |
| `seed_strap.rs` | Seed peer bootstrapping logic for network discovery initialization. Exports functions for connecting to seed peers and initializing network bootstrap process. Dependencies: peer connections, bootstrap logic. Used by: network discovery service to establish initial network connections through seed peers and begin network exploration. |
| `state_machine.rs` | State machine implementation for DHT network discovery lifecycle management. Exports state machine coordinating discovery phases: initialization, discovering, ready, and waiting states. Dependencies: state implementations, transition logic. Used by: network discovery service to manage discovery lifecycle, coordinate state transitions, and maintain discovery process consistency. |
| `test.rs` | Unit tests for DHT network discovery functionality. Tests state machine transitions, peer discovery algorithms, and network bootstrap scenarios. Dependencies: test utilities, mock networking. Used by: test suite to validate network discovery behavior, state transitions, and peer exploration logic. |
| `waiting.rs` | Network discovery waiting state implementation for discovery cooldown periods. Exports state handling for delays between discovery attempts and periodic network exploration. Dependencies: state machine, timing logic. Used by: network discovery service to manage discovery intervals, implement cooldown periods, and coordinate periodic peer exploration. |

###### comms/dht/src/outbound/

| File | Description |
|------|-------------|
| `broadcast.rs` | DHT outbound message broadcasting logic implementing broadcast strategies. Exports BroadcastLayer for applying broadcast strategies, peer selection, and message distribution. Dependencies: broadcast strategies, peer selection. Used by: DHT outbound pipeline to distribute messages to selected peers based on routing strategy and network topology. |
| `error.rs` | Error types for DHT outbound message processing and broadcasting. Exports DhtOutboundError enum covering peer selection failures, broadcast errors, and routing issues. Dependencies: error handling infrastructure. Used by: DHT outbound pipeline to report message routing failures, peer selection problems, and broadcast issues. |
| `message.rs` | DHT outbound message types and structures for the outbound processing pipeline. Exports message types representing outbound DHT messages at different processing stages. Dependencies: message structures, DHT headers. Used by: DHT outbound pipeline to coordinate message processing, maintain message state, and facilitate pipeline operations. |
| `message_params.rs` | Parameter structures for DHT outbound message configuration. Exports SendMessageParams and related types for configuring message routing, encryption, and delivery options. Dependencies: routing strategies, message configuration. Used by: DHT outbound processing to configure message parameters, routing behavior, and delivery requirements. |
| `message_send_state.rs` | State tracking for DHT outbound message sending operations. Exports types for tracking message delivery status, retry logic, and send completion. Dependencies: message state management. Used by: DHT outbound processing to track message delivery progress, implement retry mechanisms, and coordinate send operations. |
| `mock.rs` | Mock implementations for DHT outbound services used in testing. Exports mock outbound requester and related test utilities for simulating message sending. Dependencies: test frameworks, mock infrastructure. Used by: test suite to simulate outbound message operations, verify routing logic, and test message delivery without real networking. |
| `mod.rs` | DHT outbound message processing module coordinating the complete outbound pipeline. Exports all outbound processing components including broadcast logic, serialization, and message routing. Dependencies: all outbound components. Used by: DHT service to construct the outbound message processing stack and handle message distribution to network peers. |
| `requester.rs` | DHT outbound message requester interface for sending messages. Exports OutboundMessageRequester providing async API for message sending with routing and configuration options. Dependencies: message parameters, outbound pipeline. Used by: DHT components and applications to send messages through the DHT network with specified routing strategies and delivery options. |
| `serialize.rs` | DHT outbound message serialization middleware layer. Exports SerializeLayer for converting structured message data into bytes for network transmission. Dependencies: message serialization, protocol buffers. Used by: DHT outbound pipeline to serialize messages into network format, prepare messages for transmission, and ensure protocol compatibility. |

###### comms/dht/src/proto/

| File | Description |
|------|-------------|
| `common.proto` | Protocol Buffer definitions for common DHT message types and structures. Defines shared message formats, common data types, and protocol primitives used across DHT operations. Dependencies: protobuf specification. Used by: DHT protocol implementation to ensure consistent message formats and enable interoperability between DHT nodes. |
| `dht.proto` | Protocol Buffer definitions for core DHT protocol messages. Defines JoinMessage, discovery messages, and DHT-specific protocol structures for network operations. Dependencies: common protobuf definitions. Used by: DHT protocol implementation to define message formats for join operations, peer discovery, and DHT network coordination. |
| `envelope.proto` | Protocol Buffer definitions for DHT message envelopes and headers. Defines DhtEnvelope, DhtHeader, and message wrapping structures for network transmission. Dependencies: protobuf specification. Used by: DHT message processing to define envelope format, header structure, and message packaging for network protocol compliance. |
| `message_header.proto` | Protocol Buffer definitions for DHT message headers and metadata. Defines message header structure, routing information, and protocol metadata fields. Dependencies: protobuf specification. Used by: DHT message processing to define header format, routing metadata, and protocol information for message transmission and processing. |
| `mod.rs` | DHT protocol buffer module coordinating all protobuf definitions and generated code. Exports protobuf-generated types, conversion utilities, and protocol message types. Dependencies: protobuf definitions, generated code. Used by: DHT system to access protocol buffer types, message serialization, and protocol format definitions. |
| `rpc.proto` | Protocol Buffer definitions for DHT RPC service interfaces and messages. Defines RPC service definitions, request/response types, and remote procedure call interfaces for DHT operations. Dependencies: protobuf specification, RPC framework. Used by: DHT RPC service to define remote interfaces, enable peer-to-peer RPC communication, and provide structured DHT API access. |

###### comms/dht/src/rpc/

| File | Description |
|------|-------------|
| `mock.rs` | Mock implementations for DHT RPC services used in testing. Exports mock RPC handlers and test utilities for simulating DHT RPC operations. Dependencies: RPC framework, test utilities. Used by: test suite to simulate DHT RPC calls, verify RPC behavior, and test remote procedure call functionality without real network operations. |
| `mod.rs` | DHT RPC module coordinating remote procedure call services and interfaces. Exports DHT RPC service implementation, service builders, and RPC interface definitions. Dependencies: RPC implementations, service definitions. Used by: DHT system to provide RPC services, enable remote DHT operations, and coordinate peer-to-peer RPC communication. |
| `peer_info.rs` | DHT RPC service implementation for peer information queries. Exports RPC handlers for retrieving peer information, network status, and DHT topology data. Dependencies: peer management, RPC framework. Used by: DHT RPC service to provide peer information APIs, enable network monitoring, and support peer discovery through remote queries. |
| `service.rs` | DHT RPC service implementation providing remote procedure call interfaces for DHT operations. Exports DhtRpcServiceImpl with methods for peer queries, network information, and DHT status. Dependencies: RPC framework, peer management, DHT core. Used by: external clients and tools to access DHT functionality remotely, monitor network state, and perform DHT operations via RPC interface. |
| `test.rs` | Unit tests for DHT RPC service functionality. Tests RPC interface methods, peer information queries, and service behavior. Dependencies: test utilities, mock RPC framework. Used by: test suite to validate DHT RPC functionality, ensure proper interface behavior, and verify remote procedure call handling. |

###### comms/dht/src/storage/

| File | Description |
|------|-------------|
| `database.rs` | DHT database abstraction layer providing persistent storage for DHT data. Exports DhtDatabase with methods for storing messages, metadata, and network state. Dependencies: SQLite database, storage traits. Used by: DHT components to persist network state, store messages, manage metadata, and provide reliable data storage for DHT operations. |
| `dht_setting_entry.rs` | DHT settings/metadata entry types for database storage. Exports data structures for persisting DHT configuration settings and metadata entries. Dependencies: database serialization, storage traits. Used by: DHT storage layer to manage configuration persistence, store network metadata, and maintain DHT state across restarts. |
| `mod.rs` | DHT storage module coordinating persistent data management for DHT operations. Exports database interfaces, migration utilities, and storage abstractions. Dependencies: database implementations, storage components. Used by: DHT system to provide persistent storage, manage data lifecycle, and coordinate storage operations across DHT components. |

###### comms/dht/src/test_utils/

| File | Description |
|------|-------------|
| `dht_actor_mock.rs` | Mock implementation of DHT actor for testing purposes. Exports mock DhtActor and related test utilities for simulating DHT actor behavior in tests. Dependencies: test frameworks, DHT actor interface. Used by: test suite to mock DHT actor operations, simulate network behavior, and test DHT components without real actor implementation. |
| `dht_discovery_mock.rs` | Mock implementation of DHT discovery service for testing. Exports mock discovery service and utilities for simulating peer discovery operations in tests. Dependencies: test frameworks, discovery interfaces. Used by: test suite to mock discovery operations, simulate peer finding, and test discovery-dependent components without real network operations. |
| `makers.rs` | Factory functions and builders for creating test data and DHT objects. Exports maker functions for generating test peers, messages, and DHT components. Dependencies: DHT types, test data generation. Used by: test suite to create consistent test data, generate test objects, and provide reusable test fixtures for DHT testing. |
| `mod.rs` | DHT test utilities module coordinating all testing helpers and mock implementations. Exports test utilities, mock services, data makers, and testing infrastructure for DHT components. Dependencies: all test utility components. Used by: test suite to access testing tools, mock implementations, and test fixtures for comprehensive DHT testing. |
| `service.rs` | Service utilities and helpers for DHT testing infrastructure. Exports service builders, test service implementations, and testing service coordination utilities. Dependencies: service frameworks, test infrastructure. Used by: test suite to create test services, coordinate testing infrastructure, and provide service utilities for DHT component testing. |

##### comms/dht/tests/

| File | Description |
|------|-------------|
| `attacks.rs` | Integration tests for DHT security and attack resistance. Tests various attack scenarios including malicious peers, network partitions, and protocol violations. Dependencies: test framework, DHT test harness. Used by: security testing to validate DHT resilience against attacks, ensure protocol security, and verify network defense mechanisms. |
| `dht.rs` | Integration tests for core DHT functionality and network operations. Tests DHT initialization, message routing, peer discovery, and network behavior. Dependencies: test framework, DHT test harness. Used by: integration testing to validate DHT operations, ensure network functionality, and verify end-to-end DHT behavior. |
| `harness.rs` | Test harness infrastructure for DHT integration testing. Exports test network builders, DHT test coordinators, and integration test utilities. Dependencies: test frameworks, DHT components. Used by: integration tests to create test networks, coordinate multi-node testing, and provide comprehensive DHT testing infrastructure. |

#### comms/rpc_macros/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for Tari RPC macros crate providing procedural macros for RPC service generation. Defines dependencies on proc-macro2, quote, syn for macro implementation. Dependencies: Rust proc-macro ecosystem. Used by: build system to compile RPC procedural macros, manage macro dependencies, and provide RPC code generation capabilities. |
| `README.md` | Documentation for Tari RPC macros crate explaining procedural macro usage for RPC service generation. Provides examples, usage patterns, and macro API documentation. Dependencies: none. Used by: developers to understand RPC macro usage, implement RPC services, and integrate RPC code generation into applications. |

##### comms/rpc_macros/src/

| File | Description |
|------|-------------|
| `expand.rs` | Token stream expansion utilities for RPC procedural macros. Exports functions for expanding macro tokens, generating code, and managing macro output. Dependencies: proc-macro2, quote, syn. Used by: RPC macro implementation to expand procedural macros, generate RPC service code, and transform syntax trees into executable code. |
| `generator.rs` | Code generation engine for RPC service procedural macros. Exports code generators for creating RPC service implementations, client stubs, and service traits. Dependencies: code generation utilities, syntax analysis. Used by: RPC macros to generate service code, create RPC interfaces, and automate RPC service implementation. |
| `lib.rs` | Procedural macro library for generating Tari RPC service boilerplate code. Provides #[tari_rpc] attribute macro that generates server and client structs from trait definitions. Supports protocol name specification, method numbering for versioning, streaming responses, and automatic client/server code generation. Includes expand module for code generation, method info parsing, and options configuration. Enables clean trait-based RPC service definitions with automatic tower-service integration and protocol negotiation support. |
| `macros.rs` | Main procedural macro implementations for RPC service generation. Exports derive macros and attribute macros for creating RPC services, clients, and handlers. Dependencies: macro infrastructure, code generation. Used by: applications to automatically generate RPC services, reduce boilerplate code, and implement standardized RPC interfaces. |
| `method_info.rs` | Method information extraction and analysis for RPC macro generation. Exports utilities for parsing method signatures, extracting parameters, and analyzing RPC method attributes. Dependencies: syntax analysis, attribute parsing. Used by: RPC macro generators to understand method structure, extract RPC metadata, and generate appropriate service implementations. |
| `options.rs` | Configuration options and attribute parsing for RPC procedural macros. Exports option structures and parsing utilities for macro configuration and customization. Dependencies: attribute parsing, configuration types. Used by: RPC macros to parse macro attributes, configure code generation, and customize RPC service behavior. |

##### comms/rpc_macros/tests/

| File | Description |
|------|-------------|
| `macro.rs` | Unit tests for RPC procedural macros validating macro expansion and generated code. Tests macro functionality, code generation, and RPC service creation. Dependencies: test framework, macro testing utilities. Used by: test suite to validate RPC macro behavior, ensure correct code generation, and verify macro functionality. |

### docs/

| File | Description |
|------|-------------|
| `README.md` | Main documentation index for the Tari project providing overview, links to guides, and documentation structure. Explains project organization, how to navigate documentation, and links to key resources. Dependencies: none. Used by: developers and users to understand project structure, find relevant documentation, and get started with Tari development. |
| `book.toml` | Configuration file for mdBook documentation generation. Specifies book structure, output settings, preprocessing options, and theme configuration for Tari documentation. Dependencies: mdBook. Used by: documentation build system to generate HTML documentation, configure book layout, and customize documentation presentation. |

#### docs/Standard Operating Procedure/

| File | Description |
|------|-------------|
| `hardfork.md` | Standard operating procedure documentation for managing Tari network hard forks. Outlines steps for planning, testing, coordinating, and executing network protocol upgrades. Dependencies: none. Used by: development team and network operators to coordinate hard fork procedures, ensure smooth upgrades, and maintain network consensus. |
| `release.md` | Standard operating procedure documentation for Tari software releases. Details release planning, testing procedures, deployment steps, and post-release processes. Dependencies: none. Used by: development team to standardize release processes, ensure quality control, and coordinate software deployment across the network. |

#### docs/guide/

| File | Description |
|------|-------------|
| `applications_overview.md` | Overview documentation for Tari applications and their architecture. Explains application structure, interaction patterns, and integration approaches within the Tari ecosystem. Dependencies: none. Used by: developers to understand Tari application development, architectural patterns, and how to build applications on the Tari platform. |
| `ffi_overview.md` | Foreign Function Interface (FFI) overview documentation for Tari library integration. Explains FFI bindings, C API usage, and integration with non-Rust applications. Dependencies: none. Used by: developers integrating Tari libraries into non-Rust applications, creating language bindings, and building cross-platform integrations. |
| `grpc_overview.md` | gRPC interface overview documentation for Tari services. Explains gRPC API structure, service definitions, and client integration patterns. Dependencies: none. Used by: developers building gRPC clients, integrating with Tari services, and understanding the gRPC API architecture. |
| `tari_transaction_creation_overview.md` | Transaction creation overview documentation for the Tari blockchain. Explains transaction structure, creation process, input/output handling, and signature requirements. Dependencies: none. Used by: developers implementing transaction creation, understanding Tari transaction format, and building wallet or application transaction functionality. |

#### docs/src/

| File | Description |
|------|-------------|
| `08_setting_up_development_environment.md` | Development environment setup guide for Tari contributors. Covers installation requirements, build tools, development dependencies, and environment configuration. Dependencies: none. Used by: new developers to set up Tari development environment, configure build tools, and prepare for Tari development work. |
| `09_adding_tari_to_your_exchange.md` | Exchange integration guide for adding Tari support to cryptocurrency exchanges. Covers API integration, wallet management, deposit/withdrawal handling, and security considerations. Dependencies: none. Used by: exchange developers to integrate Tari support, implement trading functionality, and manage Tari assets on exchanges. |
| `API_GRPC_Explanation.md` | Detailed explanation of Tari's gRPC API design and implementation. Covers service definitions, message types, error handling, and API usage patterns. Dependencies: none. Used by: developers working with Tari gRPC APIs, understanding service architecture, and implementing gRPC client applications. |
| `SUMMARY.md` | Table of contents and chapter structure for the Tari documentation book. Defines documentation organization, chapter ordering, and navigation structure for mdBook. Dependencies: mdBook. Used by: documentation system to generate navigation, organize content structure, and provide consistent documentation layout. |
| `Tari_FAQ.md` | Frequently Asked Questions (FAQ) documentation for the Tari project. Provides answers to common questions about Tari technology, usage, development, and troubleshooting. Dependencies: none. Used by: users and developers to find quick answers to common questions, troubleshoot issues, and understand Tari concepts. |
| `branching_releases.md` | Documentation on Tari's branching strategy and release management process. Explains git branching model, release procedures, and version management practices. Dependencies: none. Used by: development team to understand branching strategy, coordinate releases, and maintain consistent development workflow. |
| `btc_atomic_swap.md` | Documentation on Bitcoin atomic swap functionality and implementation in Tari. Covers atomic swap protocols, cross-chain trading, and implementation details. Dependencies: none. Used by: developers implementing cross-chain functionality, understanding atomic swap mechanics, and building inter-blockchain trading features. |
| `multi_party_range.md` | Documentation on multi-party range proof implementation and cryptographic protocols in Tari. Explains range proof mechanics, multi-party computation, and privacy features. Dependencies: none. Used by: developers understanding cryptographic protocols, implementing privacy features, and working with range proofs. |
| `payref_userguide.md` | User guide documentation for Tari's payment reference (PayRef) system. Explains how to create, use, and manage payment references for transactions. Dependencies: none. Used by: users and developers to understand payment references, implement payment flows, and integrate payment reference functionality. |
| `replay_attacks.md` | Documentation on replay attack prevention and mitigation strategies in Tari. Explains attack vectors, prevention mechanisms, and security best practices. Dependencies: none. Used by: developers understanding security threats, implementing attack prevention, and designing secure protocols. |
| `reviewing_guide.md` | Code review guidelines and best practices for Tari project contributors. Covers review process, quality standards, security considerations, and collaboration practices. Dependencies: none. Used by: developers and reviewers to maintain code quality, ensure security standards, and provide effective code reviews. |
| `tari_script_no_op_vulnerability.md` | Documentation of a specific vulnerability in Tari script no-op handling and its mitigation. Explains the vulnerability, impact, fix implementation, and prevention measures. Dependencies: none. Used by: security researchers, developers, and auditors to understand the vulnerability, verify fixes, and learn from security issues. |
| `wallet_to_wallet_with_tariscript.md` | Documentation on wallet-to-wallet transactions using TariScript functionality. Explains scripting capabilities, transaction automation, and advanced wallet features. Dependencies: none. Used by: developers implementing wallet features, understanding TariScript capabilities, and building advanced transaction functionality. |

##### docs/src/diagrams/

| File | Description |
|------|-------------|
| `README.md` | Index and overview of architectural diagrams and visual documentation for the Tari project. Explains diagram organization, types of diagrams available, and how to interpret them. Dependencies: none. Used by: developers and architects to understand system design, navigate visual documentation, and find relevant architectural diagrams. |
| `block_sync.md` | Architectural diagram and documentation for Tari's block synchronization process. Illustrates how nodes sync blockchain state, handle block propagation, and maintain consensus. Dependencies: none. Used by: developers understanding blockchain synchronization, implementing sync logic, and debugging network consensus issues. |
| `chain_metadata_service.md` | Architectural diagram and documentation for Tari's chain metadata service. Illustrates how blockchain metadata is managed, cached, and distributed across the network. Dependencies: none. Used by: developers understanding blockchain metadata handling, implementing metadata services, and debugging blockchain state management. |
| `decide_next_sync.md` | Architectural diagram showing Tari's decision logic for determining next synchronization actions. Illustrates how nodes decide what to sync next based on network state and local conditions. Dependencies: none. Used by: developers understanding sync strategy, implementing sync logic, and optimizing blockchain synchronization performance. |
| `header_sync.md` | Architectural diagram documenting Tari's block header synchronization process. Shows how nodes sync block headers, validate chains, and maintain header consistency across the network. Dependencies: none. Used by: developers implementing header sync, understanding blockchain validation, and debugging sync issues. |
| `horizon_sync.md` | Architectural diagram explaining Tari's horizon synchronization mechanism for efficient blockchain sync. Shows how nodes sync recent blockchain state while maintaining security and efficiency. Dependencies: none. Used by: developers understanding horizon sync concepts, implementing sync optimizations, and debugging synchronization performance. |
| `incoming_blocks.md` | Architectural diagram documenting how Tari handles incoming blocks from the network. Shows block validation, processing pipeline, and integration into the blockchain. Dependencies: none. Used by: developers implementing block handling, understanding validation flow, and debugging block processing issues. |
| `listening_state.md` | Architectural diagram showing Tari's listening state management and network monitoring. Illustrates how nodes maintain network awareness and respond to network events. Dependencies: none. Used by: developers understanding network state management, implementing network monitoring, and debugging connectivity issues. |
| `reconcile_block.md` | Architectural diagram documenting Tari's block reconciliation process for resolving blockchain conflicts. Shows how nodes handle competing chains and maintain consensus. Dependencies: none. Used by: developers understanding consensus mechanisms, implementing conflict resolution, and debugging chain reorganization issues. |
| `state_machine.md` | Architectural diagram documenting Tari's state machine implementations and transitions. Shows state management patterns, transition logic, and state coordination across system components. Dependencies: none. Used by: developers understanding state management, implementing state machines, and debugging state transition issues. |

###### docs/src/diagrams/comms/

| File | Description |
|------|-------------|
| `inbound_messaging.md` | Architectural diagram documenting Tari's inbound messaging pipeline and message processing flow. Shows how messages are received, validated, and routed through the communications system. Dependencies: none. Used by: developers understanding message handling, implementing communication features, and debugging messaging issues. |
| `index.md` | Index and overview of communications system diagrams for the Tari project. Provides navigation to messaging, protocol, and communication architecture diagrams. Dependencies: none. Used by: developers to find communication-related diagrams, understand messaging architecture, and navigate communication system documentation. |
| `protocol_negotiation.md` | Architectural diagram documenting Tari's protocol negotiation process between peers. Shows how nodes establish communication protocols, negotiate capabilities, and establish secure connections. Dependencies: none. Used by: developers implementing protocol handling, understanding peer negotiation, and debugging connection establishment. |

##### docs/src/theme/

| File | Description |
|------|-------------|
| `book.js` | JavaScript functionality for the Tari documentation book theme. Provides interactive features, navigation enhancements, and custom documentation behavior. Dependencies: web browser JavaScript APIs. Used by: documentation website to provide enhanced user experience, interactive features, and improved navigation. |
| `highlight.css` | CSS styling for syntax highlighting in code blocks within the Tari documentation. Defines color schemes and styling for different programming languages and code elements. Dependencies: syntax highlighting library. Used by: documentation website to provide syntax highlighting, improve code readability, and enhance code presentation. |
| `highlight.js` | JavaScript syntax highlighting functionality for code blocks in the Tari documentation. Provides automatic syntax highlighting, language detection, and code formatting features. Dependencies: highlight.js library. Used by: documentation website to highlight code syntax, improve code readability, and provide interactive code features. |
| `index.hbs` | Handlebars template for the main documentation page layout and structure. Defines HTML structure, includes stylesheets and scripts, and provides the base template for documentation pages. Dependencies: Handlebars templating, mdBook. Used by: documentation build system to generate HTML pages, structure content layout, and provide consistent page framework. |

###### docs/src/theme/css/

| File | Description |
|------|-------------|
| `chrome.css` | CSS styling for browser chrome and navigation elements in the Tari documentation theme. Defines styles for menus, navigation bars, and browser-specific interface elements. Dependencies: web CSS standards. Used by: documentation website to style navigation interface, provide consistent visual design, and enhance user interface. |
| `general.css` | General CSS styling and layout definitions for the Tari documentation theme. Provides base styles, typography, layout grid, and general visual design elements. Dependencies: web CSS standards. Used by: documentation website to define overall visual appearance, typography, and layout structure. |
| `print.css` | CSS styling optimized for print media in the Tari documentation theme. Defines print-specific styles, page layout, and formatting for printed documentation. Dependencies: web CSS print media queries. Used by: documentation website to provide optimized print layout, ensure readable printed documentation, and format content for printing. |
| `variables.css` | CSS variable definitions and theme configuration for the Tari documentation. Defines color schemes, spacing, typography variables, and customizable theme properties. Dependencies: web CSS custom properties. Used by: documentation theme to provide consistent design variables, enable theme customization, and maintain visual consistency. |

###### docs/src/theme/js/

| File | Description |
|------|-------------|
| `mermaid.min.js` | [GENERATED] Minified Mermaid.js library for rendering diagrams and flowcharts in the Tari documentation. Provides diagram rendering capabilities, flowchart generation, and visual documentation features. Dependencies: web browser JavaScript APIs. Used by: documentation website to render diagrams, create visual documentation, and provide interactive diagram features. |

### hashing/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for Tari hashing library providing cryptographic hash functions and utilities. Defines dependencies on cryptographic libraries and hashing implementations. Dependencies: Rust crypto ecosystem. Used by: build system to compile hashing library, manage cryptographic dependencies, and provide hash function implementations. |
| `README.md` | Documentation for Tari hashing library explaining cryptographic hash functions, usage patterns, and implementation details. Provides API documentation and usage examples. Dependencies: none. Used by: developers to understand hashing library capabilities, implement cryptographic operations, and integrate hash functions into applications. |

#### hashing/src/

| File | Description |
|------|-------------|
| `borsh_hasher.rs` | Borsh-based hasher implementation for consistent serialization and hashing. Exports hasher types that use Borsh serialization for deterministic hash generation. Dependencies: Borsh serialization, hashing traits. Used by: cryptographic operations to provide consistent hashing, ensure deterministic serialization, and maintain hash compatibility across systems. |
| `domains.rs` | Domain separation constants and utilities for cryptographic hash functions. Exports domain tags and separation mechanisms to prevent hash collision attacks across different use cases. Dependencies: hash function types. Used by: cryptographic operations to ensure hash domain separation, prevent collision attacks, and maintain cryptographic security across different contexts. |
| `lib.rs` | Core hashing utilities library for Tari, designed as no_std for cross-platform compatibility including ledger devices. Provides domain separation for cryptographic hashing functions and Borsh serialization-based hashing utilities. Exports domain-specific hash functions used throughout Tari protocol for ensuring different hash contexts don't interfere with each other. Essential for maintaining cryptographic security across blockchain operations, transaction processing, and Merkle tree constructions. |

#### infrastructure/derive/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for Tari derive macro crate providing procedural macros for code generation. Defines dependencies on proc-macro2, quote, syn for derive macro implementation. Dependencies: Rust proc-macro ecosystem. Used by: build system to compile derive macros, enable automatic trait implementations, and provide code generation capabilities across Tari crates. |
| `README.md` | Documentation for Tari derive macros explaining procedural macro usage for trait derivation and code generation. Provides examples, usage patterns, and macro API documentation. Dependencies: none. Used by: developers to understand derive macro capabilities, implement automatic trait derivation, and integrate code generation into Tari development. |

##### infrastructure/derive/src/

| File | Description |
|------|-------------|
| `extend_bytes.rs` | Derive macro implementation for extending byte vectors with typed data. Exports procedural macro for automatic implementation of byte extension traits and serialization methods. Dependencies: proc-macro utilities, serialization traits. Used by: Tari types to automatically implement byte extension functionality, enable efficient serialization, and maintain type safety in byte operations. |
| `hashable.rs` | Derive macro implementation for automatic Hashable trait derivation. Exports procedural macro for generating consistent hash implementations across Tari types with domain separation and security considerations. Dependencies: hashing infrastructure, proc-macro utilities. Used by: Tari types to automatically implement secure hashing, ensure hash consistency, and enable cryptographic operations on custom types. |
| `hashable_ordering.rs` | Derive macro implementation for hashable ordering and canonical serialization. Exports procedural macro for generating deterministic ordering and hashing that is consistent across different systems and platforms. Dependencies: hashable traits, ordering utilities. Used by: consensus-critical types to ensure deterministic hashing, maintain consistent ordering, and prevent consensus failures due to serialization differences. |
| `lib.rs` | Procedural macro library providing automatic trait derivations for Tari data structures. Implements HashableOrdering derive macro for sortable hashable structs, Hashable derive macro for hash function implementations with configurable digest algorithms, and ExtendBytes derive macro for byte serialization. Includes field-level attributes for selective inclusion/exclusion (#[Hashable(Ignore)], #[ExtendBytes(Ignore)]) and digest specification (#[Digest = "<DigestType>"]). Essential for maintaining consistent hashing and serialization across Tari blockchain data structures while reducing boilerplate code. |

#### infrastructure/libtor/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for Tari libtor crate providing Tor network integration and privacy features. Defines dependencies on Tor libraries, network utilities, and privacy infrastructure. Dependencies: Tor libraries, networking. Used by: build system to compile Tor integration, manage privacy dependencies, and enable anonymous networking capabilities within Tari. |

##### infrastructure/libtor/src/

| File | Description |
|------|-------------|
| `lib.rs` | Embedded Tor integration library for Unix systems providing privacy and anonymity for Tari network communications. Wraps the libtor C library to enable embedded Tor instances within Tari applications. Conditionally compiled for Unix platforms only, allowing Tari nodes to run their own Tor daemon for enhanced privacy without requiring external Tor installation. Provides transport configuration integration and background Tor service management. |
| `tor.rs` | Tor network integration implementation providing anonymous networking capabilities for Tari. Exports Tor client functionality, onion service management, and privacy-preserving networking features. Dependencies: Tor libraries, network protocols. Used by: Tari networking to provide anonymous communications, protect user privacy, and enable censorship-resistant networking through Tor onion routing. |

#### infrastructure/max_size/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for Tari max_size crate providing size-limited data structures for security and resource management. Defines utilities for bounded collections and memory-safe operations. Dependencies: standard library collections. Used by: build system to compile size-limited collections, manage memory constraints, and prevent resource exhaustion attacks through bounded data structures. |

##### infrastructure/max_size/src/

| File | Description |
|------|-------------|
| `bytes.rs` | Size-limited byte vector implementation for secure memory management. Exports MaxSizeBytes type with automatic size enforcement, preventing memory exhaustion and ensuring bounded resource usage. Dependencies: standard library Vec. Used by: security-critical code to handle byte data with size limits, prevent DoS attacks, and maintain predictable memory usage patterns. |
| `lib.rs` | Memory-safe bounded collection types preventing excessive memory allocation in Tari applications. Provides MaxSizeString for size-limited strings with overflow protection, MaxSizeBytes for bounded byte arrays, and MaxSizeVec for capacity-limited vectors. Includes comprehensive error handling (MaxSizeStringLengthError, MaxSizeBytesError, MaxSizeVecError) to prevent denial-of-service attacks through memory exhaustion. Essential for network-facing components where input size validation is critical for system stability and security. |
| `string.rs` | Size-limited string implementation for secure text handling and resource management. Exports MaxSizeString type with automatic length enforcement, preventing string-based attacks and memory exhaustion. Dependencies: standard library String. Used by: input validation and text processing to handle strings with size limits, prevent buffer overflow attacks, and ensure bounded memory allocation. |
| `vec.rs` | Size-limited vector implementation for secure collection management and resource control. Exports MaxSizeVec type with automatic capacity enforcement, preventing unbounded growth and ensuring predictable memory usage. Dependencies: standard library Vec. Used by: security-critical code to handle collections with size limits, prevent memory exhaustion attacks, and maintain bounded resource consumption. |

#### infrastructure/metrics/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for Tari metrics collection and monitoring infrastructure. Defines dependencies on metrics frameworks, server components, and monitoring utilities. Dependencies: metrics libraries, HTTP server. Used by: build system to compile metrics infrastructure, enable system monitoring, and provide performance measurement capabilities across Tari components. |
| `README.md` | Documentation for Tari metrics infrastructure explaining monitoring capabilities, metric collection, and performance measurement systems. Provides setup instructions and usage examples. Dependencies: none. Used by: developers and operators to understand metrics collection, configure monitoring, and implement performance measurement in Tari applications. |

##### infrastructure/metrics/src/

| File | Description |
|------|-------------|
| `lib.rs` | Prometheus metrics collection library for Tari applications. Provides thread-safe global registry management, convenience functions for registering various metric types (Gauge, IntGauge, Counter, IntCounter, Histogram), and optional metrics server. Re-exports core Prometheus types including collectors, timers, and error handling. Supports metric registration with labels, automatic collection registration, and centralized metric management across Tari components. Includes registry cloning and custom collector registration capabilities. |
| `server.rs` | Main metrics server implementation coordinating metrics collection, aggregation, and exposure. Exports unified metrics server managing both pull and push collection modes. Dependencies: server components, metrics infrastructure. Used by: Tari applications to provide metrics monitoring, enable performance measurement, and integrate with monitoring systems. |

###### infrastructure/metrics/src/server/

| File | Description |
|------|-------------|
| `builder.rs` | Builder pattern implementation for configuring and constructing metrics server instances. Exports server builder with options for endpoints, collection intervals, and output formats. Dependencies: server infrastructure, configuration types. Used by: metrics infrastructure to create customized metrics servers, configure monitoring endpoints, and set up performance measurement collection. |
| `pull.rs` | Pull-based metrics collection server implementation for exposing metrics endpoints. Exports HTTP server functionality for external monitoring systems to scrape metrics data. Dependencies: HTTP server, metrics collection. Used by: monitoring infrastructure to expose metrics endpoints, enable Prometheus-style scraping, and provide external access to system metrics. |
| `push.rs` | Push-based metrics collection server implementation for active metrics reporting. Exports functionality for pushing metrics to external systems and centralized monitoring services. Dependencies: HTTP client, metrics formatting. Used by: monitoring infrastructure to actively push metrics, integrate with external monitoring systems, and enable real-time metrics reporting. |

#### infrastructure/shutdown/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for Tari shutdown infrastructure providing graceful application termination and signal handling. Defines utilities for coordinated shutdown across system components. Dependencies: signal handling, async utilities. Used by: build system to compile shutdown infrastructure, enable graceful termination, and coordinate clean application shutdown across Tari services. |
| `README.md` | Documentation for Tari shutdown infrastructure explaining graceful termination patterns, signal handling, and coordinated shutdown procedures. Provides usage examples and best practices. Dependencies: none. Used by: developers to implement graceful shutdown, handle termination signals, and coordinate clean application shutdown across distributed components. |

##### infrastructure/shutdown/src/

| File | Description |
|------|-------------|
| `lib.rs` | Graceful shutdown coordination library providing async-compatible shutdown signaling across Tari applications. Implements Shutdown trigger with broadcast capabilities, ShutdownSignal futures that resolve on trigger or drop, and OptionalShutdownSignal for conditional shutdown handling. Features oneshot trigger mechanism, atomic state tracking, FusedFuture implementation for efficient polling, and select() support for combining with other futures. Enables clean application shutdown coordination between services, with clone support for multiple listeners and automatic triggering on drop. |
| `oneshot_trigger.rs` | One-shot trigger implementation for coordinating shutdown signals across system components. Exports trigger mechanisms for broadcasting shutdown events and coordinating graceful termination. Dependencies: async synchronization, signal handling. Used by: shutdown infrastructure to coordinate termination events, ensure ordered shutdown, and provide reliable shutdown signaling across distributed components. |

#### infrastructure/storage/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for Tari storage infrastructure providing database abstractions and key-value store implementations. Defines dependencies on LMDB, storage traits, and database utilities. Dependencies: LMDB, storage libraries. Used by: build system to compile storage infrastructure, manage database dependencies, and provide persistent storage capabilities across Tari components. |
| `README.md` | Documentation for Tari storage infrastructure explaining database abstractions, key-value stores, and persistent storage patterns. Provides API documentation and usage examples. Dependencies: none. Used by: developers to understand storage architecture, implement persistent data structures, and integrate database functionality into Tari applications. |

##### infrastructure/storage/src/

| File | Description |
|------|-------------|
| `lib.rs` | Storage abstraction layer providing key-value store interfaces for Tari applications. Exports KeyValueStore trait, LMDB database wrapper (LMDBWrapper), in-memory HashMap database implementation, cached store for performance optimization, and comprehensive error handling (KeyValStoreError). Includes LMDB-specific storage implementation with transaction support and iteration capabilities through IterationResult. Designed to support multiple storage backends while maintaining consistent interface across Tari components. |

###### infrastructure/storage/src/key_val_store/

| File | Description |
|------|-------------|
| `cached_store.rs` | Cached key-value store implementation providing in-memory caching layer over persistent storage. Exports caching wrapper with LRU eviction, write-through/write-back strategies, and cache coherence. Dependencies: key-value store traits, caching utilities. Used by: storage layer to improve read performance, reduce database load, and provide fast access to frequently used data. |
| `error.rs` | Error types and error handling for key-value store operations. Exports storage error enums covering database failures, serialization errors, and transaction issues. Dependencies: error handling infrastructure. Used by: storage components to provide structured error reporting, enable proper error handling, and facilitate storage operation debugging. |
| `hmap_database.rs` | HashMap-based key-value store implementation for in-memory storage and testing. Exports thread-safe HashMap wrapper with key-value store interface for development and testing scenarios. Dependencies: standard library HashMap, synchronization. Used by: testing infrastructure and development scenarios to provide fast in-memory storage without persistence requirements. |
| `key_val_store.rs` | Core key-value store trait definitions and abstractions for storage operations. Exports KeyValueStore trait with methods for get, put, delete, and iteration operations. Dependencies: storage error types, serialization. Used by: storage implementations to provide consistent interface, enable storage abstraction, and facilitate database backend swapping. |
| `lmdb_database.rs` | LMDB-based key-value store implementation providing persistent, ACID-compliant storage. Exports LMDB wrapper with transaction support, cursor iteration, and optimal performance characteristics. Dependencies: LMDB library, storage traits. Used by: production storage to provide reliable persistence, transaction support, and high-performance database operations for critical Tari data. |
| `mod.rs` | Key-value store module coordinating all storage implementations and abstractions. Exports key-value store traits, implementations, and utilities for database operations. Dependencies: all key-value store components. Used by: storage layer to provide unified key-value storage interface, coordinate storage implementations, and abstract database operations. |

###### infrastructure/storage/src/lmdb_store/

| File | Description |
|------|-------------|
| `error.rs` | Error types specific to LMDB storage operations and database management. Exports LMDB-specific error handling covering transaction failures, database corruption, and environment issues. Dependencies: LMDB library, error infrastructure. Used by: LMDB storage implementation to provide detailed error reporting, handle database-specific failures, and facilitate LMDB operation debugging. |
| `mod.rs` | LMDB store module coordinating Lightning Memory-Mapped Database integration and management. Exports LMDB store implementations, configuration, and utilities for high-performance persistent storage. Dependencies: LMDB components. Used by: storage infrastructure to provide LMDB integration, manage database environments, and coordinate LMDB-based storage operations. |
| `store.rs` | Core LMDB store implementation providing database operations, transaction management, and storage utilities. Exports LmdbStore with methods for database management, transaction handling, and efficient data operations. Dependencies: LMDB library, storage abstractions. Used by: storage layer to provide production-grade LMDB storage, manage database transactions, and ensure data persistence and integrity. |

##### infrastructure/storage/tests/

| File | Description |
|------|-------------|
| `README.md` | Documentation for storage infrastructure tests explaining test organization, database testing patterns, and test data management. Provides overview of storage test coverage and testing approaches. Dependencies: none. Used by: developers to understand storage testing, run database tests, and contribute to storage infrastructure validation. |
| `lmdb.rs` | Integration tests for LMDB storage implementation validating database operations, transaction handling, and storage functionality. Tests LMDB-specific features, performance characteristics, and error conditions. Dependencies: test framework, LMDB storage. Used by: test suite to validate LMDB storage implementation, ensure database reliability, and verify storage operation correctness. |
| `users.csv` | Test data file containing user information for storage infrastructure testing. Provides sample data for database operations, import/export testing, and storage functionality validation. Dependencies: none. Used by: storage tests to provide consistent test data, validate data import/export capabilities, and test database operations with realistic data sets. |

###### infrastructure/storage/tests/data/

| File | Description |
|------|-------------|
| `.gitkeep` | [GENERATED] Git keep file to preserve test data directory structure for storage tests. Ensures the test data folder is tracked in version control even when empty. Dependencies: none. Used by: Git to maintain directory structure for storage test data and temporary database files. |

#### infrastructure/tari_script/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for TariScript virtual machine and scripting infrastructure. Defines dependencies on script execution, opcode implementations, and virtual machine components. Dependencies: cryptographic libraries, script utilities. Used by: build system to compile TariScript VM, manage scripting dependencies, and provide programmable transaction capabilities within Tari. |
| `README.md` | Documentation for TariScript virtual machine explaining scripting capabilities, opcode reference, and smart contract functionality. Provides programming guide and usage examples. Dependencies: none. Used by: developers to understand TariScript capabilities, implement smart contracts, and build programmable transaction logic using TariScript VM. |

##### infrastructure/tari_script/src/

| File | Description |
|------|-------------|
| `error.rs` | Error types and error handling for TariScript virtual machine operations. Exports script execution errors, opcode errors, and VM runtime failures. Dependencies: error handling infrastructure. Used by: TariScript VM to provide structured error reporting, handle script execution failures, and facilitate script debugging and error recovery. |
| `lib.rs` | Tari Script execution engine implementing a stack-based scripting language for transaction validation and smart contracts. Provides TariScript structure, ExecutionStack for script execution, Opcode definitions with versioning, ScriptContext for execution environment, and SchnorrSignature support for CheckSig operations. Includes error handling (ScriptError), stack operations (StackItem), and domain-separated hashing for signature verification. Features push_pubkey_script utility for standard one-sided payments and script serialization support. |
| `op_codes.rs` | TariScript opcode definitions and implementations for virtual machine operations. Exports opcode enumeration, instruction implementations, and execution logic for script operations. Dependencies: script execution context, cryptographic operations. Used by: TariScript VM to execute script instructions, implement smart contract logic, and provide programmable transaction capabilities. |
| `script.rs` | Core TariScript implementation providing script parsing, validation, and execution coordination. Exports Script type with methods for script compilation, validation, and execution management. Dependencies: opcode implementations, script context. Used by: transaction processing to execute script logic, validate script conditions, and enable programmable transaction validation. |
| `script_context.rs` | Execution context for TariScript virtual machine providing runtime environment and state management. Exports ScriptContext with execution state, variable bindings, and runtime utilities for script execution. Dependencies: script types, execution state. Used by: TariScript VM to maintain execution context, manage script state, and provide runtime environment for script operations. |
| `serde.rs` | Serialization and deserialization utilities for TariScript data types and bytecode. Exports serde implementations for script serialization, bytecode encoding, and cross-platform compatibility. Dependencies: serde framework, script types. Used by: TariScript system to serialize scripts, encode bytecode for storage/transmission, and maintain script format compatibility across systems. |
| `stack.rs` | Stack implementation for TariScript virtual machine providing operand storage and manipulation. Exports stack operations for push, pop, and stack management during script execution. Dependencies: script data types, stack utilities. Used by: TariScript VM to manage execution stack, handle operands during script execution, and provide stack-based computation model. |

#### infrastructure/test_utils/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for Tari test utilities infrastructure providing testing frameworks and utilities. Defines dependencies on test frameworks, async utilities, and testing infrastructure. Dependencies: test frameworks, async runtime. Used by: build system to compile test utilities, provide testing infrastructure, and enable comprehensive testing capabilities across Tari components. |
| `README.md` | Documentation for Tari test utilities explaining testing frameworks, utility functions, and testing patterns. Provides testing guidelines and utility API documentation. Dependencies: none. Used by: developers to understand testing infrastructure, implement comprehensive tests, and utilize testing utilities for Tari component validation. |

##### infrastructure/test_utils/src/

| File | Description |
|------|-------------|
| `enums.rs` | Testing utilities for enum handling and validation. Exports test helpers for enum iteration, validation testing, and exhaustive enum coverage verification. Dependencies: test frameworks. Used by: test suite to ensure complete enum coverage, validate enum behavior, and test enum-related functionality comprehensively. |
| `lib.rs` | Common testing utilities library for Tari codebase providing standardized test helpers. Includes futures utilities for testing async code, path utilities for file-based tests, random value generation helpers, stream testing utilities with macros, and comms/services testing infrastructure. Provides runtime utilities for test environments and enum testing helpers. Designed to reduce code duplication and standardize testing patterns across all Tari components and applications. |
| `paths.rs` | Path and filesystem utilities for testing infrastructure. Exports temporary directory creation, test file management, and path manipulation utilities for test environments. Dependencies: filesystem utilities, temporary file handling. Used by: test suite to manage test files, create temporary directories, and handle filesystem operations in isolated test environments. |
| `runtime.rs` | Runtime utilities for async testing infrastructure and test execution coordination. Exports test runtime builders, async test helpers, and runtime configuration for test environments. Dependencies: async runtime, test frameworks. Used by: test suite to provide async test runtime, coordinate test execution, and manage async testing infrastructure across test modules. |

###### infrastructure/test_utils/src/comms_and_services/

| File | Description |
|------|-------------|
| `mod.rs` | Test utilities for communications and services infrastructure testing. Exports mock services, test builders, and utilities for testing distributed components and service interactions. Dependencies: service frameworks, test infrastructure. Used by: test suite to create mock services, test service interactions, and validate communications infrastructure behavior. |

###### infrastructure/test_utils/src/futures/

| File | Description |
|------|-------------|
| `async_assert_eventually.rs` | Async assertion utilities for testing eventual conditions and timing-dependent behavior. Exports async_assert_eventually! macro for testing conditions that should be true after some time. Dependencies: async testing, timing utilities. Used by: async tests to validate eventual consistency, test timing-dependent behavior, and ensure async operations complete successfully. |
| `mod.rs` | Future testing utilities module coordinating async testing infrastructure and future-based test helpers. Exports async testing utilities, future helpers, and timing assertion tools. Dependencies: async testing infrastructure. Used by: test suite to provide async testing capabilities, coordinate future-based tests, and validate async operation behavior. |

###### infrastructure/test_utils/src/random/

| File | Description |
|------|-------------|
| `mod.rs` | Random data generation utilities for testing infrastructure. Exports random generators for test data, cryptographic key generation, and randomized testing scenarios. Dependencies: random number generation, cryptographic utilities. Used by: test suite to generate consistent test data, create random test scenarios, and provide deterministic randomness for reproducible testing. |

###### infrastructure/test_utils/src/streams/

| File | Description |
|------|-------------|
| `mod.rs` | Stream testing utilities for async stream validation and stream-based testing infrastructure. Exports stream test helpers, mock streams, and utilities for testing async stream behavior. Dependencies: async streams, test frameworks. Used by: test suite to test stream processing, validate async stream behavior, and provide stream testing infrastructure for component validation. |

### integration_tests/

| File | Description |
|------|-------------|
| `Cargo.toml` | Cargo configuration for Tari integration tests providing end-to-end testing infrastructure. Defines dependencies on test frameworks, cucumber testing, FFI testing, and integration test utilities. Dependencies: cucumber, test frameworks, FFI libraries. Used by: build system to compile integration tests, manage test dependencies, and enable comprehensive end-to-end testing of Tari components. |
| `README.md` | Documentation for Tari integration tests explaining end-to-end testing approach, test organization, and integration test execution. Provides testing guidelines and coverage information. Dependencies: none. Used by: developers and testers to understand integration testing, run end-to-end tests, and contribute to integration test coverage. |
| `build.rs` | Build script for integration tests handling code generation, test data preparation, and build-time test configuration. Manages test environment setup and build-time dependencies for integration testing. Dependencies: build utilities. Used by: build system to prepare integration test environment, generate test code, and configure test infrastructure during compilation. |

#### integration_tests/log4rs/

| File | Description |
|------|-------------|
| `cucumber.yml` | Log4rs logging configuration for cucumber integration tests. Defines logging levels, output formats, and log management for behavioral testing scenarios. Dependencies: log4rs configuration format. Used by: cucumber tests to configure logging, manage test output, and provide appropriate logging levels during integration test execution. |

#### integration_tests/src/

| File | Description |
|------|-------------|
| `base_node_process.rs` | Base node process management for integration testing infrastructure. Exports utilities for spawning, managing, and coordinating base node processes during integration tests. Dependencies: process management, base node configuration. Used by: integration tests to create test networks, coordinate multiple base nodes, and test distributed blockchain functionality. |
| `lib.rs` | Integration testing framework and utilities for end-to-end Tari system testing. Provides TariWorld for test environment management, base node process handling, wallet testing infrastructure, FFI testing utilities, merge mining proxy testing, miner testing, and transaction flow testing. Includes port allocation utilities, service waiting mechanisms, peer address management, and temporary directory handling. Designed for comprehensive system testing across all Tari components with real process spawning and network interactions. |
| `merge_mining_proxy.rs` | Integration test utilities for merge mining proxy functionality and Bitcoin merge mining operations. Exports test infrastructure for merge mining scenarios, proxy management, and cross-chain mining coordination. Dependencies: merge mining infrastructure, proxy services. Used by: integration tests to validate merge mining functionality, test proxy operations, and ensure proper Bitcoin-Tari merge mining coordination. |
| `miner.rs` | Integration test utilities for mining functionality and block generation operations. Exports test mining infrastructure, block mining coordination, and mining process management for integration testing. Dependencies: mining infrastructure, block generation. Used by: integration tests to validate mining operations, test block generation, and ensure proper mining functionality across the network. |
| `transaction.rs` | Integration test utilities for transaction functionality and transaction processing operations. Exports transaction test infrastructure, transaction builders, and transaction validation for integration testing. Dependencies: transaction processing, wallet infrastructure. Used by: integration tests to validate transaction operations, test transaction processing, and ensure proper transaction functionality across components. |
| `wallet.rs` | Integration test utilities for wallet functionality and wallet operations. Exports wallet test infrastructure, wallet builders, and wallet coordination for integration testing scenarios. Dependencies: wallet infrastructure, test utilities. Used by: integration tests to validate wallet operations, test wallet functionality, and ensure proper wallet behavior in integration test environments. |
| `wallet_ffi.rs` | Integration test utilities for wallet FFI functionality and cross-language wallet interface testing. Exports FFI wallet test infrastructure, FFI coordination, and wallet FFI validation utilities. Dependencies: wallet FFI, integration test infrastructure. Used by: integration tests to validate wallet FFI operations, test cross-language compatibility, and ensure proper wallet FFI functionality. |
| `wallet_process.rs` | Integration test utilities for wallet process management and wallet coordination. Exports wallet process builders, process management, and wallet lifecycle coordination for integration testing. Dependencies: process management, wallet infrastructure. Used by: integration tests to manage wallet processes, coordinate multiple wallets, and test distributed wallet functionality. |
| `world.rs` | Integration test world state management and test environment coordination. Exports World type for cucumber testing, test state management, and integration test scenario coordination. Dependencies: cucumber framework, test state. Used by: cucumber integration tests to manage test state, coordinate test scenarios, and maintain consistent test environment across behavioral tests. |

##### integration_tests/src/ffi/

| File | Description |
|------|-------------|
| `balance.rs` | FFI (Foreign Function Interface) integration tests for balance-related wallet operations. Tests balance queries, balance updates, and balance management through the C FFI interface. Dependencies: wallet FFI, test frameworks. Used by: integration testing to validate wallet balance functionality, test FFI interface reliability, and ensure cross-language compatibility for balance operations. |
| `callbacks.rs` | FFI integration tests for callback mechanisms and event handling through the C interface. Tests callback registration, event notifications, and asynchronous callback execution. Dependencies: FFI callbacks, test frameworks. Used by: integration testing to validate callback functionality, test event handling reliability, and ensure proper callback execution across language boundaries. |
| `coin_preview.rs` | FFI integration tests for coin preview functionality and transaction estimation. Tests coin selection preview, fee estimation, and transaction building preview through C interface. Dependencies: wallet FFI, transaction preview. Used by: integration testing to validate coin preview functionality, test transaction estimation accuracy, and ensure proper fee calculation through FFI. |
| `comms_config.rs` | FFI integration tests for communications configuration and network setup through C interface. Tests network configuration, peer management, and communication settings via FFI. Dependencies: comms FFI, configuration. Used by: integration testing to validate communications configuration, test network setup reliability, and ensure proper configuration management through FFI. |
| `completed_transaction.rs` | FFI integration tests for completed transaction handling and management through C interface. Tests completed transaction queries, status updates, and transaction history via FFI. Dependencies: wallet FFI, transaction management. Used by: integration testing to validate completed transaction functionality, test transaction history reliability, and ensure proper transaction state management through FFI. |
| `completed_transactions.rs` | FFI integration tests for completed transaction collection management through C interface. Tests transaction list operations, batch processing, and collection handling via FFI. Dependencies: wallet FFI, transaction collections. Used by: integration testing to validate transaction collection functionality, test batch operations reliability, and ensure proper collection management through FFI. |
| `contact.rs` | FFI integration tests for contact management and address book functionality through C interface. Tests contact creation, updates, and management via FFI. Dependencies: wallet FFI, contact management. Used by: integration testing to validate contact functionality, test address book reliability, and ensure proper contact management through FFI. |
| `contacts.rs` | FFI integration tests for contact collection management and batch contact operations through C interface. Tests contact list operations, search functionality, and collection handling via FFI. Dependencies: wallet FFI, contact collections. Used by: integration testing to validate contact collection functionality, test contact search reliability, and ensure proper contact list management through FFI. |
| `contacts_liveness_data.rs` | FFI integration tests for contact liveness monitoring and peer status tracking through C interface. Tests contact connectivity status, liveness probes, and peer monitoring via FFI. Dependencies: wallet FFI, peer monitoring. Used by: integration testing to validate contact liveness functionality, test peer status reliability, and ensure proper connectivity monitoring through FFI. |
| `fee_per_gram_stat.rs` | FFI integration tests for fee per gram statistics and fee estimation through C interface. Tests fee calculation, statistics gathering, and fee optimization via FFI. Dependencies: wallet FFI, fee estimation. Used by: integration testing to validate fee statistics functionality, test fee calculation accuracy, and ensure proper fee estimation through FFI. |
| `fee_per_gram_stats.rs` | FFI integration tests for fee per gram statistics collection and analysis through C interface. Tests fee statistics aggregation, historical data, and fee trends via FFI. Dependencies: wallet FFI, fee statistics. Used by: integration testing to validate fee statistics collection, test fee trend analysis reliability, and ensure proper fee statistics management through FFI. |
| `ffi_bytes.rs` | FFI integration tests for byte data handling and memory management through C interface. Tests byte array operations, memory allocation, and data marshaling via FFI. Dependencies: FFI utilities, memory management. Used by: integration testing to validate byte handling functionality, test memory safety reliability, and ensure proper data marshaling through FFI. |
| `ffi_import.rs` | FFI integration tests for import functionality and data import operations through C interface. Tests wallet import, seed import, and data migration via FFI. Dependencies: wallet FFI, import utilities. Used by: integration testing to validate import functionality, test data migration reliability, and ensure proper import operations through FFI. |
| `ffi_string.rs` | FFI integration tests for string handling and text operations through C interface. Tests string conversion, UTF-8 handling, and text marshaling via FFI. Dependencies: FFI string utilities, text handling. Used by: integration testing to validate string handling functionality, test text conversion reliability, and ensure proper string operations through FFI. |
| `kernel.rs` | FFI integration tests for transaction kernel operations and validation through C interface. Tests kernel creation, validation, and signature verification via FFI. Dependencies: kernel FFI, transaction validation. Used by: integration testing to validate kernel functionality, test transaction validation reliability, and ensure proper kernel operations through FFI. |
| `mod.rs` | FFI integration testing module coordinating all foreign function interface tests. Exports FFI test utilities, common test infrastructure, and integration test coordination for C interface validation. Dependencies: all FFI test modules. Used by: integration testing to coordinate FFI tests, provide common FFI testing infrastructure, and validate cross-language interface reliability. |
| `pending_inbound_transaction.rs` | FFI integration tests for pending inbound transaction handling through C interface. Tests inbound transaction processing, status monitoring, and transaction completion via FFI. Dependencies: wallet FFI, transaction processing. Used by: integration testing to validate inbound transaction functionality, test transaction processing reliability, and ensure proper inbound transaction handling through FFI. |
| `pending_inbound_transactions.rs` | FFI integration tests for pending inbound transaction collection management through C interface. Tests inbound transaction lists, batch processing, and collection operations via FFI. Dependencies: wallet FFI, transaction collections. Used by: integration testing to validate inbound transaction collection functionality, test batch processing reliability, and ensure proper transaction list management through FFI. |
| `pending_outbound_transaction.rs` | FFI integration tests for pending outbound transaction handling through C interface. Tests outbound transaction creation, broadcasting, and status tracking via FFI. Dependencies: wallet FFI, transaction broadcasting. Used by: integration testing to validate outbound transaction functionality, test transaction broadcasting reliability, and ensure proper outbound transaction handling through FFI. |
| `pending_outbound_transactions.rs` | FFI integration tests for pending outbound transaction collection management through C interface. Tests outbound transaction lists, batch operations, and collection handling via FFI. Dependencies: wallet FFI, transaction collections. Used by: integration testing to validate outbound transaction collection functionality, test batch operations reliability, and ensure proper transaction list management through FFI. |
| `private_key.rs` | FFI integration tests for private key operations and cryptographic key management through C interface. Tests private key generation, import/export, and cryptographic operations via FFI. Dependencies: crypto FFI, key management. Used by: integration testing to validate private key functionality, test key management reliability, and ensure proper cryptographic operations through FFI. |
| `public_key.rs` | FFI integration tests for public key operations and cryptographic verification through C interface. Tests public key derivation, validation, and cryptographic verification via FFI. Dependencies: crypto FFI, key validation. Used by: integration testing to validate public key functionality, test key derivation reliability, and ensure proper cryptographic verification through FFI. |
| `public_keys.rs` | FFI integration tests for public key collection management and batch key operations through C interface. Tests public key lists, key validation, and collection handling via FFI. Dependencies: crypto FFI, key collections. Used by: integration testing to validate public key collection functionality, test batch key operations reliability, and ensure proper key list management through FFI. |
| `seed_words.rs` | FFI integration tests for seed word functionality and mnemonic handling through C interface. Tests seed word generation, validation, and wallet recovery via FFI. Dependencies: wallet FFI, mnemonic utilities. Used by: integration testing to validate seed word functionality, test mnemonic reliability, and ensure proper wallet recovery operations through FFI. |
| `transaction_send_status.rs` | FFI integration tests for transaction send status tracking and monitoring through C interface. Tests transaction status updates, send progress, and status notifications via FFI. Dependencies: wallet FFI, transaction status. Used by: integration testing to validate transaction status functionality, test status tracking reliability, and ensure proper send status monitoring through FFI. |
| `transport_config.rs` | FFI integration tests for transport configuration and network transport setup through C interface. Tests transport configuration, network setup, and communication parameters via FFI. Dependencies: transport FFI, network configuration. Used by: integration testing to validate transport configuration functionality, test network setup reliability, and ensure proper transport management through FFI. |
| `vector.rs` | FFI integration tests for vector/array data structures and collection operations through C interface. Tests vector creation, manipulation, and memory management via FFI. Dependencies: FFI utilities, collection handling. Used by: integration testing to validate vector functionality, test collection operations reliability, and ensure proper memory management for arrays through FFI. |
| `wallet.rs` | FFI integration tests for core wallet functionality and operations through C interface. Tests wallet creation, management, transactions, and core wallet operations via FFI. Dependencies: wallet FFI, wallet core. Used by: integration testing to validate wallet functionality, test wallet operations reliability, and ensure proper wallet management through FFI. |
| `wallet_address.rs` | FFI integration tests for wallet address functionality and address management through C interface. Tests address generation, validation, and address operations via FFI. Dependencies: wallet FFI, address handling. Used by: integration testing to validate wallet address functionality, test address operations reliability, and ensure proper address management through FFI. |

#### integration_tests/tests/

| File | Description |
|------|-------------|
| `cucumber.rs` | Cucumber integration test runner and behavioral test execution coordinator. Exports cucumber test configuration, step definitions, and behavioral test execution infrastructure. Dependencies: cucumber framework, test infrastructure. Used by: integration testing to run behavioral tests, execute cucumber scenarios, and provide BDD-style testing for Tari functionality. |

##### integration_tests/tests/features/

| File | Description |
|------|-------------|
| `BaseNodeConnectivity.feature` | Cucumber feature file defining behavioral tests for base node connectivity and network communication. Specifies test scenarios for node connections, peer discovery, and network resilience. Dependencies: none. Used by: cucumber tests to validate base node connectivity, test network communication patterns, and ensure proper peer-to-peer networking functionality. |
| `BlockExplorerGRPC.feature` | Cucumber feature file defining behavioral tests for block explorer gRPC API functionality. Specifies test scenarios for block queries, transaction lookup, and blockchain data access via gRPC. Dependencies: none. Used by: cucumber tests to validate block explorer API, test gRPC interface reliability, and ensure proper blockchain data access functionality. |
| `BlockTemplate.feature` | Cucumber feature file defining behavioral tests for block template creation and mining coordination. Specifies test scenarios for block generation, template validation, and mining operations. Dependencies: none. Used by: cucumber tests to validate block template functionality, test mining coordination, and ensure proper block generation processes. |
| `Mempool.feature` | Cucumber feature file defining behavioral tests for mempool functionality and transaction management. Specifies test scenarios for transaction submission, mempool validation, and transaction prioritization. Dependencies: none. Used by: cucumber tests to validate mempool operations, test transaction handling, and ensure proper transaction pool management functionality. |
| `MergeMining.feature` | Cucumber feature file defining behavioral tests for merge mining functionality and Bitcoin integration. Specifies test scenarios for merge mining operations, proxy coordination, and cross-chain mining. Dependencies: none. Used by: cucumber tests to validate merge mining functionality, test Bitcoin integration, and ensure proper cross-chain mining coordination. |
| `Propagation.feature` | Cucumber feature file defining behavioral tests for message and block propagation across the network. Specifies test scenarios for message routing, block distribution, and network propagation efficiency. Dependencies: none. Used by: cucumber tests to validate propagation functionality, test network message distribution, and ensure proper peer-to-peer communication patterns. |
| `Recovery.feature` | Cucumber feature file defining behavioral tests for wallet and blockchain recovery functionality. Specifies test scenarios for wallet recovery, blockchain sync recovery, and state restoration. Dependencies: none. Used by: cucumber tests to validate recovery mechanisms, test disaster recovery procedures, and ensure proper system restoration capabilities. |
| `Reorgs.feature` | Cucumber feature file defining behavioral tests for blockchain reorganization handling and chain reorg scenarios. Specifies test scenarios for chain splits, reorg resolution, and consensus management. Dependencies: none. Used by: cucumber tests to validate reorganization handling, test chain conflict resolution, and ensure proper blockchain consensus mechanisms. |
| `StressTest.feature` | Cucumber feature file defining behavioral stress tests for system performance and scalability validation. Specifies test scenarios for high load, concurrent operations, and system stress conditions. Dependencies: none. Used by: cucumber tests to validate system performance, test scalability limits, and ensure proper behavior under stress conditions. |
| `Sync.feature` | Cucumber feature file defining behavioral tests for blockchain synchronization and state sync functionality. Specifies test scenarios for initial sync, partial sync, and sync recovery operations. Dependencies: none. Used by: cucumber tests to validate synchronization mechanisms, test sync performance, and ensure proper blockchain state consistency. |
| `TransactionInfo.feature` | Cucumber feature file defining behavioral tests for transaction information retrieval and transaction data queries. Specifies test scenarios for transaction lookup, status queries, and transaction history access. Dependencies: none. Used by: cucumber tests to validate transaction information systems, test transaction queries, and ensure proper transaction data access functionality. |
| `WalletCli.feature` | Cucumber feature file defining behavioral tests for wallet command-line interface functionality. Specifies test scenarios for CLI commands, wallet operations, and command-line interaction patterns. Dependencies: none. Used by: cucumber tests to validate wallet CLI functionality, test command-line operations, and ensure proper user interface behavior. |
| `WalletFFI.feature` | Cucumber feature file defining behavioral tests for wallet Foreign Function Interface (FFI) functionality. Specifies test scenarios for FFI operations, cross-language integration, and C API functionality. Dependencies: none. Used by: cucumber tests to validate wallet FFI operations, test cross-language compatibility, and ensure proper C interface functionality. |
| `WalletMonitoring.feature` | Cucumber feature file defining behavioral tests for wallet monitoring and status tracking functionality. Specifies test scenarios for wallet status monitoring, health checks, and operational monitoring. Dependencies: none. Used by: cucumber tests to validate wallet monitoring systems, test status tracking, and ensure proper wallet health monitoring capabilities. |
| `WalletQuery.feature` | Cucumber feature file defining behavioral tests for wallet query functionality and data retrieval operations. Specifies test scenarios for balance queries, transaction history, and wallet data access. Dependencies: none. Used by: cucumber tests to validate wallet query operations, test data retrieval, and ensure proper wallet information access functionality. |
| `WalletRecovery.feature` | Cucumber feature file defining behavioral tests for wallet recovery and restoration functionality. Specifies test scenarios for seed phrase recovery, wallet restoration, and backup recovery operations. Dependencies: none. Used by: cucumber tests to validate wallet recovery mechanisms, test backup restoration, and ensure proper wallet recovery procedures. |
| `WalletRoutingMechanism.feature` | Cucumber feature file defining behavioral tests for wallet routing mechanism and message routing functionality. Specifies test scenarios for message routing, peer discovery, and communication pathways. Dependencies: none. Used by: cucumber tests to validate wallet routing functionality, test message routing efficiency, and ensure proper peer communication mechanisms. |
| `WalletTransactions.feature` | Cucumber feature file defining behavioral tests for wallet transaction functionality and transaction management. Specifies test scenarios for transaction creation, sending, receiving, and transaction lifecycle management. Dependencies: none. Used by: cucumber tests to validate wallet transaction operations, test transaction processing, and ensure proper transaction management functionality. |
| `WalletTransfer.feature` | Cucumber feature file defining behavioral tests for wallet transfer functionality and fund transfer operations. Specifies test scenarios for money transfers, transfer validation, and transfer completion tracking. Dependencies: none. Used by: cucumber tests to validate wallet transfer operations, test fund movement, and ensure proper transfer functionality. |

##### integration_tests/tests/steps/

| File | Description |
|------|-------------|
| `merge_mining_steps.rs` | Cucumber step definitions for merge mining integration test scenarios. Exports step implementations for merge mining operations, proxy management, and Bitcoin integration testing. Dependencies: cucumber framework, merge mining infrastructure. Used by: cucumber tests to implement merge mining test steps, coordinate mining operations, and validate cross-chain mining functionality. |
| `mining_steps.rs` | Cucumber step definitions for mining integration test scenarios. Exports step implementations for block mining, mining coordination, and mining process management testing. Dependencies: cucumber framework, mining infrastructure. Used by: cucumber tests to implement mining test steps, coordinate mining operations, and validate block generation functionality. |
| `mod.rs` | Cucumber step definitions module coordinating all behavioral test step implementations. Exports step definition modules and common step utilities for integration testing. Dependencies: all step definition modules. Used by: cucumber tests to coordinate step definitions, provide common step infrastructure, and organize behavioral test implementation. |
| `node_steps.rs` | Cucumber step definitions for base node integration test scenarios. Exports step implementations for node operations, network connectivity, and blockchain functionality testing. Dependencies: cucumber framework, base node infrastructure. Used by: cucumber tests to implement node test steps, coordinate node operations, and validate blockchain node functionality. |
| `wallet_cli_steps.rs` | Cucumber step definitions for wallet CLI integration test scenarios. Exports step implementations for command-line wallet operations, CLI commands, and wallet interface testing. Dependencies: cucumber framework, wallet CLI infrastructure. Used by: cucumber tests to implement wallet CLI test steps, validate command-line operations, and test wallet user interface functionality. |
| `wallet_ffi_steps.rs` | Cucumber step definitions for wallet FFI integration test scenarios. Exports step implementations for FFI operations, cross-language integration, and C API testing. Dependencies: cucumber framework, wallet FFI infrastructure. Used by: cucumber tests to implement wallet FFI test steps, validate FFI operations, and test cross-language compatibility. |
| `wallet_steps.rs` | Cucumber step definitions for wallet integration test scenarios. Exports step implementations for wallet operations, transaction processing, and wallet functionality testing. Dependencies: cucumber framework, wallet infrastructure. Used by: cucumber tests to implement wallet test steps, coordinate wallet operations, and validate wallet functionality across integration scenarios. |

### meta/

| File | Description |
|------|-------------|
| `hashes.txt` | Release artifact verification hashes for Minotari applications providing integrity validation for distributed binaries. Contains SHA-256 checksums for base node and console wallet binaries across platforms (macOS .pkg, Linux .zip, Windows .exe) with version and git commit information. Essential for users to verify downloaded binaries match official releases, preventing tampering and ensuring authentic software distribution. Used in conjunction with GPG signatures for complete release verification workflow. |
| `hashes.txt.bad.sig` | Invalid GPG signature file for hash verification demonstrating signature validation failure. Used for testing signature verification systems and demonstrating invalid signature handling. Dependencies: GPG infrastructure. Used by: testing and verification processes to validate signature checking, test error handling, and demonstrate proper signature validation procedures. |
| `hashes.txt.sig` | GPG signature file for hash verification and release integrity validation. Contains cryptographic signature for verifying the authenticity and integrity of release hashes. Dependencies: GPG infrastructure, corresponding hashes file. Used by: release verification processes to validate hash integrity, verify release authenticity, and ensure secure distribution of Tari releases. |

#### meta/assets/

| File | Description |
|------|-------------|
| `rustdoc-include-js-header.html` | HTML header template for including JavaScript assets in Rust documentation generation. Provides custom JavaScript integration for enhanced documentation features and interactive elements. Dependencies: rustdoc system. Used by: documentation build process to include custom JavaScript functionality, enhance documentation presentation, and provide interactive documentation features. |
| `rustdoc-include-katex-header.html` | HTML header template for including KaTeX math rendering in Rust documentation. Provides mathematical notation support and LaTeX-style equation rendering for technical documentation. Dependencies: KaTeX library, rustdoc system. Used by: documentation build process to render mathematical formulas, display cryptographic equations, and provide enhanced technical documentation with mathematical notation. |

#### meta/crates.io/

| File | Description |
|------|-------------|
| `update_owners.sh` | Shell script for updating crate ownership information on crates.io registry. Manages crate publishing permissions, maintainer access, and ownership coordination for Tari crates. Dependencies: crates.io CLI tools. Used by: maintainers to manage crate ownership, update publishing permissions, and coordinate package maintenance on the Rust package registry. |

#### meta/gpg_keys/

| File | Description |
|------|-------------|
| `CjS77.asc` | GPG public key file for CjS77 team member used for code signing and release verification. Contains ASCII-armored public key for cryptographic verification of commits and releases. Dependencies: GPG infrastructure. Used by: verification processes to validate code signatures, verify release authenticity, and ensure secure development practices. |
| `README.md` | Documentation explaining GPG key management and verification procedures for the Tari project. Provides instructions for key verification, signature validation, and secure development practices. Dependencies: none. Used by: developers and users to understand GPG key verification, validate signatures, and maintain secure development workflows. |
| `cifko.asc` | GPG public key file for cifko team member used for code signing and release verification. Contains ASCII-armored public key for cryptographic verification of commits and releases. Dependencies: GPG infrastructure. Used by: verification processes to validate code signatures, verify release authenticity, and ensure secure development practices. |
| `hansieodendaal.asc` | GPG public key file for hansieodendaal team member used for code signing and release verification. Contains ASCII-armored public key for cryptographic verification of commits and releases. Dependencies: GPG infrastructure. Used by: verification processes to validate code signatures, verify release authenticity, and ensure secure development practices. |
| `sdbondi.asc` | GPG public key file for sdbondi team member used for code signing and release verification. Contains ASCII-armored public key for cryptographic verification of commits and releases. Dependencies: GPG infrastructure. Used by: verification processes to validate code signatures, verify release authenticity, and ensure secure development practices. |
| `stringhandler.asc` | GPG public key file for stringhandler team member used for code signing and release verification. Contains ASCII-armored public key for cryptographic verification of commits and releases. Dependencies: GPG infrastructure. Used by: verification processes to validate code signatures, verify release authenticity, and ensure secure development practices. |
| `swvheerden.asc` | GPG public key file for swvheerden team member used for code signing and release verification. Contains ASCII-armored public key for cryptographic verification of commits and releases. Dependencies: GPG infrastructure. Used by: verification processes to validate code signatures, verify release authenticity, and ensure secure development practices. |
| `tari-bot.asc` | GPG public key file for tari-bot automated system used for automated code signing and CI/CD operations. Contains ASCII-armored public key for cryptographic verification of automated commits and releases. Dependencies: GPG infrastructure. Used by: automated systems to validate bot signatures, verify automated releases, and ensure secure CI/CD practices. |

#### meta/img/

| File | Description |
|------|-------------|
| `hacker1.webp` | WebP image asset for documentation or marketing materials. Provides visual content for project documentation, presentations, or promotional materials related to the Tari project. Dependencies: none. Used by: documentation system, marketing materials, or website to provide visual content and enhance project presentation. |

### scripts/

| File | Description |
|------|-------------|
| `build_dists_tarball.sh` | Shell script for building distribution tarballs and packaging Tari releases. Automates the creation of release packages, binary distributions, and deployment artifacts. Dependencies: build tools, packaging utilities. Used by: release process to create distribution packages, generate release artifacts, and prepare software for distribution across platforms. |
| `code_coverage.sh` | Shell script for generating code coverage reports and analyzing test coverage. Automates code coverage collection, report generation, and coverage analysis for quality assurance. Dependencies: coverage tools, test frameworks. Used by: CI/CD and development processes to measure test coverage, generate coverage reports, and ensure adequate testing of the codebase. |
| `create_bundle.sh` | Shell script for creating application bundles and packaging Tari components together. Automates bundle creation, dependency management, and component packaging for deployment. Dependencies: packaging tools, application components. Used by: deployment process to create application bundles, package related components, and prepare unified deployment packages. |
| `cross_compile_tooling.sh` | Shell script for setting up cross-compilation tooling and build environments. Automates toolchain installation, target configuration, and cross-compilation setup for multiple platforms. Dependencies: cross-compilation tools, build utilities. Used by: build process to enable cross-platform compilation, configure build environments, and support multi-architecture builds. |
| `cross_compile_ubuntu_18-pre-build.sh` | Shell script for Ubuntu 18.04 cross-compilation pre-build setup and environment preparation. Configures build environment, installs dependencies, and prepares toolchain for Ubuntu 18.04 cross-compilation. Dependencies: Ubuntu 18.04 build tools. Used by: cross-compilation process to prepare Ubuntu 18.04 build environment, configure dependencies, and enable legacy platform support. |
| `env_sample` | Sample environment configuration file providing template for environment variable setup. Contains example configurations for development, testing, and deployment environments. Dependencies: none. Used by: developers and operators to configure environment variables, set up development environments, and understand required configuration parameters. |
| `file_license_check.sh` | Shell script for checking license headers and ensuring license compliance across source files. Validates license headers, checks copyright notices, and ensures proper licensing attribution. Dependencies: text processing tools. Used by: CI/CD and development processes to enforce license compliance, validate copyright headers, and maintain proper licensing across the codebase. |
| `generate-coinsplits.ps1` | PowerShell script for generating coin split configurations and managing coin distribution parameters. Automates coin split calculations, configuration generation, and distribution planning. Dependencies: PowerShell, calculation utilities. Used by: network configuration to generate coin split parameters, manage token distribution, and configure economic parameters. |
| `install_tor.sh` | Shell script for installing and configuring Tor networking software for anonymous communications. Automates Tor installation, configuration setup, and integration with Tari networking. Dependencies: Tor software, system package managers. Used by: deployment and development processes to install Tor, configure anonymous networking, and enable privacy features. |
| `install_ubuntu_dependencies-cross_compile.sh` | Shell script for installing Ubuntu dependencies required for cross-compilation builds. Automates dependency installation, toolchain setup, and build environment configuration for Ubuntu cross-compilation. Dependencies: Ubuntu package manager, cross-compilation tools. Used by: build process to install cross-compilation dependencies, configure Ubuntu build environment, and enable multi-platform builds. |
| `install_ubuntu_dependencies-rust-arm64.sh` | Shell script for installing Ubuntu dependencies required for ARM64 Rust compilation. Automates ARM64 toolchain installation, dependency setup, and build environment configuration for ARM64 targets. Dependencies: Ubuntu package manager, ARM64 cross-compilation tools. Used by: build process to install ARM64 dependencies, configure ARM64 build environment, and enable ARM64 Rust compilation. |
| `install_ubuntu_dependencies-rust.sh` | Shell script for installing Ubuntu dependencies required for Rust development and compilation. Automates Rust toolchain installation, dependency setup, and development environment configuration. Dependencies: Ubuntu package manager, Rust ecosystem. Used by: development setup to install Rust dependencies, configure development environment, and prepare Ubuntu systems for Tari development. |
| `install_ubuntu_dependencies.sh` | Ubuntu/Debian dependency installation script for Tari development environment setup. Installs essential packages including SSL libraries (openssl, libssl-dev), SQLite development libraries, build tools (cmake, make, clang, g++), protocol buffer compiler, ncurses libraries, hardware device support (libudev-dev, libhidapi-dev), and development utilities. Provides standardized dependency setup for Ubuntu-based development environments, ensuring all required system libraries are available for building and running Tari applications. |
| `publish_crates.sh` | Shell script for publishing Tari crates to crates.io registry. Automates crate publishing, version management, and release coordination for Rust packages. Dependencies: cargo publishing tools, crates.io credentials. Used by: release process to publish crates, manage package versions, and coordinate Rust package releases to the public registry. |
| `sign-hashes.sh` | GPG hash signing script that digitally signs the meta/hashes.txt file using GPG detached signature. Creates a corresponding .sig file for cryptographic verification of the hash file integrity. Used in release processes to ensure authenticity of distributed binary hashes. Requires GPG to be configured with appropriate signing keys. |
| `source_coverage.sh` | Source code coverage analysis script using cargo-llvm-cov. Automatically installs cargo-llvm-cov if missing, then runs comprehensive test coverage analysis across the workspace. Excludes application binaries and utility crates from coverage measurement. Outputs HTML format locally or LCOV format in CI environments. Configures 90%/66% coverage watermarks for reporting. Used for continuous integration coverage reporting and development quality assurance. |
| `test_in_docker.sh` | Docker-based testing script that runs the complete Tari test suite in an isolated container environment. Uses the quay.io/tarilabs/rust_tari-build-with-deps:stable image for consistent build environment. Mounts current directory as /src in container, executes cargo build and cargo test. Provides interactive debugging access after test completion. Ensures reproducible testing across different development environments. |
| `update_crate_metadata.sh` | Automated version bumping script for Tari workspace crates. Updates version fields in Cargo.toml files across all infrastructure, base_layer, common, comms, and application crates. Takes target version as parameter and uses sed to perform regex-based version string replacement. Includes comprehensive list of all workspace crates to ensure consistent versioning across the entire project. Essential for coordinated releases and semantic versioning compliance. |

### supply-chain/

| File | Description |
|------|-------------|
| `audits.toml` | Cargo-vet security audit records for third-party dependencies. Contains manual security reviews and certifications for crates like dhat, linux-raw-sys, mintex, rustix, tari_core, tempfile, and thousands. Includes detailed audit notes covering unsafe code analysis, security vulnerability assessments, and safe-to-deploy criteria. Features audits from multiple organizations including Tari team, Coinspect security firm, and other trusted sources. Critical for supply chain security and dependency trust verification. |
| `config.toml` | Cargo-vet supply chain security configuration for dependency auditing and verification in the Tari project. Configures security audit imports from trusted organizations (Bytecode Alliance, Embark Studios, Fermyon, Google, Mozilla, Zcash), defines audit policies for all Tari crates (audit-as-crates-io = true), and lists exemptions for third-party dependencies with 'safe-to-deploy' criteria. Provides comprehensive dependency security verification ensuring all external crates meet security standards. Critical security infrastructure component protecting against supply chain attacks and maintaining dependency integrity. |
| `imports.lock` | Cargo-vet imports lock file tracking publisher verification and audit inheritance from trusted audit sources. Records publisher metadata including user IDs, login names, and publication timestamps for crates like bumpalo, core-foundation, encoding_rs, unicode libraries, and wit-bindgen-rt. Includes wildcard audits and inherited security certifications from organizations like Bytecode Alliance, Embark Studios, Google, and others. Ensures dependency authenticity through cryptographic publisher verification and trusted audit aggregation. |

---
*Generated by MCP Code Indexer on 2025-06-12 14:48:48*
